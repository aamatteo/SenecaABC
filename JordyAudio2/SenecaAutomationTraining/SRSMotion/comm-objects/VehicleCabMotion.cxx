/* ------------------------------------------------------------------ */
/*      item            : VehicleCabMotion.cxx
        generated by    : matteo (matteo)
        date            : Wed 15 Dec 2021
        category        : body file
        description     : DUECA Communication Object (DCO),
                          automatically generated by dueca-codegen
        codegen version : 110
        language        : C++
*/

#include "VehicleCabMotion.hxx"
#include <iostream>
#include <cassert>
#if !defined(__DCO_NOPACK)
#include <AmorphStore.hxx>
#include <PackUnpackTemplates.hxx>
#endif
#include <DataWriterArraySize.hxx>
#define DOBS(A)
#if !defined(__DCO_STANDALONE)
#include <Arena.hxx>
#include <ArenaPool.hxx>
#include <DataClassRegistrar.hxx>
#include <CommObjectMemberAccess.hxx>
#include <DCOFunctor.hxx>
#include <DCOMetaFunctor.hxx>

#define DO_INSTANTIATE
#include <DataSetSubsidiary.hxx>
#endif




#if !defined(__DCO_STANDALONE)
// static CommObjectMemberAccess objects, that can provide flexible access
// to the members of a VehicleCabMotion object
static ::dueca::CommObjectMemberAccess
  <VehicleCabMotion,double >
  VehicleCabMotion_member_xdotdot(&VehicleCabMotion::xdotdot, "xdotdot");
static ::dueca::CommObjectMemberAccess
  <VehicleCabMotion,double >
  VehicleCabMotion_member_ydotdot(&VehicleCabMotion::ydotdot, "ydotdot");
static ::dueca::CommObjectMemberAccess
  <VehicleCabMotion,double >
  VehicleCabMotion_member_zdotdot(&VehicleCabMotion::zdotdot, "zdotdot");
static ::dueca::CommObjectMemberAccess
  <VehicleCabMotion,double >
  VehicleCabMotion_member_fx(&VehicleCabMotion::fx, "fx");
static ::dueca::CommObjectMemberAccess
  <VehicleCabMotion,double >
  VehicleCabMotion_member_fy(&VehicleCabMotion::fy, "fy");
static ::dueca::CommObjectMemberAccess
  <VehicleCabMotion,double >
  VehicleCabMotion_member_fz(&VehicleCabMotion::fz, "fz");
static ::dueca::CommObjectMemberAccess
  <VehicleCabMotion,double >
  VehicleCabMotion_member_xdot(&VehicleCabMotion::xdot, "xdot");
static ::dueca::CommObjectMemberAccess
  <VehicleCabMotion,double >
  VehicleCabMotion_member_ydot(&VehicleCabMotion::ydot, "ydot");
static ::dueca::CommObjectMemberAccess
  <VehicleCabMotion,double >
  VehicleCabMotion_member_zdot(&VehicleCabMotion::zdot, "zdot");
static ::dueca::CommObjectMemberAccess
  <VehicleCabMotion,double >
  VehicleCabMotion_member_pdot(&VehicleCabMotion::pdot, "pdot");
static ::dueca::CommObjectMemberAccess
  <VehicleCabMotion,double >
  VehicleCabMotion_member_qdot(&VehicleCabMotion::qdot, "qdot");
static ::dueca::CommObjectMemberAccess
  <VehicleCabMotion,double >
  VehicleCabMotion_member_rdot(&VehicleCabMotion::rdot, "rdot");
static ::dueca::CommObjectMemberAccess
  <VehicleCabMotion,double >
  VehicleCabMotion_member_p(&VehicleCabMotion::p, "p");
static ::dueca::CommObjectMemberAccess
  <VehicleCabMotion,double >
  VehicleCabMotion_member_q(&VehicleCabMotion::q, "q");
static ::dueca::CommObjectMemberAccess
  <VehicleCabMotion,double >
  VehicleCabMotion_member_r(&VehicleCabMotion::r, "r");

// assemble the above entries into a table in the order in which they
// appear in the VehicleCabMotion object
static const ::dueca::CommObjectDataTable entriestable[] = {
  { &VehicleCabMotion_member_xdotdot },
  { &VehicleCabMotion_member_ydotdot },
  { &VehicleCabMotion_member_zdotdot },
  { &VehicleCabMotion_member_fx },
  { &VehicleCabMotion_member_fy },
  { &VehicleCabMotion_member_fz },
  { &VehicleCabMotion_member_xdot },
  { &VehicleCabMotion_member_ydot },
  { &VehicleCabMotion_member_zdot },
  { &VehicleCabMotion_member_pdot },
  { &VehicleCabMotion_member_qdot },
  { &VehicleCabMotion_member_rdot },
  { &VehicleCabMotion_member_p },
  { &VehicleCabMotion_member_q },
  { &VehicleCabMotion_member_r },
  { NULL }
};

#endif

// class name, static
const char * const VehicleCabMotion::classname = "VehicleCabMotion";

// magic number, hashed from class name and member names / classes
const uint32_t VehicleCabMotion::magic_check_number=0x56e52c00;

#if !defined(__DCO_STANDALONE)
// functor table, provides access to user-defined metafunctions through the
// data class registry
static dueca::functortable_type functortable;

// register this class, provides access to a packing/unpacking object,
// and to the member access tables
static ::dueca::DataClassRegistrar registrar
  (VehicleCabMotion::classname, NULL,
   entriestable, &functortable,
   new ::dueca::DataSetSubsidiary<VehicleCabMotion>());

#endif

#ifndef __CUSTOM_DEFAULT_CONSTRUCTOR
VehicleCabMotion::VehicleCabMotion()
{
  DOBS("default constructor VehicleCabMotion");
}
#endif

#ifndef __CUSTOM_FULL_CONSTRUCTOR
VehicleCabMotion::VehicleCabMotion(
        const double& xdotdot,
        const double& ydotdot,
        const double& zdotdot,
        const double& fx,
        const double& fy,
        const double& fz,
        const double& xdot,
        const double& ydot,
        const double& zdot,
        const double& pdot,
        const double& qdot,
        const double& rdot,
        const double& p,
        const double& q,
        const double& r) :
    xdotdot(xdotdot),
    ydotdot(ydotdot),
    zdotdot(zdotdot),
    fx(fx),
    fy(fy),
    fz(fz),
    xdot(xdot),
    ydot(ydot),
    zdot(zdot),
    pdot(pdot),
    qdot(qdot),
    rdot(rdot),
    p(p),
    q(q),
    r(r)
{
  DOBS("complete constructor VehicleCabMotion");
}
#endif

#ifndef __CUSTOM_FULLSINGLES_CONSTRUCTOR
#endif

#ifndef __CUSTOM_COPY_CONSTRUCTOR
VehicleCabMotion::VehicleCabMotion(const VehicleCabMotion& other):
    xdotdot(other.xdotdot),
    ydotdot(other.ydotdot),
    zdotdot(other.zdotdot),
    fx(other.fx),
    fy(other.fy),
    fz(other.fz),
    xdot(other.xdot),
    ydot(other.ydot),
    zdot(other.zdot),
    pdot(other.pdot),
    qdot(other.qdot),
    rdot(other.rdot),
    p(other.p),
    q(other.q),
    r(other.r)
{
  DOBS("copy constructor VehicleCabMotion");
}
#endif

#if !defined(__CUSTOM_AMORPHRESTORE_CONSTRUCTOR) && !defined(__DCO_NOPACK)
VehicleCabMotion::VehicleCabMotion(dueca::AmorphReStore& s):
        xdotdot(s),
        ydotdot(s),
        zdotdot(s),
        fx(s),
        fy(s),
        fz(s),
        xdot(s),
        ydot(s),
        zdot(s),
        pdot(s),
        qdot(s),
        rdot(s),
        p(s),
        q(s),
        r(s)
{
  DOBS("amorph constructor VehicleCabMotion");
}
#endif

#if !defined(__CUSTOM_ARRAY_SIZE_INIT_CONSTRUCTOR)
#endif

#ifndef __CUSTOM_DESTRUCTOR
VehicleCabMotion::~VehicleCabMotion()
{
  DOBS("destructor VehicleCabMotion");
}
#endif

#if !defined(__DCO_STANDALONE)
void* VehicleCabMotion::operator new(size_t size)
{
  DOBS("operator new VehicleCabMotion");
  static ::dueca::Arena* my_arena = arena_pool.findArena
    (sizeof(VehicleCabMotion));
  return my_arena->alloc(size);
}

void VehicleCabMotion::operator delete(void* v)
{
  DOBS("operator delete VehicleCabMotion");
  static ::dueca::Arena* my_arena = arena_pool.findArena
    (sizeof(VehicleCabMotion));
  my_arena->free(v);
}
#endif

#if !defined(__CUSTOM_FUNCTION_PACKDATADIFF) && !defined(__DCO_NOPACK)
void VehicleCabMotion::packDataDiff(::dueca::AmorphStore& s, const VehicleCabMotion& ref) const
{
  DOBS("packDataDiff VehicleCabMotion");
  ::dueca::IndexMemory im;
  ::dueca::checkandpackdiffsingle(this->xdotdot, ref.xdotdot,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->ydotdot, ref.ydotdot,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->zdotdot, ref.zdotdot,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->fx, ref.fx,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->fy, ref.fy,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->fz, ref.fz,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->xdot, ref.xdot,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->ydot, ref.ydot,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->zdot, ref.zdot,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->pdot, ref.pdot,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->qdot, ref.qdot,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->rdot, ref.rdot,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->p, ref.p,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->q, ref.q,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->r, ref.r,
                         s, im);
  im.closeoff(s);
}
#endif

#if !defined(__CUSTOM_FUNCTION_UNPACKDATA) && !defined(__DCO_NOPACK)
void VehicleCabMotion::unPackData(::dueca::AmorphReStore& s)
{
  DOBS("unPackData VehicleCabMotion");

  ::unPackData(s, this->xdotdot);
  ::unPackData(s, this->ydotdot);
  ::unPackData(s, this->zdotdot);
  ::unPackData(s, this->fx);
  ::unPackData(s, this->fy);
  ::unPackData(s, this->fz);
  ::unPackData(s, this->xdot);
  ::unPackData(s, this->ydot);
  ::unPackData(s, this->zdot);
  ::unPackData(s, this->pdot);
  ::unPackData(s, this->qdot);
  ::unPackData(s, this->rdot);
  ::unPackData(s, this->p);
  ::unPackData(s, this->q);
  ::unPackData(s, this->r);

}
#endif

#if !defined(__CUSTOM_FUNCTION_UNPACKDATADIFF) && !defined(__DCO_NOPACK)
void VehicleCabMotion::unPackDataDiff(dueca::AmorphReStore& s)
{
  DOBS("unPackDataDiff VehicleCabMotion");
  ::dueca::IndexRecall im;
  ::dueca::checkandunpackdiffsingle(this->xdotdot, s, im);
  ::dueca::checkandunpackdiffsingle(this->ydotdot, s, im);
  ::dueca::checkandunpackdiffsingle(this->zdotdot, s, im);
  ::dueca::checkandunpackdiffsingle(this->fx, s, im);
  ::dueca::checkandunpackdiffsingle(this->fy, s, im);
  ::dueca::checkandunpackdiffsingle(this->fz, s, im);
  ::dueca::checkandunpackdiffsingle(this->xdot, s, im);
  ::dueca::checkandunpackdiffsingle(this->ydot, s, im);
  ::dueca::checkandunpackdiffsingle(this->zdot, s, im);
  ::dueca::checkandunpackdiffsingle(this->pdot, s, im);
  ::dueca::checkandunpackdiffsingle(this->qdot, s, im);
  ::dueca::checkandunpackdiffsingle(this->rdot, s, im);
  ::dueca::checkandunpackdiffsingle(this->p, s, im);
  ::dueca::checkandunpackdiffsingle(this->q, s, im);
  ::dueca::checkandunpackdiffsingle(this->r, s, im);
}
#endif

#ifndef __CUSTOM_OPERATOR_EQUAL
bool VehicleCabMotion::operator == (const VehicleCabMotion& other) const
{
  DOBS("operator == VehicleCabMotion");
  if (this->xdotdot != other.xdotdot) return false;
  if (this->ydotdot != other.ydotdot) return false;
  if (this->zdotdot != other.zdotdot) return false;
  if (this->fx != other.fx) return false;
  if (this->fy != other.fy) return false;
  if (this->fz != other.fz) return false;
  if (this->xdot != other.xdot) return false;
  if (this->ydot != other.ydot) return false;
  if (this->zdot != other.zdot) return false;
  if (this->pdot != other.pdot) return false;
  if (this->qdot != other.qdot) return false;
  if (this->rdot != other.rdot) return false;
  if (this->p != other.p) return false;
  if (this->q != other.q) return false;
  if (this->r != other.r) return false;
  return true;
}
#endif

#ifndef __CUSTOM_OPERATOR_ASSIGN
VehicleCabMotion&
VehicleCabMotion::operator=(const VehicleCabMotion& other)
{
  DOBS("operator = VehicleCabMotion");
  if (this == &other) return *this;
  this->xdotdot = other.xdotdot;
  this->ydotdot = other.ydotdot;
  this->zdotdot = other.zdotdot;
  this->fx = other.fx;
  this->fy = other.fy;
  this->fz = other.fz;
  this->xdot = other.xdot;
  this->ydot = other.ydot;
  this->zdot = other.zdot;
  this->pdot = other.pdot;
  this->qdot = other.qdot;
  this->rdot = other.rdot;
  this->p = other.p;
  this->q = other.q;
  this->r = other.r;
  return *this;
}
#endif

#if !defined(__CUSTOM_FUNCTION_PACKDATA) && !defined(__DCO_NOPACK)
void VehicleCabMotion::packData(::dueca::AmorphStore& s) const
{
  DOBS("packData VehicleCabMotion");
  ::packData(s, this->xdotdot);
  ::packData(s, this->ydotdot);
  ::packData(s, this->zdotdot);
  ::packData(s, this->fx);
  ::packData(s, this->fy);
  ::packData(s, this->fz);
  ::packData(s, this->xdot);
  ::packData(s, this->ydot);
  ::packData(s, this->zdot);
  ::packData(s, this->pdot);
  ::packData(s, this->qdot);
  ::packData(s, this->rdot);
  ::packData(s, this->p);
  ::packData(s, this->q);
  ::packData(s, this->r);
}
#endif

#ifndef __CUSTOM_FUNCTION_PRINT
std::ostream & VehicleCabMotion::print(std::ostream& s) const
{
  s << "VehicleCabMotion("
    << "xdotdot=" << this->xdotdot << ','
    << "ydotdot=" << this->ydotdot << ','
    << "zdotdot=" << this->zdotdot << ','
    << "fx=" << this->fx << ','
    << "fy=" << this->fy << ','
    << "fz=" << this->fz << ','
    << "xdot=" << this->xdot << ','
    << "ydot=" << this->ydot << ','
    << "zdot=" << this->zdot << ','
    << "pdot=" << this->pdot << ','
    << "qdot=" << this->qdot << ','
    << "rdot=" << this->rdot << ','
    << "p=" << this->p << ','
    << "q=" << this->q << ','
    << "r=" << this->r
    << ')';
  return s;
}
#endif


