/* ------------------------------------------------------------------ */
/*      item            : MotionConfirm.cxx
        generated by    : matteo (matteo)
        date            : Wed 15 Dec 2021
        category        : body file
        description     : DUECA Communication Object (DCO),
                          automatically generated by dueca-codegen
        codegen version : 110
        language        : C++
*/

#include "MotionConfirm.hxx"
#include <iostream>
#include <cassert>
#if !defined(__DCO_NOPACK)
#include <AmorphStore.hxx>
#include <PackUnpackTemplates.hxx>
#endif
#include <DataWriterArraySize.hxx>
#define DOBS(A)
#if !defined(__DCO_STANDALONE)
#include <Arena.hxx>
#include <ArenaPool.hxx>
#include <DataClassRegistrar.hxx>
#include <CommObjectMemberAccess.hxx>
#include <DCOFunctor.hxx>
#include <DCOMetaFunctor.hxx>

#define DO_INSTANTIATE
#include <DataSetSubsidiary.hxx>
#endif




#if !defined(__DCO_STANDALONE)
// static CommObjectMemberAccess objects, that can provide flexible access
// to the members of a MotionConfirm object
static ::dueca::CommObjectMemberAccess
  <MotionConfirm,vstring >
  MotionConfirm_member_receiver(&MotionConfirm::receiver, "receiver");
static ::dueca::CommObjectMemberAccess
  <MotionConfirm,MotionConfirm::motion_position >
  MotionConfirm_member_position(&MotionConfirm::position, "position");

// assemble the above entries into a table in the order in which they
// appear in the MotionConfirm object
static const ::dueca::CommObjectDataTable entriestable[] = {
  { &MotionConfirm_member_receiver },
  { &MotionConfirm_member_position },
  { NULL }
};

#endif

// class name, static
const char * const MotionConfirm::classname = "MotionConfirm";

// magic number, hashed from class name and member names / classes
const uint32_t MotionConfirm::magic_check_number=0x477104fa;

#if !defined(__DCO_STANDALONE)
// functor table, provides access to user-defined metafunctions through the
// data class registry
static dueca::functortable_type functortable;

// register this class, provides access to a packing/unpacking object,
// and to the member access tables
static ::dueca::DataClassRegistrar registrar
  (MotionConfirm::classname, NULL,
   entriestable, &functortable,
   new ::dueca::DataSetSubsidiary<MotionConfirm>());

#endif

#ifndef __CUSTOM_DEFAULT_CONSTRUCTOR
MotionConfirm::MotionConfirm()
{
  DOBS("default constructor MotionConfirm");
}
#endif

#ifndef __CUSTOM_FULL_CONSTRUCTOR
MotionConfirm::MotionConfirm(
        const vstring& receiver,
        const motion_position& position) :
    receiver(receiver),
    position(position)
{
  DOBS("complete constructor MotionConfirm");
}
#endif

#ifndef __CUSTOM_FULLSINGLES_CONSTRUCTOR
#endif

#ifndef __CUSTOM_COPY_CONSTRUCTOR
MotionConfirm::MotionConfirm(const MotionConfirm& other):
    receiver(other.receiver),
    position(other.position)
{
  DOBS("copy constructor MotionConfirm");
}
#endif

#if !defined(__CUSTOM_AMORPHRESTORE_CONSTRUCTOR) && !defined(__DCO_NOPACK)
MotionConfirm::MotionConfirm(dueca::AmorphReStore& s):
        receiver(s),
        position(motion_position(uint8_t(s)))
{
  DOBS("amorph constructor MotionConfirm");
}
#endif

#if !defined(__CUSTOM_ARRAY_SIZE_INIT_CONSTRUCTOR)
#endif

#ifndef __CUSTOM_DESTRUCTOR
MotionConfirm::~MotionConfirm()
{
  DOBS("destructor MotionConfirm");
}
#endif

#if !defined(__DCO_STANDALONE)
void* MotionConfirm::operator new(size_t size)
{
  DOBS("operator new MotionConfirm");
  static ::dueca::Arena* my_arena = arena_pool.findArena
    (sizeof(MotionConfirm));
  return my_arena->alloc(size);
}

void MotionConfirm::operator delete(void* v)
{
  DOBS("operator delete MotionConfirm");
  static ::dueca::Arena* my_arena = arena_pool.findArena
    (sizeof(MotionConfirm));
  my_arena->free(v);
}
#endif

#if !defined(__CUSTOM_FUNCTION_PACKDATADIFF) && !defined(__DCO_NOPACK)
void MotionConfirm::packDataDiff(::dueca::AmorphStore& s, const MotionConfirm& ref) const
{
  DOBS("packDataDiff MotionConfirm");
  ::dueca::IndexMemory im;
  ::dueca::checkandpackdiffsingle(this->receiver, ref.receiver,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->position, ref.position,
                         s, im);
  im.closeoff(s);
}
#endif

#if !defined(__CUSTOM_FUNCTION_UNPACKDATA) && !defined(__DCO_NOPACK)
void MotionConfirm::unPackData(::dueca::AmorphReStore& s)
{
  DOBS("unPackData MotionConfirm");

  ::unPackData(s, this->receiver);
  ::unPackData(s, this->position);

}
#endif

#if !defined(__CUSTOM_FUNCTION_UNPACKDATADIFF) && !defined(__DCO_NOPACK)
void MotionConfirm::unPackDataDiff(dueca::AmorphReStore& s)
{
  DOBS("unPackDataDiff MotionConfirm");
  ::dueca::IndexRecall im;
  ::dueca::checkandunpackdiffsingle(this->receiver, s, im);
  ::dueca::checkandunpackdiffsingle(this->position, s, im);
}
#endif

#ifndef __CUSTOM_OPERATOR_EQUAL
bool MotionConfirm::operator == (const MotionConfirm& other) const
{
  DOBS("operator == MotionConfirm");
  if (this->receiver != other.receiver) return false;
  if (this->position != other.position) return false;
  return true;
}
#endif

#ifndef __CUSTOM_OPERATOR_ASSIGN
MotionConfirm&
MotionConfirm::operator=(const MotionConfirm& other)
{
  DOBS("operator = MotionConfirm");
  if (this == &other) return *this;
  this->receiver = other.receiver;
  this->position = other.position;
  return *this;
}
#endif

#if !defined(__CUSTOM_FUNCTION_PACKDATA) && !defined(__DCO_NOPACK)
void MotionConfirm::packData(::dueca::AmorphStore& s) const
{
  DOBS("packData MotionConfirm");
  ::packData(s, this->receiver);
  ::packData(s, this->position);
}
#endif

#ifndef __CUSTOM_FUNCTION_PRINT
std::ostream & MotionConfirm::print(std::ostream& s) const
{
  s << "MotionConfirm("
    << "receiver=" << this->receiver << ','
    << "position=" << this->position
    << ')';
  return s;
}
#endif


            #ifndef __CUSTOM_GETSTRING_motion_position
const char* const getString(const MotionConfirm::motion_position &o)
{
  static const char* motion_position_names[] = {
    "NEUTRAL",
    "DOWN"};

  return motion_position_names[int(o)];
}
#endif

#ifndef __CUSTOM_READFROMSTRING_motion_position
void readFromString(MotionConfirm::motion_position &o, const std::string& s)
{
  for (int ii = 2; ii--; ) {
    if (std::string(getString(MotionConfirm::motion_position(ii))) == s) {
      o = MotionConfirm::motion_position(ii);
      return;
    }
  }
  throw(dueca::ConversionNotDefined());
}
#endif

#if !defined(__CUSTOM_PACKDATA_motion_position) && !defined(__DCO_NOPACK)
void packData(::dueca::AmorphStore& s,
              const MotionConfirm::motion_position &o)
{ packData(s, uint8_t(o));}
#endif

#if !defined(__CUSTOM_UNPACKDATA_motion_position) && !defined(__DCO_NOPACK)
void unPackData(::dueca::AmorphReStore& s,
                MotionConfirm::motion_position &o)
{ uint8_t tmp(s); o = MotionConfirm::motion_position(tmp); }
#endif

namespace dueca {;
template <>
const char* getclassname<MotionConfirm::motion_position>()
{ return "MotionConfirm::motion_position"; }
};

