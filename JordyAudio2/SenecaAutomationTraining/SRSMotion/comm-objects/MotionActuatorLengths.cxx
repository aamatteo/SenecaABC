/* ------------------------------------------------------------------ */
/*      item            : MotionActuatorLengths.cxx
        generated by    : matteo (matteo)
        date            : Wed 15 Dec 2021
        category        : body file
        description     : DUECA Communication Object (DCO),
                          automatically generated by dueca-codegen
        codegen version : 110
        language        : C++
*/

#include "MotionActuatorLengths.hxx"
#include <iostream>
#include <cassert>
#if !defined(__DCO_NOPACK)
#include <AmorphStore.hxx>
#include <PackUnpackTemplates.hxx>
#endif
#include <DataWriterArraySize.hxx>
#define DOBS(A)
#if !defined(__DCO_STANDALONE)
#include <Arena.hxx>
#include <ArenaPool.hxx>
#include <DataClassRegistrar.hxx>
#include <CommObjectMemberAccess.hxx>
#include <DCOFunctor.hxx>
#include <DCOMetaFunctor.hxx>

#define DO_INSTANTIATE
#include <DataSetSubsidiary.hxx>
#endif




#if !defined(__DCO_STANDALONE)
// static CommObjectMemberAccess objects, that can provide flexible access
// to the members of a MotionActuatorLengths object
static ::dueca::CommObjectMemberAccess
  <MotionActuatorLengths,int >
  MotionActuatorLengths_member_status(&MotionActuatorLengths::status, "status");
static ::dueca::CommObjectMemberAccess
  <MotionActuatorLengths,dueca::fixvector<6,double> >
  MotionActuatorLengths_member_j(&MotionActuatorLengths::j, "j");
static ::dueca::CommObjectMemberAccess
  <MotionActuatorLengths,dueca::fixvector<6,double> >
  MotionActuatorLengths_member_jd(&MotionActuatorLengths::jd, "jd");
static ::dueca::CommObjectMemberAccess
  <MotionActuatorLengths,dueca::fixvector<6,double> >
  MotionActuatorLengths_member_jdd(&MotionActuatorLengths::jdd, "jdd");

// assemble the above entries into a table in the order in which they
// appear in the MotionActuatorLengths object
static const ::dueca::CommObjectDataTable entriestable[] = {
  { &MotionActuatorLengths_member_status },
  { &MotionActuatorLengths_member_j },
  { &MotionActuatorLengths_member_jd },
  { &MotionActuatorLengths_member_jdd },
  { NULL }
};

#endif

// class name, static
const char * const MotionActuatorLengths::classname = "MotionActuatorLengths";

// magic number, hashed from class name and member names / classes
const uint32_t MotionActuatorLengths::magic_check_number=0xae278c19;

#if !defined(__DCO_STANDALONE)
// functor table, provides access to user-defined metafunctions through the
// data class registry
static dueca::functortable_type functortable;

// register this class, provides access to a packing/unpacking object,
// and to the member access tables
static ::dueca::DataClassRegistrar registrar
  (MotionActuatorLengths::classname, NULL,
   entriestable, &functortable,
   new ::dueca::DataSetSubsidiary<MotionActuatorLengths>());

#endif

#ifndef __CUSTOM_DEFAULT_CONSTRUCTOR
MotionActuatorLengths::MotionActuatorLengths()
{
  DOBS("default constructor MotionActuatorLengths");
}
#endif

#ifndef __CUSTOM_FULL_CONSTRUCTOR
MotionActuatorLengths::MotionActuatorLengths(
        const int& status,
        const dueca::fixvector<6,double>& j,
        const dueca::fixvector<6,double>& jd,
        const dueca::fixvector<6,double>& jdd) :
    status(status),
    j(j),
    jd(jd),
    jdd(jdd)
{
  DOBS("complete constructor MotionActuatorLengths");
}
#endif

#ifndef __CUSTOM_FULLSINGLES_CONSTRUCTOR
MotionActuatorLengths::MotionActuatorLengths(
        const int& status) :
    status(status)
{
  DOBS("complete single argument constructor MotionActuatorLengths");
}
#endif

#ifndef __CUSTOM_COPY_CONSTRUCTOR
MotionActuatorLengths::MotionActuatorLengths(const MotionActuatorLengths& other):
    status(other.status),
    j(other.j),
    jd(other.jd),
    jdd(other.jdd)
{
  DOBS("copy constructor MotionActuatorLengths");
}
#endif

#if !defined(__CUSTOM_AMORPHRESTORE_CONSTRUCTOR) && !defined(__DCO_NOPACK)
MotionActuatorLengths::MotionActuatorLengths(dueca::AmorphReStore& s):
        status(s)
{
  ::dueca::unpackiterable(s, this->j,
                          dueca::pack_traits<dueca::fixvector<6,double> >()); 
  ::dueca::unpackiterable(s, this->jd,
                          dueca::pack_traits<dueca::fixvector<6,double> >()); 
  ::dueca::unpackiterable(s, this->jdd,
                          dueca::pack_traits<dueca::fixvector<6,double> >()); 
  DOBS("amorph constructor MotionActuatorLengths");
}
#endif

#if !defined(__CUSTOM_ARRAY_SIZE_INIT_CONSTRUCTOR)
#endif

#ifndef __CUSTOM_DESTRUCTOR
MotionActuatorLengths::~MotionActuatorLengths()
{
  DOBS("destructor MotionActuatorLengths");
}
#endif

#if !defined(__DCO_STANDALONE)
void* MotionActuatorLengths::operator new(size_t size)
{
  DOBS("operator new MotionActuatorLengths");
  static ::dueca::Arena* my_arena = arena_pool.findArena
    (sizeof(MotionActuatorLengths));
  return my_arena->alloc(size);
}

void MotionActuatorLengths::operator delete(void* v)
{
  DOBS("operator delete MotionActuatorLengths");
  static ::dueca::Arena* my_arena = arena_pool.findArena
    (sizeof(MotionActuatorLengths));
  my_arena->free(v);
}
#endif

#if !defined(__CUSTOM_FUNCTION_PACKDATADIFF) && !defined(__DCO_NOPACK)
void MotionActuatorLengths::packDataDiff(::dueca::AmorphStore& s, const MotionActuatorLengths& ref) const
{
  DOBS("packDataDiff MotionActuatorLengths");
  ::dueca::IndexMemory im;
  ::dueca::checkandpackdiffsingle(this->status, ref.status,
                         s, im);
  ::dueca::checkandpackdiffiterable(this->j, ref.j, s, im,
                          dueca::diffpack_traits<dueca::fixvector<6,double> >());
  ::dueca::checkandpackdiffiterable(this->jd, ref.jd, s, im,
                          dueca::diffpack_traits<dueca::fixvector<6,double> >());
  ::dueca::checkandpackdiffiterable(this->jdd, ref.jdd, s, im,
                          dueca::diffpack_traits<dueca::fixvector<6,double> >());
  im.closeoff(s);
}
#endif

#if !defined(__CUSTOM_FUNCTION_UNPACKDATA) && !defined(__DCO_NOPACK)
void MotionActuatorLengths::unPackData(::dueca::AmorphReStore& s)
{
  DOBS("unPackData MotionActuatorLengths");

  ::unPackData(s, this->status);

  ::dueca::unpackiterable(s, this->j,
                          dueca::pack_traits<dueca::fixvector<6,double> >()); 
  ::dueca::unpackiterable(s, this->jd,
                          dueca::pack_traits<dueca::fixvector<6,double> >()); 
  ::dueca::unpackiterable(s, this->jdd,
                          dueca::pack_traits<dueca::fixvector<6,double> >()); 
}
#endif

#if !defined(__CUSTOM_FUNCTION_UNPACKDATADIFF) && !defined(__DCO_NOPACK)
void MotionActuatorLengths::unPackDataDiff(dueca::AmorphReStore& s)
{
  DOBS("unPackDataDiff MotionActuatorLengths");
  ::dueca::IndexRecall im;
  ::dueca::checkandunpackdiffsingle(this->status, s, im);
  ::dueca::checkandunpackdiffiterable(this->j, s, im,
                          dueca::diffpack_traits<dueca::fixvector<6,double> >());
  ::dueca::checkandunpackdiffiterable(this->jd, s, im,
                          dueca::diffpack_traits<dueca::fixvector<6,double> >());
  ::dueca::checkandunpackdiffiterable(this->jdd, s, im,
                          dueca::diffpack_traits<dueca::fixvector<6,double> >());
}
#endif

#ifndef __CUSTOM_OPERATOR_EQUAL
bool MotionActuatorLengths::operator == (const MotionActuatorLengths& other) const
{
  DOBS("operator == MotionActuatorLengths");
  if (this->status != other.status) return false;
  if (this->j != other.j) return false;
  if (this->jd != other.jd) return false;
  if (this->jdd != other.jdd) return false;
  return true;
}
#endif

#ifndef __CUSTOM_OPERATOR_ASSIGN
MotionActuatorLengths&
MotionActuatorLengths::operator=(const MotionActuatorLengths& other)
{
  DOBS("operator = MotionActuatorLengths");
  if (this == &other) return *this;
  this->status = other.status;
  this->j = other.j;
  this->jd = other.jd;
  this->jdd = other.jdd;
  return *this;
}
#endif

#if !defined(__CUSTOM_FUNCTION_PACKDATA) && !defined(__DCO_NOPACK)
void MotionActuatorLengths::packData(::dueca::AmorphStore& s) const
{
  DOBS("packData MotionActuatorLengths");
  ::packData(s, this->status);
  ::dueca::packiterable(s, this->j,
                        dueca::pack_traits<dueca::fixvector<6,double> >()); 
  ::dueca::packiterable(s, this->jd,
                        dueca::pack_traits<dueca::fixvector<6,double> >()); 
  ::dueca::packiterable(s, this->jdd,
                        dueca::pack_traits<dueca::fixvector<6,double> >()); 
}
#endif

#ifndef __CUSTOM_FUNCTION_PRINT
std::ostream & MotionActuatorLengths::print(std::ostream& s) const
{
  s << "MotionActuatorLengths("
    << "status=" << this->status << ','
    << "j={";
  for (dueca::fixvector<6,double>::const_iterator ii = this->j.begin();
       ii != this->j.end(); ii++) {
    if (ii != this->j.begin()) s << ',';
    s << (*ii);
  }
  s << "},"
    << "jd={";
  for (dueca::fixvector<6,double>::const_iterator ii = this->jd.begin();
       ii != this->jd.end(); ii++) {
    if (ii != this->jd.begin()) s << ',';
    s << (*ii);
  }
  s << "},"
    << "jdd={";
  for (dueca::fixvector<6,double>::const_iterator ii = this->jdd.begin();
       ii != this->jdd.end(); ii++) {
    if (ii != this->jdd.begin()) s << ',';
    s << (*ii);
  }
  s << "}"
    << ')';
  return s;
}
#endif


