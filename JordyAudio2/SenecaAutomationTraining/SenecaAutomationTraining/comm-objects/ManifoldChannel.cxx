/* ------------------------------------------------------------------ */
/*      item            : ManifoldChannel.cxx
        generated by    : matteo (matteo)
        date            : Wed 15 Dec 2021
        category        : body file
        description     : DUECA Communication Object (DCO),
                          automatically generated by dueca-codegen
        codegen version : 110
        language        : C++
*/

#include "ManifoldChannel.hxx"
#include <iostream>
#include <cassert>
#if !defined(__DCO_NOPACK)
#include <AmorphStore.hxx>
#include <PackUnpackTemplates.hxx>
#endif
#include <DataWriterArraySize.hxx>
#define DOBS(A)
#if !defined(__DCO_STANDALONE)
#include <Arena.hxx>
#include <ArenaPool.hxx>
#include <DataClassRegistrar.hxx>
#include <CommObjectMemberAccess.hxx>
#include <DCOFunctor.hxx>
#include <DCOMetaFunctor.hxx>

#define DO_INSTANTIATE
#include <DataSetSubsidiary.hxx>
#endif




#if !defined(__DCO_STANDALONE)
// static CommObjectMemberAccess objects, that can provide flexible access
// to the members of a ManifoldChannel object
static ::dueca::CommObjectMemberAccess
  <ManifoldChannel,float >
  ManifoldChannel_member_map_l(&ManifoldChannel::map_l, "map_l");
static ::dueca::CommObjectMemberAccess
  <ManifoldChannel,float >
  ManifoldChannel_member_map_r(&ManifoldChannel::map_r, "map_r");

// assemble the above entries into a table in the order in which they
// appear in the ManifoldChannel object
static const ::dueca::CommObjectDataTable entriestable[] = {
  { &ManifoldChannel_member_map_l },
  { &ManifoldChannel_member_map_r },
  { NULL }
};

#endif

// class name, static
const char * const ManifoldChannel::classname = "ManifoldChannel";

// magic number, hashed from class name and member names / classes
const uint32_t ManifoldChannel::magic_check_number=0xf181b6;

#if !defined(__DCO_STANDALONE)
// functor table, provides access to user-defined metafunctions through the
// data class registry
static dueca::functortable_type functortable;

// register this class, provides access to a packing/unpacking object,
// and to the member access tables
static ::dueca::DataClassRegistrar registrar
  (ManifoldChannel::classname, NULL,
   entriestable, &functortable,
   new ::dueca::DataSetSubsidiary<ManifoldChannel>());

#endif

#ifndef __CUSTOM_DEFAULT_CONSTRUCTOR
ManifoldChannel::ManifoldChannel():
    map_l(0.0),
    map_r(0.0)
{
  DOBS("default constructor ManifoldChannel");
}
#endif

#ifndef __CUSTOM_FULL_CONSTRUCTOR
ManifoldChannel::ManifoldChannel(
        const float& map_l,
        const float& map_r) :
    map_l(map_l),
    map_r(map_r)
{
  DOBS("complete constructor ManifoldChannel");
}
#endif

#ifndef __CUSTOM_FULLSINGLES_CONSTRUCTOR
#endif

#ifndef __CUSTOM_COPY_CONSTRUCTOR
ManifoldChannel::ManifoldChannel(const ManifoldChannel& other):
    map_l(other.map_l),
    map_r(other.map_r)
{
  DOBS("copy constructor ManifoldChannel");
}
#endif

#if !defined(__CUSTOM_AMORPHRESTORE_CONSTRUCTOR) && !defined(__DCO_NOPACK)
ManifoldChannel::ManifoldChannel(dueca::AmorphReStore& s):
        map_l(s),
        map_r(s)
{
  DOBS("amorph constructor ManifoldChannel");
}
#endif

#if !defined(__CUSTOM_ARRAY_SIZE_INIT_CONSTRUCTOR)
#endif

#ifndef __CUSTOM_DESTRUCTOR
ManifoldChannel::~ManifoldChannel()
{
  DOBS("destructor ManifoldChannel");
}
#endif

#if !defined(__DCO_STANDALONE)
void* ManifoldChannel::operator new(size_t size)
{
  DOBS("operator new ManifoldChannel");
  static ::dueca::Arena* my_arena = arena_pool.findArena
    (sizeof(ManifoldChannel));
  return my_arena->alloc(size);
}

void ManifoldChannel::operator delete(void* v)
{
  DOBS("operator delete ManifoldChannel");
  static ::dueca::Arena* my_arena = arena_pool.findArena
    (sizeof(ManifoldChannel));
  my_arena->free(v);
}
#endif

#if !defined(__CUSTOM_FUNCTION_PACKDATADIFF) && !defined(__DCO_NOPACK)
void ManifoldChannel::packDataDiff(::dueca::AmorphStore& s, const ManifoldChannel& ref) const
{
  DOBS("packDataDiff ManifoldChannel");
  ::dueca::IndexMemory im;
  ::dueca::checkandpackdiffsingle(this->map_l, ref.map_l,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->map_r, ref.map_r,
                         s, im);
  im.closeoff(s);
}
#endif

#if !defined(__CUSTOM_FUNCTION_UNPACKDATA) && !defined(__DCO_NOPACK)
void ManifoldChannel::unPackData(::dueca::AmorphReStore& s)
{
  DOBS("unPackData ManifoldChannel");

  ::unPackData(s, this->map_l);
  ::unPackData(s, this->map_r);

}
#endif

#if !defined(__CUSTOM_FUNCTION_UNPACKDATADIFF) && !defined(__DCO_NOPACK)
void ManifoldChannel::unPackDataDiff(dueca::AmorphReStore& s)
{
  DOBS("unPackDataDiff ManifoldChannel");
  ::dueca::IndexRecall im;
  ::dueca::checkandunpackdiffsingle(this->map_l, s, im);
  ::dueca::checkandunpackdiffsingle(this->map_r, s, im);
}
#endif

#ifndef __CUSTOM_OPERATOR_EQUAL
bool ManifoldChannel::operator == (const ManifoldChannel& other) const
{
  DOBS("operator == ManifoldChannel");
  if (this->map_l != other.map_l) return false;
  if (this->map_r != other.map_r) return false;
  return true;
}
#endif

#ifndef __CUSTOM_OPERATOR_ASSIGN
ManifoldChannel&
ManifoldChannel::operator=(const ManifoldChannel& other)
{
  DOBS("operator = ManifoldChannel");
  if (this == &other) return *this;
  this->map_l = other.map_l;
  this->map_r = other.map_r;
  return *this;
}
#endif

#if !defined(__CUSTOM_FUNCTION_PACKDATA) && !defined(__DCO_NOPACK)
void ManifoldChannel::packData(::dueca::AmorphStore& s) const
{
  DOBS("packData ManifoldChannel");
  ::packData(s, this->map_l);
  ::packData(s, this->map_r);
}
#endif

#ifndef __CUSTOM_FUNCTION_PRINT
std::ostream & ManifoldChannel::print(std::ostream& s) const
{
  s << "ManifoldChannel("
    << "map_l=" << this->map_l << ','
    << "map_r=" << this->map_r
    << ')';
  return s;
}
#endif


