/* ------------------------------------------------------------------ */
/*      item            : ControlEvent.cxx
        generated by    : matteo (matteo)
        date            : Mon 31 Jan 2022
        category        : body file
        description     : DUECA Communication Object (DCO),
                          automatically generated by dueca-codegen
        codegen version : 110
        language        : C++
*/

#include "ControlEvent.hxx"
#include <iostream>
#include <cassert>
#if !defined(__DCO_NOPACK)
#include <AmorphStore.hxx>
#include <PackUnpackTemplates.hxx>
#endif
#include <DataWriterArraySize.hxx>
#define DOBS(A)
#if !defined(__DCO_STANDALONE)
#include <Arena.hxx>
#include <ArenaPool.hxx>
#include <DataClassRegistrar.hxx>
#include <CommObjectMemberAccess.hxx>
#include <DCOFunctor.hxx>
#include <DCOMetaFunctor.hxx>

#define DO_INSTANTIATE
#include <DataSetSubsidiary.hxx>
#endif




#if !defined(__DCO_STANDALONE)
// static CommObjectMemberAccess objects, that can provide flexible access
// to the members of a ControlEvent object
static ::dueca::CommObjectMemberAccess
  <ControlEvent,int >
  ControlEvent_member_id(&ControlEvent::id, "id");
static ::dueca::CommObjectMemberAccess
  <ControlEvent,float >
  ControlEvent_member_aileron_power(&ControlEvent::aileron_power, "aileron_power");
static ::dueca::CommObjectMemberAccess
  <ControlEvent,float >
  ControlEvent_member_aileron_power_time(&ControlEvent::aileron_power_time, "aileron_power_time");
static ::dueca::CommObjectMemberAccess
  <ControlEvent,float >
  ControlEvent_member_aileron_offset(&ControlEvent::aileron_offset, "aileron_offset");
static ::dueca::CommObjectMemberAccess
  <ControlEvent,float >
  ControlEvent_member_aileron_offset_time(&ControlEvent::aileron_offset_time, "aileron_offset_time");
static ::dueca::CommObjectMemberAccess
  <ControlEvent,float >
  ControlEvent_member_rudder_power(&ControlEvent::rudder_power, "rudder_power");
static ::dueca::CommObjectMemberAccess
  <ControlEvent,float >
  ControlEvent_member_rudder_power_time(&ControlEvent::rudder_power_time, "rudder_power_time");
static ::dueca::CommObjectMemberAccess
  <ControlEvent,float >
  ControlEvent_member_rudder_offset(&ControlEvent::rudder_offset, "rudder_offset");
static ::dueca::CommObjectMemberAccess
  <ControlEvent,float >
  ControlEvent_member_rudder_offset_time(&ControlEvent::rudder_offset_time, "rudder_offset_time");
static ::dueca::CommObjectMemberAccess
  <ControlEvent,float >
  ControlEvent_member_rudder_bias(&ControlEvent::rudder_bias, "rudder_bias");
static ::dueca::CommObjectMemberAccess
  <ControlEvent,float >
  ControlEvent_member_ARI(&ControlEvent::ARI, "ARI");
static ::dueca::CommObjectMemberAccess
  <ControlEvent,float >
  ControlEvent_member_elevator_fix(&ControlEvent::elevator_fix, "elevator_fix");

// assemble the above entries into a table in the order in which they
// appear in the ControlEvent object
static const ::dueca::CommObjectDataTable entriestable[] = {
  { &ControlEvent_member_id },
  { &ControlEvent_member_aileron_power },
  { &ControlEvent_member_aileron_power_time },
  { &ControlEvent_member_aileron_offset },
  { &ControlEvent_member_aileron_offset_time },
  { &ControlEvent_member_rudder_power },
  { &ControlEvent_member_rudder_power_time },
  { &ControlEvent_member_rudder_offset },
  { &ControlEvent_member_rudder_offset_time },
  { &ControlEvent_member_rudder_bias },
  { &ControlEvent_member_ARI },
  { &ControlEvent_member_elevator_fix },
  { NULL }
};

#endif

// class name, static
const char * const ControlEvent::classname = "ControlEvent";

// magic number, hashed from class name and member names / classes
const uint32_t ControlEvent::magic_check_number=0x2ade28e6;

#if !defined(__DCO_STANDALONE)
// functor table, provides access to user-defined metafunctions through the
// data class registry
static dueca::functortable_type functortable;

// register this class, provides access to a packing/unpacking object,
// and to the member access tables
static ::dueca::DataClassRegistrar registrar
  (ControlEvent::classname, NULL,
   entriestable, &functortable,
   new ::dueca::DataSetSubsidiary<ControlEvent>());

#endif

#ifndef __CUSTOM_DEFAULT_CONSTRUCTOR
ControlEvent::ControlEvent():
    id(0),
    aileron_power(1.0f),
    aileron_power_time(0.0f),
    aileron_offset(0.0f),
    aileron_offset_time(0.0f),
    rudder_power(1.0f),
    rudder_power_time(0.0f),
    rudder_offset(0.0f),
    rudder_offset_time(0.0f),
    rudder_bias(0.0f),
    ARI(0.0f),
    elevator_fix(0.0f)
{
  DOBS("default constructor ControlEvent");
}
#endif

#ifndef __CUSTOM_FULL_CONSTRUCTOR
ControlEvent::ControlEvent(
        const int& id,
        const float& aileron_power,
        const float& aileron_power_time,
        const float& aileron_offset,
        const float& aileron_offset_time,
        const float& rudder_power,
        const float& rudder_power_time,
        const float& rudder_offset,
        const float& rudder_offset_time,
        const float& rudder_bias,
        const float& ARI,
        const float& elevator_fix) :
    id(id),
    aileron_power(aileron_power),
    aileron_power_time(aileron_power_time),
    aileron_offset(aileron_offset),
    aileron_offset_time(aileron_offset_time),
    rudder_power(rudder_power),
    rudder_power_time(rudder_power_time),
    rudder_offset(rudder_offset),
    rudder_offset_time(rudder_offset_time),
    rudder_bias(rudder_bias),
    ARI(ARI),
    elevator_fix(elevator_fix)
{
  DOBS("complete constructor ControlEvent");
}
#endif

#ifndef __CUSTOM_FULLSINGLES_CONSTRUCTOR
#endif

#ifndef __CUSTOM_COPY_CONSTRUCTOR
ControlEvent::ControlEvent(const ControlEvent& other):
    id(other.id),
    aileron_power(other.aileron_power),
    aileron_power_time(other.aileron_power_time),
    aileron_offset(other.aileron_offset),
    aileron_offset_time(other.aileron_offset_time),
    rudder_power(other.rudder_power),
    rudder_power_time(other.rudder_power_time),
    rudder_offset(other.rudder_offset),
    rudder_offset_time(other.rudder_offset_time),
    rudder_bias(other.rudder_bias),
    ARI(other.ARI),
    elevator_fix(other.elevator_fix)
{
  DOBS("copy constructor ControlEvent");
}
#endif

#if !defined(__CUSTOM_AMORPHRESTORE_CONSTRUCTOR) && !defined(__DCO_NOPACK)
ControlEvent::ControlEvent(dueca::AmorphReStore& s):
        id(s),
        aileron_power(s),
        aileron_power_time(s),
        aileron_offset(s),
        aileron_offset_time(s),
        rudder_power(s),
        rudder_power_time(s),
        rudder_offset(s),
        rudder_offset_time(s),
        rudder_bias(s),
        ARI(s),
        elevator_fix(s)
{
  DOBS("amorph constructor ControlEvent");
}
#endif

#if !defined(__CUSTOM_ARRAY_SIZE_INIT_CONSTRUCTOR)
#endif

#ifndef __CUSTOM_DESTRUCTOR
ControlEvent::~ControlEvent()
{
  DOBS("destructor ControlEvent");
}
#endif

#if !defined(__DCO_STANDALONE)
void* ControlEvent::operator new(size_t size)
{
  DOBS("operator new ControlEvent");
  static ::dueca::Arena* my_arena = arena_pool.findArena
    (sizeof(ControlEvent));
  return my_arena->alloc(size);
}

void ControlEvent::operator delete(void* v)
{
  DOBS("operator delete ControlEvent");
  static ::dueca::Arena* my_arena = arena_pool.findArena
    (sizeof(ControlEvent));
  my_arena->free(v);
}
#endif

#if !defined(__CUSTOM_FUNCTION_PACKDATADIFF) && !defined(__DCO_NOPACK)
void ControlEvent::packDataDiff(::dueca::AmorphStore& s, const ControlEvent& ref) const
{
  DOBS("packDataDiff ControlEvent");
  ::dueca::IndexMemory im;
  ::dueca::checkandpackdiffsingle(this->id, ref.id,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->aileron_power, ref.aileron_power,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->aileron_power_time, ref.aileron_power_time,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->aileron_offset, ref.aileron_offset,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->aileron_offset_time, ref.aileron_offset_time,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->rudder_power, ref.rudder_power,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->rudder_power_time, ref.rudder_power_time,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->rudder_offset, ref.rudder_offset,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->rudder_offset_time, ref.rudder_offset_time,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->rudder_bias, ref.rudder_bias,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->ARI, ref.ARI,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->elevator_fix, ref.elevator_fix,
                         s, im);
  im.closeoff(s);
}
#endif

#if !defined(__CUSTOM_FUNCTION_UNPACKDATA) && !defined(__DCO_NOPACK)
void ControlEvent::unPackData(::dueca::AmorphReStore& s)
{
  DOBS("unPackData ControlEvent");

  ::unPackData(s, this->id);
  ::unPackData(s, this->aileron_power);
  ::unPackData(s, this->aileron_power_time);
  ::unPackData(s, this->aileron_offset);
  ::unPackData(s, this->aileron_offset_time);
  ::unPackData(s, this->rudder_power);
  ::unPackData(s, this->rudder_power_time);
  ::unPackData(s, this->rudder_offset);
  ::unPackData(s, this->rudder_offset_time);
  ::unPackData(s, this->rudder_bias);
  ::unPackData(s, this->ARI);
  ::unPackData(s, this->elevator_fix);

}
#endif

#if !defined(__CUSTOM_FUNCTION_UNPACKDATADIFF) && !defined(__DCO_NOPACK)
void ControlEvent::unPackDataDiff(dueca::AmorphReStore& s)
{
  DOBS("unPackDataDiff ControlEvent");
  ::dueca::IndexRecall im;
  ::dueca::checkandunpackdiffsingle(this->id, s, im);
  ::dueca::checkandunpackdiffsingle(this->aileron_power, s, im);
  ::dueca::checkandunpackdiffsingle(this->aileron_power_time, s, im);
  ::dueca::checkandunpackdiffsingle(this->aileron_offset, s, im);
  ::dueca::checkandunpackdiffsingle(this->aileron_offset_time, s, im);
  ::dueca::checkandunpackdiffsingle(this->rudder_power, s, im);
  ::dueca::checkandunpackdiffsingle(this->rudder_power_time, s, im);
  ::dueca::checkandunpackdiffsingle(this->rudder_offset, s, im);
  ::dueca::checkandunpackdiffsingle(this->rudder_offset_time, s, im);
  ::dueca::checkandunpackdiffsingle(this->rudder_bias, s, im);
  ::dueca::checkandunpackdiffsingle(this->ARI, s, im);
  ::dueca::checkandunpackdiffsingle(this->elevator_fix, s, im);
}
#endif

#ifndef __CUSTOM_OPERATOR_EQUAL
bool ControlEvent::operator == (const ControlEvent& other) const
{
  DOBS("operator == ControlEvent");
  if (this->id != other.id) return false;
  if (this->aileron_power != other.aileron_power) return false;
  if (this->aileron_power_time != other.aileron_power_time) return false;
  if (this->aileron_offset != other.aileron_offset) return false;
  if (this->aileron_offset_time != other.aileron_offset_time) return false;
  if (this->rudder_power != other.rudder_power) return false;
  if (this->rudder_power_time != other.rudder_power_time) return false;
  if (this->rudder_offset != other.rudder_offset) return false;
  if (this->rudder_offset_time != other.rudder_offset_time) return false;
  if (this->rudder_bias != other.rudder_bias) return false;
  if (this->ARI != other.ARI) return false;
  if (this->elevator_fix != other.elevator_fix) return false;
  return true;
}
#endif

#ifndef __CUSTOM_OPERATOR_ASSIGN
ControlEvent&
ControlEvent::operator=(const ControlEvent& other)
{
  DOBS("operator = ControlEvent");
  if (this == &other) return *this;
  this->id = other.id;
  this->aileron_power = other.aileron_power;
  this->aileron_power_time = other.aileron_power_time;
  this->aileron_offset = other.aileron_offset;
  this->aileron_offset_time = other.aileron_offset_time;
  this->rudder_power = other.rudder_power;
  this->rudder_power_time = other.rudder_power_time;
  this->rudder_offset = other.rudder_offset;
  this->rudder_offset_time = other.rudder_offset_time;
  this->rudder_bias = other.rudder_bias;
  this->ARI = other.ARI;
  this->elevator_fix = other.elevator_fix;
  return *this;
}
#endif

#if !defined(__CUSTOM_FUNCTION_PACKDATA) && !defined(__DCO_NOPACK)
void ControlEvent::packData(::dueca::AmorphStore& s) const
{
  DOBS("packData ControlEvent");
  ::packData(s, this->id);
  ::packData(s, this->aileron_power);
  ::packData(s, this->aileron_power_time);
  ::packData(s, this->aileron_offset);
  ::packData(s, this->aileron_offset_time);
  ::packData(s, this->rudder_power);
  ::packData(s, this->rudder_power_time);
  ::packData(s, this->rudder_offset);
  ::packData(s, this->rudder_offset_time);
  ::packData(s, this->rudder_bias);
  ::packData(s, this->ARI);
  ::packData(s, this->elevator_fix);
}
#endif

#ifndef __CUSTOM_FUNCTION_PRINT
std::ostream & ControlEvent::print(std::ostream& s) const
{
  s << "ControlEvent("
    << "id=" << this->id << ','
    << "aileron_power=" << this->aileron_power << ','
    << "aileron_power_time=" << this->aileron_power_time << ','
    << "aileron_offset=" << this->aileron_offset << ','
    << "aileron_offset_time=" << this->aileron_offset_time << ','
    << "rudder_power=" << this->rudder_power << ','
    << "rudder_power_time=" << this->rudder_power_time << ','
    << "rudder_offset=" << this->rudder_offset << ','
    << "rudder_offset_time=" << this->rudder_offset_time << ','
    << "rudder_bias=" << this->rudder_bias << ','
    << "ARI=" << this->ARI << ','
    << "elevator_fix=" << this->elevator_fix
    << ')';
  return s;
}
#endif


