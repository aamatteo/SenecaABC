/* ------------------------------------------------------------------ */
/*      item            : WindEvent.cxx
        generated by    : matteo (matteo)
        date            : Wed 15 Dec 2021
        category        : body file
        description     : DUECA Communication Object (DCO),
                          automatically generated by dueca-codegen
        codegen version : 110
        language        : C++
*/

#include "WindEvent.hxx"
#include <iostream>
#include <cassert>
#if !defined(__DCO_NOPACK)
#include <AmorphStore.hxx>
#include <PackUnpackTemplates.hxx>
#endif
#include <DataWriterArraySize.hxx>
#define DOBS(A)
#if !defined(__DCO_STANDALONE)
#include <Arena.hxx>
#include <ArenaPool.hxx>
#include <DataClassRegistrar.hxx>
#include <CommObjectMemberAccess.hxx>
#include <DCOFunctor.hxx>
#include <DCOMetaFunctor.hxx>

#define DO_INSTANTIATE
#include <DataSetSubsidiary.hxx>
#endif




#if !defined(__DCO_STANDALONE)
// static CommObjectMemberAccess objects, that can provide flexible access
// to the members of a WindEvent object
static ::dueca::CommObjectMemberAccess
  <WindEvent,int >
  WindEvent_member_id(&WindEvent::id, "id");
static ::dueca::CommObjectMemberAccess
  <WindEvent,bool >
  WindEvent_member_turbulence(&WindEvent::turbulence, "turbulence");
static ::dueca::CommObjectMemberAccess
  <WindEvent,float >
  WindEvent_member_turb_int(&WindEvent::turb_int, "turb_int");
static ::dueca::CommObjectMemberAccess
  <WindEvent,float >
  WindEvent_member_wind_vel(&WindEvent::wind_vel, "wind_vel");
static ::dueca::CommObjectMemberAccess
  <WindEvent,float >
  WindEvent_member_wind_dir(&WindEvent::wind_dir, "wind_dir");
static ::dueca::CommObjectMemberAccess
  <WindEvent,bool >
  WindEvent_member_gust(&WindEvent::gust, "gust");
static ::dueca::CommObjectMemberAccess
  <WindEvent,int >
  WindEvent_member_visibility(&WindEvent::visibility, "visibility");
static ::dueca::CommObjectMemberAccess
  <WindEvent,int >
  WindEvent_member_cloud_layer_0_altitude(&WindEvent::cloud_layer_0_altitude, "cloud_layer_0_altitude");
static ::dueca::CommObjectMemberAccess
  <WindEvent,int >
  WindEvent_member_cloud_layer_1_altitude(&WindEvent::cloud_layer_1_altitude, "cloud_layer_1_altitude");
static ::dueca::CommObjectMemberAccess
  <WindEvent,int >
  WindEvent_member_cloud_layer_2_altitude(&WindEvent::cloud_layer_2_altitude, "cloud_layer_2_altitude");

// assemble the above entries into a table in the order in which they
// appear in the WindEvent object
static const ::dueca::CommObjectDataTable entriestable[] = {
  { &WindEvent_member_id },
  { &WindEvent_member_turbulence },
  { &WindEvent_member_turb_int },
  { &WindEvent_member_wind_vel },
  { &WindEvent_member_wind_dir },
  { &WindEvent_member_gust },
  { &WindEvent_member_visibility },
  { &WindEvent_member_cloud_layer_0_altitude },
  { &WindEvent_member_cloud_layer_1_altitude },
  { &WindEvent_member_cloud_layer_2_altitude },
  { NULL }
};

#endif

// class name, static
const char * const WindEvent::classname = "WindEvent";

// magic number, hashed from class name and member names / classes
const uint32_t WindEvent::magic_check_number=0x61df5b3e;

#if !defined(__DCO_STANDALONE)
// functor table, provides access to user-defined metafunctions through the
// data class registry
static dueca::functortable_type functortable;

// register this class, provides access to a packing/unpacking object,
// and to the member access tables
static ::dueca::DataClassRegistrar registrar
  (WindEvent::classname, NULL,
   entriestable, &functortable,
   new ::dueca::DataSetSubsidiary<WindEvent>());

#endif

#ifndef __CUSTOM_DEFAULT_CONSTRUCTOR
WindEvent::WindEvent():
    id(0),
    turbulence(false),
    turb_int(-1.0f),
    wind_vel(-1.0f),
    wind_dir(-1.0f),
    gust(false),
    visibility(-1),
    cloud_layer_0_altitude(-1),
    cloud_layer_1_altitude(-1),
    cloud_layer_2_altitude(-1)
{
  DOBS("default constructor WindEvent");
}
#endif

#ifndef __CUSTOM_FULL_CONSTRUCTOR
WindEvent::WindEvent(
        const int& id,
        const bool& turbulence,
        const float& turb_int,
        const float& wind_vel,
        const float& wind_dir,
        const bool& gust,
        const int& visibility,
        const int& cloud_layer_0_altitude,
        const int& cloud_layer_1_altitude,
        const int& cloud_layer_2_altitude) :
    id(id),
    turbulence(turbulence),
    turb_int(turb_int),
    wind_vel(wind_vel),
    wind_dir(wind_dir),
    gust(gust),
    visibility(visibility),
    cloud_layer_0_altitude(cloud_layer_0_altitude),
    cloud_layer_1_altitude(cloud_layer_1_altitude),
    cloud_layer_2_altitude(cloud_layer_2_altitude)
{
  DOBS("complete constructor WindEvent");
}
#endif

#ifndef __CUSTOM_FULLSINGLES_CONSTRUCTOR
#endif

#ifndef __CUSTOM_COPY_CONSTRUCTOR
WindEvent::WindEvent(const WindEvent& other):
    id(other.id),
    turbulence(other.turbulence),
    turb_int(other.turb_int),
    wind_vel(other.wind_vel),
    wind_dir(other.wind_dir),
    gust(other.gust),
    visibility(other.visibility),
    cloud_layer_0_altitude(other.cloud_layer_0_altitude),
    cloud_layer_1_altitude(other.cloud_layer_1_altitude),
    cloud_layer_2_altitude(other.cloud_layer_2_altitude)
{
  DOBS("copy constructor WindEvent");
}
#endif

#if !defined(__CUSTOM_AMORPHRESTORE_CONSTRUCTOR) && !defined(__DCO_NOPACK)
WindEvent::WindEvent(dueca::AmorphReStore& s):
        id(s),
        turbulence(s),
        turb_int(s),
        wind_vel(s),
        wind_dir(s),
        gust(s),
        visibility(s),
        cloud_layer_0_altitude(s),
        cloud_layer_1_altitude(s),
        cloud_layer_2_altitude(s)
{
  DOBS("amorph constructor WindEvent");
}
#endif

#if !defined(__CUSTOM_ARRAY_SIZE_INIT_CONSTRUCTOR)
#endif

#ifndef __CUSTOM_DESTRUCTOR
WindEvent::~WindEvent()
{
  DOBS("destructor WindEvent");
}
#endif

#if !defined(__DCO_STANDALONE)
void* WindEvent::operator new(size_t size)
{
  DOBS("operator new WindEvent");
  static ::dueca::Arena* my_arena = arena_pool.findArena
    (sizeof(WindEvent));
  return my_arena->alloc(size);
}

void WindEvent::operator delete(void* v)
{
  DOBS("operator delete WindEvent");
  static ::dueca::Arena* my_arena = arena_pool.findArena
    (sizeof(WindEvent));
  my_arena->free(v);
}
#endif

#if !defined(__CUSTOM_FUNCTION_PACKDATADIFF) && !defined(__DCO_NOPACK)
void WindEvent::packDataDiff(::dueca::AmorphStore& s, const WindEvent& ref) const
{
  DOBS("packDataDiff WindEvent");
  ::dueca::IndexMemory im;
  ::dueca::checkandpackdiffsingle(this->id, ref.id,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->turbulence, ref.turbulence,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->turb_int, ref.turb_int,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->wind_vel, ref.wind_vel,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->wind_dir, ref.wind_dir,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->gust, ref.gust,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->visibility, ref.visibility,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->cloud_layer_0_altitude, ref.cloud_layer_0_altitude,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->cloud_layer_1_altitude, ref.cloud_layer_1_altitude,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->cloud_layer_2_altitude, ref.cloud_layer_2_altitude,
                         s, im);
  im.closeoff(s);
}
#endif

#if !defined(__CUSTOM_FUNCTION_UNPACKDATA) && !defined(__DCO_NOPACK)
void WindEvent::unPackData(::dueca::AmorphReStore& s)
{
  DOBS("unPackData WindEvent");

  ::unPackData(s, this->id);
  ::unPackData(s, this->turbulence);
  ::unPackData(s, this->turb_int);
  ::unPackData(s, this->wind_vel);
  ::unPackData(s, this->wind_dir);
  ::unPackData(s, this->gust);
  ::unPackData(s, this->visibility);
  ::unPackData(s, this->cloud_layer_0_altitude);
  ::unPackData(s, this->cloud_layer_1_altitude);
  ::unPackData(s, this->cloud_layer_2_altitude);

}
#endif

#if !defined(__CUSTOM_FUNCTION_UNPACKDATADIFF) && !defined(__DCO_NOPACK)
void WindEvent::unPackDataDiff(dueca::AmorphReStore& s)
{
  DOBS("unPackDataDiff WindEvent");
  ::dueca::IndexRecall im;
  ::dueca::checkandunpackdiffsingle(this->id, s, im);
  ::dueca::checkandunpackdiffsingle(this->turbulence, s, im);
  ::dueca::checkandunpackdiffsingle(this->turb_int, s, im);
  ::dueca::checkandunpackdiffsingle(this->wind_vel, s, im);
  ::dueca::checkandunpackdiffsingle(this->wind_dir, s, im);
  ::dueca::checkandunpackdiffsingle(this->gust, s, im);
  ::dueca::checkandunpackdiffsingle(this->visibility, s, im);
  ::dueca::checkandunpackdiffsingle(this->cloud_layer_0_altitude, s, im);
  ::dueca::checkandunpackdiffsingle(this->cloud_layer_1_altitude, s, im);
  ::dueca::checkandunpackdiffsingle(this->cloud_layer_2_altitude, s, im);
}
#endif

#ifndef __CUSTOM_OPERATOR_EQUAL
bool WindEvent::operator == (const WindEvent& other) const
{
  DOBS("operator == WindEvent");
  if (this->id != other.id) return false;
  if (this->turbulence != other.turbulence) return false;
  if (this->turb_int != other.turb_int) return false;
  if (this->wind_vel != other.wind_vel) return false;
  if (this->wind_dir != other.wind_dir) return false;
  if (this->gust != other.gust) return false;
  if (this->visibility != other.visibility) return false;
  if (this->cloud_layer_0_altitude != other.cloud_layer_0_altitude) return false;
  if (this->cloud_layer_1_altitude != other.cloud_layer_1_altitude) return false;
  if (this->cloud_layer_2_altitude != other.cloud_layer_2_altitude) return false;
  return true;
}
#endif

#ifndef __CUSTOM_OPERATOR_ASSIGN
WindEvent&
WindEvent::operator=(const WindEvent& other)
{
  DOBS("operator = WindEvent");
  if (this == &other) return *this;
  this->id = other.id;
  this->turbulence = other.turbulence;
  this->turb_int = other.turb_int;
  this->wind_vel = other.wind_vel;
  this->wind_dir = other.wind_dir;
  this->gust = other.gust;
  this->visibility = other.visibility;
  this->cloud_layer_0_altitude = other.cloud_layer_0_altitude;
  this->cloud_layer_1_altitude = other.cloud_layer_1_altitude;
  this->cloud_layer_2_altitude = other.cloud_layer_2_altitude;
  return *this;
}
#endif

#if !defined(__CUSTOM_FUNCTION_PACKDATA) && !defined(__DCO_NOPACK)
void WindEvent::packData(::dueca::AmorphStore& s) const
{
  DOBS("packData WindEvent");
  ::packData(s, this->id);
  ::packData(s, this->turbulence);
  ::packData(s, this->turb_int);
  ::packData(s, this->wind_vel);
  ::packData(s, this->wind_dir);
  ::packData(s, this->gust);
  ::packData(s, this->visibility);
  ::packData(s, this->cloud_layer_0_altitude);
  ::packData(s, this->cloud_layer_1_altitude);
  ::packData(s, this->cloud_layer_2_altitude);
}
#endif

#ifndef __CUSTOM_FUNCTION_PRINT
std::ostream & WindEvent::print(std::ostream& s) const
{
  s << "WindEvent("
    << "id=" << this->id << ','
    << "turbulence=" << this->turbulence << ','
    << "turb_int=" << this->turb_int << ','
    << "wind_vel=" << this->wind_vel << ','
    << "wind_dir=" << this->wind_dir << ','
    << "gust=" << this->gust << ','
    << "visibility=" << this->visibility << ','
    << "cloud_layer_0_altitude=" << this->cloud_layer_0_altitude << ','
    << "cloud_layer_1_altitude=" << this->cloud_layer_1_altitude << ','
    << "cloud_layer_2_altitude=" << this->cloud_layer_2_altitude
    << ')';
  return s;
}
#endif


