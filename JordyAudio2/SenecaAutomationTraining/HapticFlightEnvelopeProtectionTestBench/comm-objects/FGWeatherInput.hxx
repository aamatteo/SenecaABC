/* ------------------------------------------------------------------ */
/*      item            : FGWeatherInput.hxx
        generated by    : matteo (matteo)
        date            : Wed 15 Dec 2021
        category        : header file
        description     : DUECA Communication Object (DCO)
                          automatically generated by dueca-codegen
        codegen version : 110
        language        : C++
*/

#ifndef FGWeatherInput_hxx
#define FGWeatherInput_hxx

#include <inttypes.h>

#if !defined(__DCO_NOPACK)
namespace dueca {
class AmorphStore;
class AmorphReStore;
struct DataWriterArraySize;
};
#endif
#if !defined(__DCO_STANDALONE)
namespace dueca {
struct CommObjectDataTable;
};
#include <gencodegen.h>
#if GENCODEGEN != 110
#error "Generated FGWeatherInput.hxx too old, please clean with 'make mrproper'"
#endif
#include <CommObjectTraits.hxx>
#endif
#include <iostream>

#include <stringoptions.h>
#ifdef DUECA_CONFIG_HDF5
#include <H5Cpp.h>
#include <hdf5utils/HDF5DCOMetaFunctor.hxx>
#endif


/** An automatically generated class
    */
struct FGWeatherInput
{
  /** typedef for internal reference */
  typedef FGWeatherInput __ThisDCOType__;

public:
  /** The name of this class. */
  static const char* const classname;


  /** Enumerated type for an automatically generated object class */
  enum cloudCover {
    /** The cloud cover in octas */
    SKC,
    FEW,
    SCT,
    BKN,
    OVC,
    /** And the maximum value to check the validity of the entry */
    MAX_CLOUD_COVER
  };

  /** Information on the station and date/time */
  vstring station_id;

  /** A class member */
  vstring date_time;

  /** Information on the wind */
  int wind_direction;

  /** A class member */
  int wind_velocity;

  /** How is the visibility? */
  int visibility;

  /** The information on the clouds
      Layer 0 */
  int cloud_layer_0_altitude;

  /** A class member */
  cloudCover cloud_layer_0_cover;

  /** Layer 1 */
  int cloud_layer_1_altitude;

  /** A class member */
  cloudCover cloud_layer_1_cover;

  /** Layer 2 */
  int cloud_layer_2_altitude;

  /** A class member */
  cloudCover cloud_layer_2_cover;

  /** Temperature informaiton */
  int temperature;

  /** A class member */
  int dew_point;

  /** The pressure at sealevel */
  int qnh;

  /** The outlook to the next hours, probably nosig */
  vstring outlook;

public:
  /** a "magic" number, hashed out of the class definition,
      that will be used to check consistency of the sent objects
      across the dueca nodes. */
  static const uint32_t magic_check_number;

  /** default constructor. */
  FGWeatherInput();

  /** Constructor with arguments */
  FGWeatherInput(
        const vstring& station_id,
        const vstring& date_time,
        const int& wind_direction,
        const int& wind_velocity,
        const int& visibility,
        const int& cloud_layer_0_altitude,
        const cloudCover& cloud_layer_0_cover,
        const int& cloud_layer_1_altitude,
        const cloudCover& cloud_layer_1_cover,
        const int& cloud_layer_2_altitude,
        const cloudCover& cloud_layer_2_cover,
        const int& temperature,
        const int& dew_point,
        const int& qnh,
        const vstring& outlook);

  /** copy constructor. */
  FGWeatherInput(const FGWeatherInput& o);

#if !defined(__DCO_NOPACK)
  /** constructor to restore an FGWeatherInput from amorphous storage. */
  FGWeatherInput(dueca::AmorphReStore& r);
#endif

  /** destructor. */
  ~FGWeatherInput();

#if !defined(__DCO_STANDALONE)
  /** new operator "new", which places objects not on a
      heap, but in one of the memory arenas. This to speed up
      memory management. */
  static void* operator new(size_t size);

  /** new operator "delete", to go with the new version
      of operator new. */
  static void operator delete(void* p);

  /** placement "new", needed for stl. */
  inline static void* operator new(size_t size, FGWeatherInput*& o)
  { return reinterpret_cast<void*>(o); }
#endif

#if !defined(__DCO_NOPACK)
  /** packs the FGWeatherInput into amorphous storage. */
  void packData(::dueca::AmorphStore& s) const;

  /** packs the FGWeatherInput into amorphous storage.
      only differences with a previous object are packed. */
  void packDataDiff(::dueca::AmorphStore& s, const FGWeatherInput& ref) const;

  /** unpacks the FGWeatherInput from an amorphous storage. */
  void unPackData(::dueca::AmorphReStore& s);

  /** unpacks the differences for FGWeatherInput
      from an amorphous storage. */
  void unPackDataDiff(::dueca::AmorphReStore& s);
#endif

  /** Test for equality. */
  bool operator == (const FGWeatherInput& o) const;

  /** Test for inequality. */
  inline bool operator != (const FGWeatherInput& o) const
  { return !(*this == o); }

  /** Assignment operator. */
  FGWeatherInput& operator=(const FGWeatherInput& o);

  /** prints the FGWeatherInput to a stream. */
  std::ostream & print(std::ostream& s) const;
};

#if !defined(__DCO_NOPACK)
/** pack the object into amorphous storage. */
inline void packData(::dueca::AmorphStore& s,
                     const FGWeatherInput& o)
{ o.packData(s); }

/** pack the differences between this object and another
    into amorphous storage. */
inline void packDataDiff(dueca::AmorphStore& s,
                         const FGWeatherInput& o,
                         const FGWeatherInput& ref)
{ o.packDataDiff(s, ref); }

/** unpack the object from amorphous storage. */
inline void unPackData(::dueca::AmorphReStore& s,
                       FGWeatherInput& o)
{ o.unPackData(s); }

/** unpack the differences to this object from storage. */
inline void unPackDataDiff(dueca::AmorphReStore& s,
                           FGWeatherInput& o)
{ o.unPackDataDiff(s); }
#endif

const char* const getString(const FGWeatherInput::cloudCover &o);
void readFromString(FGWeatherInput::cloudCover &o, const std::string& s);
#if !defined(__DCO_NOPACK)
void packData(::dueca::AmorphStore& s,
              const FGWeatherInput::cloudCover &o);
void unPackData(::dueca::AmorphReStore& s,
                FGWeatherInput::cloudCover &o);
#endif
namespace dueca {
  template <>
  const char* getclassname<FGWeatherInput::cloudCover>();
};

PRINT_NS_START;
inline std::ostream&
operator << (std::ostream& s, const FGWeatherInput::cloudCover& o)
{ return s << getString(o); }
inline std::istream&
operator >> (std::istream& s, FGWeatherInput::cloudCover& o)
{ std::string tmp; s >> tmp; readFromString(o, tmp); return s; }
PRINT_NS_END;

namespace std {
/** print to a stream. */
inline std::ostream &
operator << (std::ostream& s, const FGWeatherInput& o)
{ return o.print(s); }
};

#if !defined(__DCO_STANDALONE)
namespace dueca {
/** Template specialization, defines a trait that is needed if
    FGWeatherInput is ever used inside other dco objects. */
template <>
struct dco_nested<FGWeatherInput> : public dco_isnested { };
template <>
struct dco_nested< FGWeatherInput::cloudCover > : public dco_isenum { };
};
#endif

#if defined(DUECA_CONFIG_HDF5)
namespace dueca {
  template<typename T>
  const H5::DataType* get_hdf5_type(const T& t);
  template<>
  const H5::DataType* get_hdf5_type(const FGWeatherInput::cloudCover &o);
  template<typename T>
  const H5::DataType* get_hdf5_elt_type(const T& t);
  template<>
  const H5::DataType* get_hdf5_elt_type(const FGWeatherInput::cloudCover &o);
  template<typename T>
  unsigned get_hdf5_elt_size(const T& t);
  template<>
  unsigned get_hdf5_elt_size(const FGWeatherInput::cloudCover &o);

  template<typename T>
  const H5::DataType* get_hdf5_type(T& t);
  template<>
  const H5::DataType* get_hdf5_type(FGWeatherInput::cloudCover &o);
  template<typename T>
  const H5::DataType* get_hdf5_elt_type(T& t);
  template<>
  const H5::DataType* get_hdf5_elt_type(FGWeatherInput::cloudCover &o);
  template<typename T>
  unsigned get_hdf5_elt_size(T& t);
  template<>
  unsigned get_hdf5_elt_size(FGWeatherInput::cloudCover &o);
} // end namespace dueca
#endif
#if defined(DUECA_CONFIG_HDF5)
// functors guarded in a separate namespace
namespace FGWeatherInput_space {

  // writes to file, reading from channel
  class HDF5DCOWriteFunctor: public dueca::hdf5log::HDF5DCOWriteFunctor
  {
    FGWeatherInput example;
  public:
    // constructor, to be invoked by the metafunctor
    HDF5DCOWriteFunctor(boost::weak_ptr<H5::H5File> file,
                        const std::string& path,
                        size_t chunksize,
                        const std::string& label,
                        bool compress, bool writeticks,
                        const dueca::DataTimeSpec* startend);

    // the functor member used by channel reading code
    bool operator() (const void* dpointer, const dueca::DataTimeSpec& ts);
  };

  // reads from file, writing to channel
  class HDF5DCOReadFunctor: public dueca::hdf5log::HDF5DCOReadFunctor
  {
    FGWeatherInput example;
  public:
    // constructor, to be invoked by the metafunctor
    HDF5DCOReadFunctor(boost::weak_ptr<H5::H5File> file,
                       const std::string& path,
                       bool readticks);
    // the functor member used by channel writing code
    bool operator() (void* dpointer);
  };
} // end namespace FGWeatherInput_space
#endif


#endif
