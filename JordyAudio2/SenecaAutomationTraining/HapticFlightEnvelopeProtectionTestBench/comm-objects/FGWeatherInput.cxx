/* ------------------------------------------------------------------ */
/*      item            : FGWeatherInput.cxx
        generated by    : matteo (matteo)
        date            : Wed 15 Dec 2021
        category        : body file
        description     : DUECA Communication Object (DCO),
                          automatically generated by dueca-codegen
        codegen version : 110
        language        : C++
*/

#include "FGWeatherInput.hxx"
#include <iostream>
#include <cassert>
#if !defined(__DCO_NOPACK)
#include <AmorphStore.hxx>
#include <PackUnpackTemplates.hxx>
#endif
#include <DataWriterArraySize.hxx>
#define DOBS(A)
#if !defined(__DCO_STANDALONE)
#include <Arena.hxx>
#include <ArenaPool.hxx>
#include <DataClassRegistrar.hxx>
#include <CommObjectMemberAccess.hxx>
#include <DCOFunctor.hxx>
#include <DCOMetaFunctor.hxx>

#define DO_INSTANTIATE
#include <DataSetSubsidiary.hxx>
#endif
#ifdef DUECA_CONFIG_HDF5
#include <hdf5utils/HDF5Templates.hxx>
#endif




#if !defined(__DCO_STANDALONE)
// static CommObjectMemberAccess objects, that can provide flexible access
// to the members of a FGWeatherInput object
static ::dueca::CommObjectMemberAccess
  <FGWeatherInput,vstring >
  FGWeatherInput_member_station_id(&FGWeatherInput::station_id, "station_id");
static ::dueca::CommObjectMemberAccess
  <FGWeatherInput,vstring >
  FGWeatherInput_member_date_time(&FGWeatherInput::date_time, "date_time");
static ::dueca::CommObjectMemberAccess
  <FGWeatherInput,int >
  FGWeatherInput_member_wind_direction(&FGWeatherInput::wind_direction, "wind_direction");
static ::dueca::CommObjectMemberAccess
  <FGWeatherInput,int >
  FGWeatherInput_member_wind_velocity(&FGWeatherInput::wind_velocity, "wind_velocity");
static ::dueca::CommObjectMemberAccess
  <FGWeatherInput,int >
  FGWeatherInput_member_visibility(&FGWeatherInput::visibility, "visibility");
static ::dueca::CommObjectMemberAccess
  <FGWeatherInput,int >
  FGWeatherInput_member_cloud_layer_0_altitude(&FGWeatherInput::cloud_layer_0_altitude, "cloud_layer_0_altitude");
static ::dueca::CommObjectMemberAccess
  <FGWeatherInput,FGWeatherInput::cloudCover >
  FGWeatherInput_member_cloud_layer_0_cover(&FGWeatherInput::cloud_layer_0_cover, "cloud_layer_0_cover");
static ::dueca::CommObjectMemberAccess
  <FGWeatherInput,int >
  FGWeatherInput_member_cloud_layer_1_altitude(&FGWeatherInput::cloud_layer_1_altitude, "cloud_layer_1_altitude");
static ::dueca::CommObjectMemberAccess
  <FGWeatherInput,FGWeatherInput::cloudCover >
  FGWeatherInput_member_cloud_layer_1_cover(&FGWeatherInput::cloud_layer_1_cover, "cloud_layer_1_cover");
static ::dueca::CommObjectMemberAccess
  <FGWeatherInput,int >
  FGWeatherInput_member_cloud_layer_2_altitude(&FGWeatherInput::cloud_layer_2_altitude, "cloud_layer_2_altitude");
static ::dueca::CommObjectMemberAccess
  <FGWeatherInput,FGWeatherInput::cloudCover >
  FGWeatherInput_member_cloud_layer_2_cover(&FGWeatherInput::cloud_layer_2_cover, "cloud_layer_2_cover");
static ::dueca::CommObjectMemberAccess
  <FGWeatherInput,int >
  FGWeatherInput_member_temperature(&FGWeatherInput::temperature, "temperature");
static ::dueca::CommObjectMemberAccess
  <FGWeatherInput,int >
  FGWeatherInput_member_dew_point(&FGWeatherInput::dew_point, "dew_point");
static ::dueca::CommObjectMemberAccess
  <FGWeatherInput,int >
  FGWeatherInput_member_qnh(&FGWeatherInput::qnh, "qnh");
static ::dueca::CommObjectMemberAccess
  <FGWeatherInput,vstring >
  FGWeatherInput_member_outlook(&FGWeatherInput::outlook, "outlook");

// assemble the above entries into a table in the order in which they
// appear in the FGWeatherInput object
static const ::dueca::CommObjectDataTable entriestable[] = {
  { &FGWeatherInput_member_station_id },
  { &FGWeatherInput_member_date_time },
  { &FGWeatherInput_member_wind_direction },
  { &FGWeatherInput_member_wind_velocity },
  { &FGWeatherInput_member_visibility },
  { &FGWeatherInput_member_cloud_layer_0_altitude },
  { &FGWeatherInput_member_cloud_layer_0_cover },
  { &FGWeatherInput_member_cloud_layer_1_altitude },
  { &FGWeatherInput_member_cloud_layer_1_cover },
  { &FGWeatherInput_member_cloud_layer_2_altitude },
  { &FGWeatherInput_member_cloud_layer_2_cover },
  { &FGWeatherInput_member_temperature },
  { &FGWeatherInput_member_dew_point },
  { &FGWeatherInput_member_qnh },
  { &FGWeatherInput_member_outlook },
  { NULL }
};

#endif

// class name, static
const char * const FGWeatherInput::classname = "FGWeatherInput";

// magic number, hashed from class name and member names / classes
const uint32_t FGWeatherInput::magic_check_number=0x9f494537;

#if !defined(__DCO_STANDALONE)
// functor table, provides access to user-defined metafunctions through the
// data class registry
static dueca::functortable_type functortable;

// register this class, provides access to a packing/unpacking object,
// and to the member access tables
static ::dueca::DataClassRegistrar registrar
  (FGWeatherInput::classname, NULL,
   entriestable, &functortable,
   new ::dueca::DataSetSubsidiary<FGWeatherInput>());

#endif

#ifndef __CUSTOM_DEFAULT_CONSTRUCTOR
FGWeatherInput::FGWeatherInput():
    station_id("" ),
    date_time("" ),
    wind_direction(0 ),
    wind_velocity(0 ),
    visibility(0 ),
    cloud_layer_0_altitude(0 ),
    cloud_layer_0_cover(SKC ),
    cloud_layer_1_altitude(0 ),
    cloud_layer_1_cover(SKC ),
    cloud_layer_2_altitude(0 ),
    cloud_layer_2_cover(SKC ),
    temperature(0 ),
    dew_point(0 ),
    qnh(0 ),
    outlook("" )
{
  DOBS("default constructor FGWeatherInput");
}
#endif

#ifndef __CUSTOM_FULL_CONSTRUCTOR
FGWeatherInput::FGWeatherInput(
        const vstring& station_id,
        const vstring& date_time,
        const int& wind_direction,
        const int& wind_velocity,
        const int& visibility,
        const int& cloud_layer_0_altitude,
        const cloudCover& cloud_layer_0_cover,
        const int& cloud_layer_1_altitude,
        const cloudCover& cloud_layer_1_cover,
        const int& cloud_layer_2_altitude,
        const cloudCover& cloud_layer_2_cover,
        const int& temperature,
        const int& dew_point,
        const int& qnh,
        const vstring& outlook) :
    station_id(station_id),
    date_time(date_time),
    wind_direction(wind_direction),
    wind_velocity(wind_velocity),
    visibility(visibility),
    cloud_layer_0_altitude(cloud_layer_0_altitude),
    cloud_layer_0_cover(cloud_layer_0_cover),
    cloud_layer_1_altitude(cloud_layer_1_altitude),
    cloud_layer_1_cover(cloud_layer_1_cover),
    cloud_layer_2_altitude(cloud_layer_2_altitude),
    cloud_layer_2_cover(cloud_layer_2_cover),
    temperature(temperature),
    dew_point(dew_point),
    qnh(qnh),
    outlook(outlook)
{
  DOBS("complete constructor FGWeatherInput");
}
#endif

#ifndef __CUSTOM_FULLSINGLES_CONSTRUCTOR
#endif

#ifndef __CUSTOM_COPY_CONSTRUCTOR
FGWeatherInput::FGWeatherInput(const FGWeatherInput& other):
    station_id(other.station_id),
    date_time(other.date_time),
    wind_direction(other.wind_direction),
    wind_velocity(other.wind_velocity),
    visibility(other.visibility),
    cloud_layer_0_altitude(other.cloud_layer_0_altitude),
    cloud_layer_0_cover(other.cloud_layer_0_cover),
    cloud_layer_1_altitude(other.cloud_layer_1_altitude),
    cloud_layer_1_cover(other.cloud_layer_1_cover),
    cloud_layer_2_altitude(other.cloud_layer_2_altitude),
    cloud_layer_2_cover(other.cloud_layer_2_cover),
    temperature(other.temperature),
    dew_point(other.dew_point),
    qnh(other.qnh),
    outlook(other.outlook)
{
  DOBS("copy constructor FGWeatherInput");
}
#endif

#if !defined(__CUSTOM_AMORPHRESTORE_CONSTRUCTOR) && !defined(__DCO_NOPACK)
FGWeatherInput::FGWeatherInput(dueca::AmorphReStore& s):
        station_id(s),
        date_time(s),
        wind_direction(s),
        wind_velocity(s),
        visibility(s),
        cloud_layer_0_altitude(s),
        cloud_layer_0_cover(cloudCover(uint32_t(s))),
        cloud_layer_1_altitude(s),
        cloud_layer_1_cover(cloudCover(uint32_t(s))),
        cloud_layer_2_altitude(s),
        cloud_layer_2_cover(cloudCover(uint32_t(s))),
        temperature(s),
        dew_point(s),
        qnh(s),
        outlook(s)
{
  DOBS("amorph constructor FGWeatherInput");
}
#endif

#if !defined(__CUSTOM_ARRAY_SIZE_INIT_CONSTRUCTOR)
#endif

#ifndef __CUSTOM_DESTRUCTOR
FGWeatherInput::~FGWeatherInput()
{
  DOBS("destructor FGWeatherInput");
}
#endif

#if !defined(__DCO_STANDALONE)
void* FGWeatherInput::operator new(size_t size)
{
  DOBS("operator new FGWeatherInput");
  static ::dueca::Arena* my_arena = arena_pool.findArena
    (sizeof(FGWeatherInput));
  return my_arena->alloc(size);
}

void FGWeatherInput::operator delete(void* v)
{
  DOBS("operator delete FGWeatherInput");
  static ::dueca::Arena* my_arena = arena_pool.findArena
    (sizeof(FGWeatherInput));
  my_arena->free(v);
}
#endif

#if !defined(__CUSTOM_FUNCTION_PACKDATADIFF) && !defined(__DCO_NOPACK)
void FGWeatherInput::packDataDiff(::dueca::AmorphStore& s, const FGWeatherInput& ref) const
{
  DOBS("packDataDiff FGWeatherInput");
  ::dueca::IndexMemory im;
  ::dueca::checkandpackdiffsingle(this->station_id, ref.station_id,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->date_time, ref.date_time,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->wind_direction, ref.wind_direction,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->wind_velocity, ref.wind_velocity,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->visibility, ref.visibility,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->cloud_layer_0_altitude, ref.cloud_layer_0_altitude,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->cloud_layer_0_cover, ref.cloud_layer_0_cover,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->cloud_layer_1_altitude, ref.cloud_layer_1_altitude,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->cloud_layer_1_cover, ref.cloud_layer_1_cover,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->cloud_layer_2_altitude, ref.cloud_layer_2_altitude,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->cloud_layer_2_cover, ref.cloud_layer_2_cover,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->temperature, ref.temperature,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->dew_point, ref.dew_point,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->qnh, ref.qnh,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->outlook, ref.outlook,
                         s, im);
  im.closeoff(s);
}
#endif

#if !defined(__CUSTOM_FUNCTION_UNPACKDATA) && !defined(__DCO_NOPACK)
void FGWeatherInput::unPackData(::dueca::AmorphReStore& s)
{
  DOBS("unPackData FGWeatherInput");

  ::unPackData(s, this->station_id);
  ::unPackData(s, this->date_time);
  ::unPackData(s, this->wind_direction);
  ::unPackData(s, this->wind_velocity);
  ::unPackData(s, this->visibility);
  ::unPackData(s, this->cloud_layer_0_altitude);
  ::unPackData(s, this->cloud_layer_0_cover);
  ::unPackData(s, this->cloud_layer_1_altitude);
  ::unPackData(s, this->cloud_layer_1_cover);
  ::unPackData(s, this->cloud_layer_2_altitude);
  ::unPackData(s, this->cloud_layer_2_cover);
  ::unPackData(s, this->temperature);
  ::unPackData(s, this->dew_point);
  ::unPackData(s, this->qnh);
  ::unPackData(s, this->outlook);

}
#endif

#if !defined(__CUSTOM_FUNCTION_UNPACKDATADIFF) && !defined(__DCO_NOPACK)
void FGWeatherInput::unPackDataDiff(dueca::AmorphReStore& s)
{
  DOBS("unPackDataDiff FGWeatherInput");
  ::dueca::IndexRecall im;
  ::dueca::checkandunpackdiffsingle(this->station_id, s, im);
  ::dueca::checkandunpackdiffsingle(this->date_time, s, im);
  ::dueca::checkandunpackdiffsingle(this->wind_direction, s, im);
  ::dueca::checkandunpackdiffsingle(this->wind_velocity, s, im);
  ::dueca::checkandunpackdiffsingle(this->visibility, s, im);
  ::dueca::checkandunpackdiffsingle(this->cloud_layer_0_altitude, s, im);
  ::dueca::checkandunpackdiffsingle(this->cloud_layer_0_cover, s, im);
  ::dueca::checkandunpackdiffsingle(this->cloud_layer_1_altitude, s, im);
  ::dueca::checkandunpackdiffsingle(this->cloud_layer_1_cover, s, im);
  ::dueca::checkandunpackdiffsingle(this->cloud_layer_2_altitude, s, im);
  ::dueca::checkandunpackdiffsingle(this->cloud_layer_2_cover, s, im);
  ::dueca::checkandunpackdiffsingle(this->temperature, s, im);
  ::dueca::checkandunpackdiffsingle(this->dew_point, s, im);
  ::dueca::checkandunpackdiffsingle(this->qnh, s, im);
  ::dueca::checkandunpackdiffsingle(this->outlook, s, im);
}
#endif

#ifndef __CUSTOM_OPERATOR_EQUAL
bool FGWeatherInput::operator == (const FGWeatherInput& other) const
{
  DOBS("operator == FGWeatherInput");
  if (this->station_id != other.station_id) return false;
  if (this->date_time != other.date_time) return false;
  if (this->wind_direction != other.wind_direction) return false;
  if (this->wind_velocity != other.wind_velocity) return false;
  if (this->visibility != other.visibility) return false;
  if (this->cloud_layer_0_altitude != other.cloud_layer_0_altitude) return false;
  if (this->cloud_layer_0_cover != other.cloud_layer_0_cover) return false;
  if (this->cloud_layer_1_altitude != other.cloud_layer_1_altitude) return false;
  if (this->cloud_layer_1_cover != other.cloud_layer_1_cover) return false;
  if (this->cloud_layer_2_altitude != other.cloud_layer_2_altitude) return false;
  if (this->cloud_layer_2_cover != other.cloud_layer_2_cover) return false;
  if (this->temperature != other.temperature) return false;
  if (this->dew_point != other.dew_point) return false;
  if (this->qnh != other.qnh) return false;
  if (this->outlook != other.outlook) return false;
  return true;
}
#endif

#ifndef __CUSTOM_OPERATOR_ASSIGN
FGWeatherInput&
FGWeatherInput::operator=(const FGWeatherInput& other)
{
  DOBS("operator = FGWeatherInput");
  if (this == &other) return *this;
  this->station_id = other.station_id;
  this->date_time = other.date_time;
  this->wind_direction = other.wind_direction;
  this->wind_velocity = other.wind_velocity;
  this->visibility = other.visibility;
  this->cloud_layer_0_altitude = other.cloud_layer_0_altitude;
  this->cloud_layer_0_cover = other.cloud_layer_0_cover;
  this->cloud_layer_1_altitude = other.cloud_layer_1_altitude;
  this->cloud_layer_1_cover = other.cloud_layer_1_cover;
  this->cloud_layer_2_altitude = other.cloud_layer_2_altitude;
  this->cloud_layer_2_cover = other.cloud_layer_2_cover;
  this->temperature = other.temperature;
  this->dew_point = other.dew_point;
  this->qnh = other.qnh;
  this->outlook = other.outlook;
  return *this;
}
#endif

#if !defined(__CUSTOM_FUNCTION_PACKDATA) && !defined(__DCO_NOPACK)
void FGWeatherInput::packData(::dueca::AmorphStore& s) const
{
  DOBS("packData FGWeatherInput");
  ::packData(s, this->station_id);
  ::packData(s, this->date_time);
  ::packData(s, this->wind_direction);
  ::packData(s, this->wind_velocity);
  ::packData(s, this->visibility);
  ::packData(s, this->cloud_layer_0_altitude);
  ::packData(s, this->cloud_layer_0_cover);
  ::packData(s, this->cloud_layer_1_altitude);
  ::packData(s, this->cloud_layer_1_cover);
  ::packData(s, this->cloud_layer_2_altitude);
  ::packData(s, this->cloud_layer_2_cover);
  ::packData(s, this->temperature);
  ::packData(s, this->dew_point);
  ::packData(s, this->qnh);
  ::packData(s, this->outlook);
}
#endif

#ifndef __CUSTOM_FUNCTION_PRINT
std::ostream & FGWeatherInput::print(std::ostream& s) const
{
  s << "FGWeatherInput("
    << "station_id=" << this->station_id << ','
    << "date_time=" << this->date_time << ','
    << "wind_direction=" << this->wind_direction << ','
    << "wind_velocity=" << this->wind_velocity << ','
    << "visibility=" << this->visibility << ','
    << "cloud_layer_0_altitude=" << this->cloud_layer_0_altitude << ','
    << "cloud_layer_0_cover=" << this->cloud_layer_0_cover << ','
    << "cloud_layer_1_altitude=" << this->cloud_layer_1_altitude << ','
    << "cloud_layer_1_cover=" << this->cloud_layer_1_cover << ','
    << "cloud_layer_2_altitude=" << this->cloud_layer_2_altitude << ','
    << "cloud_layer_2_cover=" << this->cloud_layer_2_cover << ','
    << "temperature=" << this->temperature << ','
    << "dew_point=" << this->dew_point << ','
    << "qnh=" << this->qnh << ','
    << "outlook=" << this->outlook
    << ')';
  return s;
}
#endif


#if defined(DUECA_CONFIG_HDF5)
// guarded in a separate namespace
namespace FGWeatherInput_space {

#if !defined(__CUSTOM_HDF5_WRITE_FUNCTOR)
  HDF5DCOWriteFunctor::
  HDF5DCOWriteFunctor(boost::weak_ptr<H5::H5File> file,
                      const std::string& path,
                      size_t chunksize,
                      const std::string& label,
                      bool compress, bool writeticks,
                      const dueca::DataTimeSpec* startend) :
    dueca::hdf5log::HDF5DCOWriteFunctor(file, path, chunksize, label,
                               15, compress, writeticks,
                               startend)
  {
    // add memspaces for all elements

    this->configureDataSet(0, "/data/station_id",
                           HOFFSET(FGWeatherInput, station_id),
                           dueca::get_hdf5_elt_type(example.station_id),
                           dueca::get_hdf5_elt_length(example.station_id));

    this->configureDataSet(1, "/data/date_time",
                           HOFFSET(FGWeatherInput, date_time),
                           dueca::get_hdf5_elt_type(example.date_time),
                           dueca::get_hdf5_elt_length(example.date_time));

    this->configureDataSet(2, "/data/wind_direction",
                           HOFFSET(FGWeatherInput, wind_direction),
                           dueca::get_hdf5_elt_type(example.wind_direction),
                           dueca::get_hdf5_elt_length(example.wind_direction));

    this->configureDataSet(3, "/data/wind_velocity",
                           HOFFSET(FGWeatherInput, wind_velocity),
                           dueca::get_hdf5_elt_type(example.wind_velocity),
                           dueca::get_hdf5_elt_length(example.wind_velocity));

    this->configureDataSet(4, "/data/visibility",
                           HOFFSET(FGWeatherInput, visibility),
                           dueca::get_hdf5_elt_type(example.visibility),
                           dueca::get_hdf5_elt_length(example.visibility));

    this->configureDataSet(5, "/data/cloud_layer_0_altitude",
                           HOFFSET(FGWeatherInput, cloud_layer_0_altitude),
                           dueca::get_hdf5_elt_type(example.cloud_layer_0_altitude),
                           dueca::get_hdf5_elt_length(example.cloud_layer_0_altitude));

    this->configureDataSet(6, "/data/cloud_layer_0_cover",
                           HOFFSET(FGWeatherInput, cloud_layer_0_cover),
                           dueca::get_hdf5_elt_type(example.cloud_layer_0_cover),
                           dueca::get_hdf5_elt_length(example.cloud_layer_0_cover));

    this->configureDataSet(7, "/data/cloud_layer_1_altitude",
                           HOFFSET(FGWeatherInput, cloud_layer_1_altitude),
                           dueca::get_hdf5_elt_type(example.cloud_layer_1_altitude),
                           dueca::get_hdf5_elt_length(example.cloud_layer_1_altitude));

    this->configureDataSet(8, "/data/cloud_layer_1_cover",
                           HOFFSET(FGWeatherInput, cloud_layer_1_cover),
                           dueca::get_hdf5_elt_type(example.cloud_layer_1_cover),
                           dueca::get_hdf5_elt_length(example.cloud_layer_1_cover));

    this->configureDataSet(9, "/data/cloud_layer_2_altitude",
                           HOFFSET(FGWeatherInput, cloud_layer_2_altitude),
                           dueca::get_hdf5_elt_type(example.cloud_layer_2_altitude),
                           dueca::get_hdf5_elt_length(example.cloud_layer_2_altitude));

    this->configureDataSet(10, "/data/cloud_layer_2_cover",
                           HOFFSET(FGWeatherInput, cloud_layer_2_cover),
                           dueca::get_hdf5_elt_type(example.cloud_layer_2_cover),
                           dueca::get_hdf5_elt_length(example.cloud_layer_2_cover));

    this->configureDataSet(11, "/data/temperature",
                           HOFFSET(FGWeatherInput, temperature),
                           dueca::get_hdf5_elt_type(example.temperature),
                           dueca::get_hdf5_elt_length(example.temperature));

    this->configureDataSet(12, "/data/dew_point",
                           HOFFSET(FGWeatherInput, dew_point),
                           dueca::get_hdf5_elt_type(example.dew_point),
                           dueca::get_hdf5_elt_length(example.dew_point));

    this->configureDataSet(13, "/data/qnh",
                           HOFFSET(FGWeatherInput, qnh),
                           dueca::get_hdf5_elt_type(example.qnh),
                           dueca::get_hdf5_elt_length(example.qnh));

    this->configureDataSet(14, "/data/outlook",
                           HOFFSET(FGWeatherInput, outlook),
                           dueca::get_hdf5_elt_type(example.outlook),
                           dueca::get_hdf5_elt_length(example.outlook));

    if (writeticks) {
      dueca::TimeTickType tex;
      this->configureDataSet(15, "/tick", 0,
                             dueca::get_hdf5_elt_type(tex), 1);
    }
  }

  // the functor member used by channel reading code, writes data in HDF5 file
  bool HDF5DCOWriteFunctor::operator() (const void* dpointer,
                                        const dueca::DataTimeSpec& ts)
  {
    while (ts.getValidityEnd() <= startend->getValidityStart()) {
      return true;
    }
    if (ts.getValidityStart() >= startend->getValidityEnd()) {
      return false;
    }
    this->prepareRow();

    this->sets[0].writeNew(dpointer, chunkidx, example.station_id);

    this->sets[1].writeNew(dpointer, chunkidx, example.date_time);

    this->sets[2].writeNew(dpointer, chunkidx, example.wind_direction);

    this->sets[3].writeNew(dpointer, chunkidx, example.wind_velocity);

    this->sets[4].writeNew(dpointer, chunkidx, example.visibility);

    this->sets[5].writeNew(dpointer, chunkidx, example.cloud_layer_0_altitude);

    this->sets[6].writeNew(dpointer, chunkidx, example.cloud_layer_0_cover);

    this->sets[7].writeNew(dpointer, chunkidx, example.cloud_layer_1_altitude);

    this->sets[8].writeNew(dpointer, chunkidx, example.cloud_layer_1_cover);

    this->sets[9].writeNew(dpointer, chunkidx, example.cloud_layer_2_altitude);

    this->sets[10].writeNew(dpointer, chunkidx, example.cloud_layer_2_cover);

    this->sets[11].writeNew(dpointer, chunkidx, example.temperature);

    this->sets[12].writeNew(dpointer, chunkidx, example.dew_point);

    this->sets[13].writeNew(dpointer, chunkidx, example.qnh);

    this->sets[14].writeNew(dpointer, chunkidx, example.outlook);

    if (writeticks) {
      this->sets[15].writeNew(&ts);
    }
    return true;
  }
#endif


#if !defined(__CUSTOM_HDF5_READ_FUNCTOR)
  HDF5DCOReadFunctor::
  HDF5DCOReadFunctor(boost::weak_ptr<H5::H5File> file,
                     const std::string& path,
                     bool readticks) :
    dueca::hdf5log::HDF5DCOReadFunctor(file, path,
                              15, readticks)
  {
    // add memspaces for all elements

    this->configureDataSet(0, "/data/station_id",
                           HOFFSET(FGWeatherInput, station_id),
                           dueca::get_hdf5_elt_type(example.station_id),
                           dueca::get_hdf5_elt_length(example.station_id));

    this->configureDataSet(1, "/data/date_time",
                           HOFFSET(FGWeatherInput, date_time),
                           dueca::get_hdf5_elt_type(example.date_time),
                           dueca::get_hdf5_elt_length(example.date_time));

    this->configureDataSet(2, "/data/wind_direction",
                           HOFFSET(FGWeatherInput, wind_direction),
                           dueca::get_hdf5_elt_type(example.wind_direction),
                           dueca::get_hdf5_elt_length(example.wind_direction));

    this->configureDataSet(3, "/data/wind_velocity",
                           HOFFSET(FGWeatherInput, wind_velocity),
                           dueca::get_hdf5_elt_type(example.wind_velocity),
                           dueca::get_hdf5_elt_length(example.wind_velocity));

    this->configureDataSet(4, "/data/visibility",
                           HOFFSET(FGWeatherInput, visibility),
                           dueca::get_hdf5_elt_type(example.visibility),
                           dueca::get_hdf5_elt_length(example.visibility));

    this->configureDataSet(5, "/data/cloud_layer_0_altitude",
                           HOFFSET(FGWeatherInput, cloud_layer_0_altitude),
                           dueca::get_hdf5_elt_type(example.cloud_layer_0_altitude),
                           dueca::get_hdf5_elt_length(example.cloud_layer_0_altitude));

    this->configureDataSet(6, "/data/cloud_layer_0_cover",
                           HOFFSET(FGWeatherInput, cloud_layer_0_cover),
                           dueca::get_hdf5_elt_type(example.cloud_layer_0_cover),
                           dueca::get_hdf5_elt_length(example.cloud_layer_0_cover));

    this->configureDataSet(7, "/data/cloud_layer_1_altitude",
                           HOFFSET(FGWeatherInput, cloud_layer_1_altitude),
                           dueca::get_hdf5_elt_type(example.cloud_layer_1_altitude),
                           dueca::get_hdf5_elt_length(example.cloud_layer_1_altitude));

    this->configureDataSet(8, "/data/cloud_layer_1_cover",
                           HOFFSET(FGWeatherInput, cloud_layer_1_cover),
                           dueca::get_hdf5_elt_type(example.cloud_layer_1_cover),
                           dueca::get_hdf5_elt_length(example.cloud_layer_1_cover));

    this->configureDataSet(9, "/data/cloud_layer_2_altitude",
                           HOFFSET(FGWeatherInput, cloud_layer_2_altitude),
                           dueca::get_hdf5_elt_type(example.cloud_layer_2_altitude),
                           dueca::get_hdf5_elt_length(example.cloud_layer_2_altitude));

    this->configureDataSet(10, "/data/cloud_layer_2_cover",
                           HOFFSET(FGWeatherInput, cloud_layer_2_cover),
                           dueca::get_hdf5_elt_type(example.cloud_layer_2_cover),
                           dueca::get_hdf5_elt_length(example.cloud_layer_2_cover));

    this->configureDataSet(11, "/data/temperature",
                           HOFFSET(FGWeatherInput, temperature),
                           dueca::get_hdf5_elt_type(example.temperature),
                           dueca::get_hdf5_elt_length(example.temperature));

    this->configureDataSet(12, "/data/dew_point",
                           HOFFSET(FGWeatherInput, dew_point),
                           dueca::get_hdf5_elt_type(example.dew_point),
                           dueca::get_hdf5_elt_length(example.dew_point));

    this->configureDataSet(13, "/data/qnh",
                           HOFFSET(FGWeatherInput, qnh),
                           dueca::get_hdf5_elt_type(example.qnh),
                           dueca::get_hdf5_elt_length(example.qnh));

    this->configureDataSet(14, "/data/outlook",
                           HOFFSET(FGWeatherInput, outlook),
                           dueca::get_hdf5_elt_type(example.outlook),
                           dueca::get_hdf5_elt_length(example.outlook));

    if (readticks) {
      dueca::TimeTickType tex;
      this->configureDataSet(15, "/tick", 0,
                             dueca::get_hdf5_elt_type(tex), 1);
    }
  }

  bool HDF5DCOReadFunctor::operator() (void* dpointer)
  {

    this->sets[0].readObjectPart(dpointer, example.station_id);

    this->sets[1].readObjectPart(dpointer, example.date_time);

    this->sets[2].readObjectPart(dpointer, example.wind_direction);

    this->sets[3].readObjectPart(dpointer, example.wind_velocity);

    this->sets[4].readObjectPart(dpointer, example.visibility);

    this->sets[5].readObjectPart(dpointer, example.cloud_layer_0_altitude);

    this->sets[6].readObjectPart(dpointer, example.cloud_layer_0_cover);

    this->sets[7].readObjectPart(dpointer, example.cloud_layer_1_altitude);

    this->sets[8].readObjectPart(dpointer, example.cloud_layer_1_cover);

    this->sets[9].readObjectPart(dpointer, example.cloud_layer_2_altitude);

    this->sets[10].readObjectPart(dpointer, example.cloud_layer_2_cover);

    this->sets[11].readObjectPart(dpointer, example.temperature);

    this->sets[12].readObjectPart(dpointer, example.dew_point);

    this->sets[13].readObjectPart(dpointer, example.qnh);

    this->sets[14].readObjectPart(dpointer, example.outlook);

    return true;
  }
#endif


  /** Metafunctor, can be accessed through the table, and can
      produce a functor object and the HDF5 data type */
  class HDF5DCOMetaFunctor: public dueca::hdf5log::HDF5DCOMetaFunctor
  {
    HDF5DCOWriteFunctor* getWriteFunctor(boost::weak_ptr<H5::H5File> file,
                                         const std::string& path,
                                         size_t chunksize,
                                         const std::string& label,
                                         const dueca::DataTimeSpec* startend,
                                         bool compress,
                                         bool writeticks=true)
    {
      return new HDF5DCOWriteFunctor(file, path, chunksize, label,
                                     compress, writeticks, startend);
    }

    HDF5DCOReadFunctor* getReadFunctor(boost::weak_ptr<H5::H5File> file,
                                       const std::string& path,
                                       bool writeticks=true)
    {
      return new HDF5DCOReadFunctor(file, path, writeticks);
    }

  };

#if !defined(__DCO_STANDALONE)
  // loads the metafunctor in the table
  static dueca::LoadMetaFunctor<HDF5DCOMetaFunctor>
    load_functor(functortable, "hdf5");
#endif
} // end namespace FGWeatherInput_space
#endif

#if defined(DUECA_CONFIG_HDF5) && !defined(__CUSTOM_HDF5_ENUM_cloudCover)
namespace dueca {
  template<>
  const H5::DataType*
    get_hdf5_type(const FGWeatherInput::cloudCover &o)
  {
    static H5::EnumType data_type(sizeof(uint32_t));
    static bool once = true;
    if (once) {
      FGWeatherInput::cloudCover v;

      v = FGWeatherInput::SKC;
      data_type.insert("SKC", &v);
      v = FGWeatherInput::FEW;
      data_type.insert("FEW", &v);
      v = FGWeatherInput::SCT;
      data_type.insert("SCT", &v);
      v = FGWeatherInput::BKN;
      data_type.insert("BKN", &v);
      v = FGWeatherInput::OVC;
      data_type.insert("OVC", &v);
      v = FGWeatherInput::MAX_CLOUD_COVER;
      data_type.insert("MAX_CLOUD_COVER", &v);
      once = false;
    }
    return &data_type;
  }

  template<>
  const H5::DataType* get_hdf5_elt_type(const FGWeatherInput::cloudCover &o)
  { return get_hdf5_type(o); }

  template<>
  unsigned get_hdf5_elt_size(const FGWeatherInput::cloudCover &o)
  { return 1; }

  template<>
  const H5::DataType*
    get_hdf5_type(FGWeatherInput::cloudCover &o)
  {
    static H5::EnumType data_type(sizeof(uint32_t));
    static bool once = true;
    if (once) {
      FGWeatherInput::cloudCover v;

      v = FGWeatherInput::SKC;
      data_type.insert("MAX_CLOUD_COVER", &v);
      v = FGWeatherInput::FEW;
      data_type.insert("MAX_CLOUD_COVER", &v);
      v = FGWeatherInput::SCT;
      data_type.insert("MAX_CLOUD_COVER", &v);
      v = FGWeatherInput::BKN;
      data_type.insert("MAX_CLOUD_COVER", &v);
      v = FGWeatherInput::OVC;
      data_type.insert("MAX_CLOUD_COVER", &v);
      v = FGWeatherInput::MAX_CLOUD_COVER;
      data_type.insert("MAX_CLOUD_COVER", &v);
      once = false;
    }
    return &data_type;
  }

  template<>
  const H5::DataType* get_hdf5_elt_type(FGWeatherInput::cloudCover &o)
  { return get_hdf5_type(o); }

  template<>
  unsigned get_hdf5_elt_size(FGWeatherInput::cloudCover &o)
  { return 1; }

} // end dueca namespace
#endif
            #ifndef __CUSTOM_GETSTRING_cloudCover
const char* const getString(const FGWeatherInput::cloudCover &o)
{
  static const char* cloudCover_names[] = {
    "SKC",
    "FEW",
    "SCT",
    "BKN",
    "OVC",
    "MAX_CLOUD_COVER"};

  return cloudCover_names[int(o)];
}
#endif

#ifndef __CUSTOM_READFROMSTRING_cloudCover
void readFromString(FGWeatherInput::cloudCover &o, const std::string& s)
{
  for (int ii = 6; ii--; ) {
    if (std::string(getString(FGWeatherInput::cloudCover(ii))) == s) {
      o = FGWeatherInput::cloudCover(ii);
      return;
    }
  }
  throw(dueca::ConversionNotDefined());
}
#endif

#if !defined(__CUSTOM_PACKDATA_cloudCover) && !defined(__DCO_NOPACK)
void packData(::dueca::AmorphStore& s,
              const FGWeatherInput::cloudCover &o)
{ packData(s, uint32_t(o));}
#endif

#if !defined(__CUSTOM_UNPACKDATA_cloudCover) && !defined(__DCO_NOPACK)
void unPackData(::dueca::AmorphReStore& s,
                FGWeatherInput::cloudCover &o)
{ uint32_t tmp(s); o = FGWeatherInput::cloudCover(tmp); }
#endif

namespace dueca {;
template <>
const char* getclassname<FGWeatherInput::cloudCover>()
{ return "FGWeatherInput::cloudCover"; }
};

