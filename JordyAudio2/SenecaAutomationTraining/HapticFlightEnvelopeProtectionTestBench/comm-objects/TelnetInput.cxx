/* ------------------------------------------------------------------ */
/*      item            : TelnetInput.cxx
        generated by    : matteo (matteo)
        date            : Wed 15 Dec 2021
        category        : body file
        description     : DUECA Communication Object (DCO),
                          automatically generated by dueca-codegen
        codegen version : 110
        language        : C++
*/

#include "TelnetInput.hxx"
#include <iostream>
#include <cassert>
#if !defined(__DCO_NOPACK)
#include <AmorphStore.hxx>
#include <PackUnpackTemplates.hxx>
#endif
#include <DataWriterArraySize.hxx>
#define DOBS(A)
#if !defined(__DCO_STANDALONE)
#include <Arena.hxx>
#include <ArenaPool.hxx>
#include <DataClassRegistrar.hxx>
#include <CommObjectMemberAccess.hxx>
#include <DCOFunctor.hxx>
#include <DCOMetaFunctor.hxx>

#define DO_INSTANTIATE
#include <DataSetSubsidiary.hxx>
#endif




#if !defined(__DCO_STANDALONE)
// static CommObjectMemberAccess objects, that can provide flexible access
// to the members of a TelnetInput object
static ::dueca::CommObjectMemberAccess
  <TelnetInput,bool >
  TelnetInput_member_command_ready(&TelnetInput::command_ready, "command_ready");
static ::dueca::CommObjectMemberAccess
  <TelnetInput,vstring >
  TelnetInput_member_command(&TelnetInput::command, "command");
static ::dueca::CommObjectMemberAccess
  <TelnetInput,bool >
  TelnetInput_member_command_vector_ready(&TelnetInput::command_vector_ready, "command_vector_ready");
static ::dueca::CommObjectMemberAccess
  <TelnetInput,CommandVector >
  TelnetInput_member_command_vector(&TelnetInput::command_vector, "command_vector");

// assemble the above entries into a table in the order in which they
// appear in the TelnetInput object
static const ::dueca::CommObjectDataTable entriestable[] = {
  { &TelnetInput_member_command_ready },
  { &TelnetInput_member_command },
  { &TelnetInput_member_command_vector_ready },
  { &TelnetInput_member_command_vector },
  { NULL }
};

#endif

// class name, static
const char * const TelnetInput::classname = "TelnetInput";

// magic number, hashed from class name and member names / classes
const uint32_t TelnetInput::magic_check_number=0x1c363b72;

#if !defined(__DCO_STANDALONE)
// functor table, provides access to user-defined metafunctions through the
// data class registry
static dueca::functortable_type functortable;

// register this class, provides access to a packing/unpacking object,
// and to the member access tables
static ::dueca::DataClassRegistrar registrar
  (TelnetInput::classname, NULL,
   entriestable, &functortable,
   new ::dueca::DataSetSubsidiary<TelnetInput>());

#endif

#ifndef __CUSTOM_DEFAULT_CONSTRUCTOR
TelnetInput::TelnetInput():
    command_ready(false ),
    command("" ),
    command_vector_ready(false )
{
  DOBS("default constructor TelnetInput");
}
#endif

#ifndef __CUSTOM_FULL_CONSTRUCTOR
TelnetInput::TelnetInput(
        const bool& command_ready,
        const vstring& command,
        const bool& command_vector_ready,
        const CommandVector& command_vector) :
    command_ready(command_ready),
    command(command),
    command_vector_ready(command_vector_ready),
    command_vector(command_vector)
{
  DOBS("complete constructor TelnetInput");
}
#endif

#ifndef __CUSTOM_FULLSINGLES_CONSTRUCTOR
TelnetInput::TelnetInput(
        const bool& command_ready,
        const vstring& command,
        const bool& command_vector_ready) :
    command_ready(command_ready),
    command(command),
    command_vector_ready(command_vector_ready)
{
  DOBS("complete single argument constructor TelnetInput");
}
#endif

#ifndef __CUSTOM_COPY_CONSTRUCTOR
TelnetInput::TelnetInput(const TelnetInput& other):
    command_ready(other.command_ready),
    command(other.command),
    command_vector_ready(other.command_vector_ready),
    command_vector(other.command_vector)
{
  DOBS("copy constructor TelnetInput");
}
#endif

#if !defined(__CUSTOM_AMORPHRESTORE_CONSTRUCTOR) && !defined(__DCO_NOPACK)
TelnetInput::TelnetInput(dueca::AmorphReStore& s):
        command_ready(s),
        command(s),
        command_vector_ready(s)
{
  ::dueca::unpackiterable(s, this->command_vector,
                          dueca::pack_traits<CommandVector >()); 
  DOBS("amorph constructor TelnetInput");
}
#endif

#if !defined(__CUSTOM_ARRAY_SIZE_INIT_CONSTRUCTOR)
#endif

#ifndef __CUSTOM_DESTRUCTOR
TelnetInput::~TelnetInput()
{
  DOBS("destructor TelnetInput");
}
#endif

#if !defined(__DCO_STANDALONE)
void* TelnetInput::operator new(size_t size)
{
  DOBS("operator new TelnetInput");
  static ::dueca::Arena* my_arena = arena_pool.findArena
    (sizeof(TelnetInput));
  return my_arena->alloc(size);
}

void TelnetInput::operator delete(void* v)
{
  DOBS("operator delete TelnetInput");
  static ::dueca::Arena* my_arena = arena_pool.findArena
    (sizeof(TelnetInput));
  my_arena->free(v);
}
#endif

#if !defined(__CUSTOM_FUNCTION_PACKDATADIFF) && !defined(__DCO_NOPACK)
void TelnetInput::packDataDiff(::dueca::AmorphStore& s, const TelnetInput& ref) const
{
  DOBS("packDataDiff TelnetInput");
  ::dueca::IndexMemory im;
  ::dueca::checkandpackdiffsingle(this->command_ready, ref.command_ready,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->command, ref.command,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->command_vector_ready, ref.command_vector_ready,
                         s, im);
  ::dueca::checkandpackdiffiterable(this->command_vector, ref.command_vector, s, im,
                          dueca::diffpack_traits<CommandVector >());
  im.closeoff(s);
}
#endif

#if !defined(__CUSTOM_FUNCTION_UNPACKDATA) && !defined(__DCO_NOPACK)
void TelnetInput::unPackData(::dueca::AmorphReStore& s)
{
  DOBS("unPackData TelnetInput");

  ::unPackData(s, this->command_ready);
  ::unPackData(s, this->command);
  ::unPackData(s, this->command_vector_ready);

  ::dueca::unpackiterable(s, this->command_vector,
                          dueca::pack_traits<CommandVector >()); 
}
#endif

#if !defined(__CUSTOM_FUNCTION_UNPACKDATADIFF) && !defined(__DCO_NOPACK)
void TelnetInput::unPackDataDiff(dueca::AmorphReStore& s)
{
  DOBS("unPackDataDiff TelnetInput");
  ::dueca::IndexRecall im;
  ::dueca::checkandunpackdiffsingle(this->command_ready, s, im);
  ::dueca::checkandunpackdiffsingle(this->command, s, im);
  ::dueca::checkandunpackdiffsingle(this->command_vector_ready, s, im);
  ::dueca::checkandunpackdiffiterable(this->command_vector, s, im,
                          dueca::diffpack_traits<CommandVector >());
}
#endif

#ifndef __CUSTOM_OPERATOR_EQUAL
bool TelnetInput::operator == (const TelnetInput& other) const
{
  DOBS("operator == TelnetInput");
  if (this->command_ready != other.command_ready) return false;
  if (this->command != other.command) return false;
  if (this->command_vector_ready != other.command_vector_ready) return false;
  if (this->command_vector != other.command_vector) return false;
  return true;
}
#endif

#ifndef __CUSTOM_OPERATOR_ASSIGN
TelnetInput&
TelnetInput::operator=(const TelnetInput& other)
{
  DOBS("operator = TelnetInput");
  if (this == &other) return *this;
  this->command_ready = other.command_ready;
  this->command = other.command;
  this->command_vector_ready = other.command_vector_ready;
  this->command_vector = other.command_vector;
  return *this;
}
#endif

#if !defined(__CUSTOM_FUNCTION_PACKDATA) && !defined(__DCO_NOPACK)
void TelnetInput::packData(::dueca::AmorphStore& s) const
{
  DOBS("packData TelnetInput");
  ::packData(s, this->command_ready);
  ::packData(s, this->command);
  ::packData(s, this->command_vector_ready);
  ::dueca::packiterable(s, this->command_vector,
                        dueca::pack_traits<CommandVector >()); 
}
#endif

#ifndef __CUSTOM_FUNCTION_PRINT
std::ostream & TelnetInput::print(std::ostream& s) const
{
  s << "TelnetInput("
    << "command_ready=" << this->command_ready << ','
    << "command=" << this->command << ','
    << "command_vector_ready=" << this->command_vector_ready << ','
    << "command_vector={";
  for (CommandVector::const_iterator ii = this->command_vector.begin();
       ii != this->command_vector.end(); ii++) {
    if (ii != this->command_vector.begin()) s << ',';
    s << (*ii);
  }
  s << "}"
    << ')';
  return s;
}
#endif


