/* ------------------------------------------------------------------ */
/*      item            : WorldDataSpec.cxx
        generated by    : matteo (matteo)
        date            : Wed 15 Dec 2021
        category        : body file
        description     : DUECA Communication Object (DCO),
                          automatically generated by dueca-codegen
        codegen version : 110
        language        : C++
*/

#include "WorldDataSpec.hxx"
#include <iostream>
#include <cassert>
#if !defined(__DCO_NOPACK)
#include <AmorphStore.hxx>
#include <PackUnpackTemplates.hxx>
#endif
#include <DataWriterArraySize.hxx>
#define DOBS(A)
#if !defined(__DCO_STANDALONE)
#include <Arena.hxx>
#include <ArenaPool.hxx>
#include <DataClassRegistrar.hxx>
#include <CommObjectMemberAccess.hxx>
#include <DCOFunctor.hxx>
#include <DCOMetaFunctor.hxx>

#define DO_INSTANTIATE
#include <DataSetSubsidiary.hxx>
#endif




// Additional custom code
#include "WorldDataSpecExtra.cxx"

// if any custom implementations have been defined, for packing,
// unpacking, construction or deletion, verify that the
// custom code is compatible with the current generation
#if defined(__CUSTOM_DEFAULT_CONSTRUCTOR) || \
    defined(__CUSTOM_FULL_CONSTRUCTOR) || \
    defined(__CUSTOM_FULLSINGLES_CONSTRUCTOR) || \
    defined(__CUSTOM_COPY_CONSTRUCTOR) || \
    defined(__CUSTOM_AMORPHRESTORE_CONSTRUCTOR) || \
    defined(__CUSTOM_ARRAYS_SIZE_INIT_CONSTRUCTOR) || \
    defined(__CUSTOM_DESTRUCTOR) || \
    defined(__CUSTOM_FUNCTION_PACKDATADIFF) || \
    defined(__CUSTOM_FUNCTION_UNPACKDATA) || \
    defined(__CUSTOM_FUNCTION_UNPACKDATADIFF) || \
    defined(__CUSTOM_FUNCTION_PACKDATA)
#ifndef __CUSTOM_COMPATLEVEL_110
#error "Verify that your custom code is compatible with version 110. Then define __CUSTOM_COMPATLEVEL_110"
#endif
#endif


#if !defined(__DCO_STANDALONE)
// static CommObjectMemberAccess objects, that can provide flexible access
// to the members of a WorldDataSpec object
static ::dueca::CommObjectMemberAccess
  <WorldDataSpec,vstring >
  WorldDataSpec_member_name(&WorldDataSpec::name, "name");
static ::dueca::CommObjectMemberAccess
  <WorldDataSpec,vstring >
  WorldDataSpec_member_type(&WorldDataSpec::type, "type");
static ::dueca::CommObjectMemberAccess
  <WorldDataSpec,std::vector<vstring> >
  WorldDataSpec_member_filename(&WorldDataSpec::filename, "filename");
static ::dueca::CommObjectMemberAccess
  <WorldDataSpec,std::vector<double> >
  WorldDataSpec_member_coordinates(&WorldDataSpec::coordinates, "coordinates");

// assemble the above entries into a table in the order in which they
// appear in the WorldDataSpec object
static const ::dueca::CommObjectDataTable entriestable[] = {
  { &WorldDataSpec_member_name },
  { &WorldDataSpec_member_type },
  { &WorldDataSpec_member_filename },
  { &WorldDataSpec_member_coordinates },
  { NULL }
};

#endif

// class name, static
const char * const WorldDataSpec::classname = "WorldDataSpec";

// magic number, hashed from class name and member names / classes
const uint32_t WorldDataSpec::magic_check_number=0x351a8f63;

#if !defined(__DCO_STANDALONE)
// functor table, provides access to user-defined metafunctions through the
// data class registry
static dueca::functortable_type functortable;

// register this class, provides access to a packing/unpacking object,
// and to the member access tables
static ::dueca::DataClassRegistrar registrar
  (WorldDataSpec::classname, NULL,
   entriestable, &functortable,
   new ::dueca::DataSetSubsidiary<WorldDataSpec>());

#endif

#ifndef __CUSTOM_DEFAULT_CONSTRUCTOR
WorldDataSpec::WorldDataSpec():
    name(""),
    type("")
{
  DOBS("default constructor WorldDataSpec");
}
#endif

#ifndef __CUSTOM_FULL_CONSTRUCTOR
WorldDataSpec::WorldDataSpec(
        const vstring& name,
        const vstring& type,
        const std::vector<vstring>& filename,
        const std::vector<double>& coordinates) :
    name(name),
    type(type),
    filename(filename),
    coordinates(coordinates)
{
  DOBS("complete constructor WorldDataSpec");
}
#endif

#ifndef __CUSTOM_FULLSINGLES_CONSTRUCTOR
WorldDataSpec::WorldDataSpec(
        const vstring& name,
        const vstring& type) :
    name(name),
    type(type)
{
  DOBS("complete single argument constructor WorldDataSpec");
}
#endif

#ifndef __CUSTOM_COPY_CONSTRUCTOR
WorldDataSpec::WorldDataSpec(const WorldDataSpec& other):
    name(other.name),
    type(other.type),
    filename(other.filename),
    coordinates(other.coordinates)
{
  DOBS("copy constructor WorldDataSpec");
}
#endif

#if !defined(__CUSTOM_AMORPHRESTORE_CONSTRUCTOR) && !defined(__DCO_NOPACK)
WorldDataSpec::WorldDataSpec(dueca::AmorphReStore& s):
        name(s),
        type(s)
{
  ::dueca::unpackiterable(s, this->filename,
                          dueca::pack_traits<std::vector<vstring> >()); 
  ::dueca::unpackiterable(s, this->coordinates,
                          dueca::pack_traits<std::vector<double> >()); 
  DOBS("amorph constructor WorldDataSpec");
}
#endif

#if !defined(__CUSTOM_ARRAY_SIZE_INIT_CONSTRUCTOR)
#endif

#ifndef __CUSTOM_DESTRUCTOR
WorldDataSpec::~WorldDataSpec()
{
  DOBS("destructor WorldDataSpec");
}
#endif

#if !defined(__DCO_STANDALONE)
void* WorldDataSpec::operator new(size_t size)
{
  DOBS("operator new WorldDataSpec");
  static ::dueca::Arena* my_arena = arena_pool.findArena
    (sizeof(WorldDataSpec));
  return my_arena->alloc(size);
}

void WorldDataSpec::operator delete(void* v)
{
  DOBS("operator delete WorldDataSpec");
  static ::dueca::Arena* my_arena = arena_pool.findArena
    (sizeof(WorldDataSpec));
  my_arena->free(v);
}
#endif

#if !defined(__CUSTOM_FUNCTION_PACKDATADIFF) && !defined(__DCO_NOPACK)
void WorldDataSpec::packDataDiff(::dueca::AmorphStore& s, const WorldDataSpec& ref) const
{
  DOBS("packDataDiff WorldDataSpec");
  ::dueca::IndexMemory im;
  ::dueca::checkandpackdiffsingle(this->name, ref.name,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->type, ref.type,
                         s, im);
  ::dueca::checkandpackdiffiterable(this->filename, ref.filename, s, im,
                          dueca::diffpack_traits<std::vector<vstring> >());
  ::dueca::checkandpackdiffiterable(this->coordinates, ref.coordinates, s, im,
                          dueca::diffpack_traits<std::vector<double> >());
  im.closeoff(s);
}
#endif

#if !defined(__CUSTOM_FUNCTION_UNPACKDATA) && !defined(__DCO_NOPACK)
void WorldDataSpec::unPackData(::dueca::AmorphReStore& s)
{
  DOBS("unPackData WorldDataSpec");

  ::unPackData(s, this->name);
  ::unPackData(s, this->type);

  ::dueca::unpackiterable(s, this->filename,
                          dueca::pack_traits<std::vector<vstring> >()); 
  ::dueca::unpackiterable(s, this->coordinates,
                          dueca::pack_traits<std::vector<double> >()); 
}
#endif

#if !defined(__CUSTOM_FUNCTION_UNPACKDATADIFF) && !defined(__DCO_NOPACK)
void WorldDataSpec::unPackDataDiff(dueca::AmorphReStore& s)
{
  DOBS("unPackDataDiff WorldDataSpec");
  ::dueca::IndexRecall im;
  ::dueca::checkandunpackdiffsingle(this->name, s, im);
  ::dueca::checkandunpackdiffsingle(this->type, s, im);
  ::dueca::checkandunpackdiffiterable(this->filename, s, im,
                          dueca::diffpack_traits<std::vector<vstring> >());
  ::dueca::checkandunpackdiffiterable(this->coordinates, s, im,
                          dueca::diffpack_traits<std::vector<double> >());
}
#endif

#ifndef __CUSTOM_OPERATOR_EQUAL
bool WorldDataSpec::operator == (const WorldDataSpec& other) const
{
  DOBS("operator == WorldDataSpec");
  if (this->name != other.name) return false;
  if (this->type != other.type) return false;
  if (this->filename != other.filename) return false;
  if (this->coordinates != other.coordinates) return false;
  return true;
}
#endif

#ifndef __CUSTOM_OPERATOR_ASSIGN
WorldDataSpec&
WorldDataSpec::operator=(const WorldDataSpec& other)
{
  DOBS("operator = WorldDataSpec");
  if (this == &other) return *this;
  this->name = other.name;
  this->type = other.type;
  this->filename = other.filename;
  this->coordinates = other.coordinates;
  return *this;
}
#endif

#if !defined(__CUSTOM_FUNCTION_PACKDATA) && !defined(__DCO_NOPACK)
void WorldDataSpec::packData(::dueca::AmorphStore& s) const
{
  DOBS("packData WorldDataSpec");
  ::packData(s, this->name);
  ::packData(s, this->type);
  ::dueca::packiterable(s, this->filename,
                        dueca::pack_traits<std::vector<vstring> >()); 
  ::dueca::packiterable(s, this->coordinates,
                        dueca::pack_traits<std::vector<double> >()); 
}
#endif

#ifndef __CUSTOM_FUNCTION_PRINT
std::ostream & WorldDataSpec::print(std::ostream& s) const
{
  s << "WorldDataSpec("
    << "name=" << this->name << ','
    << "type=" << this->type << ','
    << "filename={";
  for (std::vector<vstring>::const_iterator ii = this->filename.begin();
       ii != this->filename.end(); ii++) {
    if (ii != this->filename.begin()) s << ',';
    s << (*ii);
  }
  s << "},"
    << "coordinates={";
  for (std::vector<double>::const_iterator ii = this->coordinates.begin();
       ii != this->coordinates.end(); ii++) {
    if (ii != this->coordinates.begin()) s << ',';
    s << (*ii);
  }
  s << "}"
    << ')';
  return s;
}
#endif


