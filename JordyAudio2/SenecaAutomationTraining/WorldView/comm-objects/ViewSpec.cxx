/* ------------------------------------------------------------------ */
/*      item            : ViewSpec.cxx
        generated by    : matteo (matteo)
        date            : Wed 15 Dec 2021
        category        : body file
        description     : DUECA Communication Object (DCO),
                          automatically generated by dueca-codegen
        codegen version : 110
        language        : C++
*/

#include "ViewSpec.hxx"
#include <iostream>
#include <cassert>
#if !defined(__DCO_NOPACK)
#include <AmorphStore.hxx>
#include <PackUnpackTemplates.hxx>
#endif
#include <DataWriterArraySize.hxx>
#define DOBS(A)
#if !defined(__DCO_STANDALONE)
#include <Arena.hxx>
#include <ArenaPool.hxx>
#include <DataClassRegistrar.hxx>
#include <CommObjectMemberAccess.hxx>
#include <DCOFunctor.hxx>
#include <DCOMetaFunctor.hxx>

#define DO_INSTANTIATE
#include <DataSetSubsidiary.hxx>
#endif




// Additional custom code
#include "ViewSpecExtra.cxx"

// if any custom implementations have been defined, for packing,
// unpacking, construction or deletion, verify that the
// custom code is compatible with the current generation
#if defined(__CUSTOM_DEFAULT_CONSTRUCTOR) || \
    defined(__CUSTOM_FULL_CONSTRUCTOR) || \
    defined(__CUSTOM_FULLSINGLES_CONSTRUCTOR) || \
    defined(__CUSTOM_COPY_CONSTRUCTOR) || \
    defined(__CUSTOM_AMORPHRESTORE_CONSTRUCTOR) || \
    defined(__CUSTOM_ARRAYS_SIZE_INIT_CONSTRUCTOR) || \
    defined(__CUSTOM_DESTRUCTOR) || \
    defined(__CUSTOM_FUNCTION_PACKDATADIFF) || \
    defined(__CUSTOM_FUNCTION_UNPACKDATA) || \
    defined(__CUSTOM_FUNCTION_UNPACKDATADIFF) || \
    defined(__CUSTOM_FUNCTION_PACKDATA)
#ifndef __CUSTOM_COMPATLEVEL_110
#error "Verify that your custom code is compatible with version 110. Then define __CUSTOM_COMPATLEVEL_110"
#endif
#endif


#if !defined(__DCO_STANDALONE)
// static CommObjectMemberAccess objects, that can provide flexible access
// to the members of a ViewSpec object
static ::dueca::CommObjectMemberAccess
  <ViewSpec,vstring >
  ViewSpec_member_name(&ViewSpec::name, "name");
static ::dueca::CommObjectMemberAccess
  <ViewSpec,vstring >
  ViewSpec_member_winname(&ViewSpec::winname, "winname");
static ::dueca::CommObjectMemberAccess
  <ViewSpec,vstring >
  ViewSpec_member_overlay(&ViewSpec::overlay, "overlay");
static ::dueca::CommObjectMemberAccess
  <ViewSpec,vector_int_t >
  ViewSpec_member_portcoords(&ViewSpec::portcoords, "portcoords");
static ::dueca::CommObjectMemberAccess
  <ViewSpec,vector_float_t >
  ViewSpec_member_eye_pos(&ViewSpec::eye_pos, "eye_pos");
static ::dueca::CommObjectMemberAccess
  <ViewSpec,vector_float_t >
  ViewSpec_member_frustum_data(&ViewSpec::frustum_data, "frustum_data");
static ::dueca::CommObjectMemberAccess
  <ViewSpec,bool >
  ViewSpec_member_render_shadows(&ViewSpec::render_shadows, "render_shadows");
static ::dueca::CommObjectMemberAccess
  <ViewSpec,vstring >
  ViewSpec_member_shadow_technique(&ViewSpec::shadow_technique, "shadow_technique");
static ::dueca::CommObjectMemberAccess
  <ViewSpec,vector_float_t >
  ViewSpec_member_shadow_colour(&ViewSpec::shadow_colour, "shadow_colour");
static ::dueca::CommObjectMemberAccess
  <ViewSpec,float >
  ViewSpec_member_shadow_farDistance(&ViewSpec::shadow_farDistance, "shadow_farDistance");

// assemble the above entries into a table in the order in which they
// appear in the ViewSpec object
static const ::dueca::CommObjectDataTable entriestable[] = {
  { &ViewSpec_member_name },
  { &ViewSpec_member_winname },
  { &ViewSpec_member_overlay },
  { &ViewSpec_member_portcoords },
  { &ViewSpec_member_eye_pos },
  { &ViewSpec_member_frustum_data },
  { &ViewSpec_member_render_shadows },
  { &ViewSpec_member_shadow_technique },
  { &ViewSpec_member_shadow_colour },
  { &ViewSpec_member_shadow_farDistance },
  { NULL }
};

#endif

// class name, static
const char * const ViewSpec::classname = "ViewSpec";

// magic number, hashed from class name and member names / classes
const uint32_t ViewSpec::magic_check_number=0xb39c9be9;

#if !defined(__DCO_STANDALONE)
// functor table, provides access to user-defined metafunctions through the
// data class registry
static dueca::functortable_type functortable;

// register this class, provides access to a packing/unpacking object,
// and to the member access tables
static ::dueca::DataClassRegistrar registrar
  (ViewSpec::classname, NULL,
   entriestable, &functortable,
   new ::dueca::DataSetSubsidiary<ViewSpec>());

#endif

#ifndef __CUSTOM_DEFAULT_CONSTRUCTOR
ViewSpec::ViewSpec():
    eye_pos(6, 0.0f),
    frustum_data(3),
    render_shadows(false),
    shadow_technique("stencil"),
    shadow_colour(3),
    shadow_farDistance(100.0)
{
  frustum_data[0] = 1.0;
  frustum_data[1] = 1000.0, frustum_data[2] = 0.8;
  shadow_colour[0] = 0.2;
  shadow_colour[1] = 0.2;
  shadow_colour[2] = 0.2;
  DOBS("default constructor ViewSpec");
}
#endif

#ifndef __CUSTOM_FULL_CONSTRUCTOR
ViewSpec::ViewSpec(
        const vstring& name,
        const vstring& winname,
        const vstring& overlay,
        const vector_int_t& portcoords,
        const vector_float_t& eye_pos,
        const vector_float_t& frustum_data,
        const bool& render_shadows,
        const vstring& shadow_technique,
        const vector_float_t& shadow_colour,
        const float& shadow_farDistance) :
    name(name),
    winname(winname),
    overlay(overlay),
    portcoords(portcoords),
    eye_pos(eye_pos),
    frustum_data(frustum_data),
    render_shadows(render_shadows),
    shadow_technique(shadow_technique),
    shadow_colour(shadow_colour),
    shadow_farDistance(shadow_farDistance)
{
  DOBS("complete constructor ViewSpec");
}
#endif

#ifndef __CUSTOM_FULLSINGLES_CONSTRUCTOR
ViewSpec::ViewSpec(
        const vstring& name,
        const vstring& winname,
        const vstring& overlay,
        const bool& render_shadows,
        const vstring& shadow_technique,
        const float& shadow_farDistance) :
    name(name),
    winname(winname),
    overlay(overlay),
    render_shadows(render_shadows),
    shadow_technique(shadow_technique),
    shadow_farDistance(shadow_farDistance)
{
  DOBS("complete single argument constructor ViewSpec");
}
#endif

#ifndef __CUSTOM_COPY_CONSTRUCTOR
ViewSpec::ViewSpec(const ViewSpec& other):
    name(other.name),
    winname(other.winname),
    overlay(other.overlay),
    portcoords(other.portcoords),
    eye_pos(other.eye_pos),
    frustum_data(other.frustum_data),
    render_shadows(other.render_shadows),
    shadow_technique(other.shadow_technique),
    shadow_colour(other.shadow_colour),
    shadow_farDistance(other.shadow_farDistance)
{
  DOBS("copy constructor ViewSpec");
}
#endif

#if !defined(__CUSTOM_AMORPHRESTORE_CONSTRUCTOR) && !defined(__DCO_NOPACK)
ViewSpec::ViewSpec(dueca::AmorphReStore& s):
        name(s),
        winname(s),
        overlay(s),
        render_shadows(s),
        shadow_technique(s),
        shadow_farDistance(s)
{
  ::dueca::unpackiterable(s, this->portcoords,
                          dueca::pack_traits<vector_int_t >()); 
  ::dueca::unpackiterable(s, this->eye_pos,
                          dueca::pack_traits<vector_float_t >()); 
  ::dueca::unpackiterable(s, this->frustum_data,
                          dueca::pack_traits<vector_float_t >()); 
  ::dueca::unpackiterable(s, this->shadow_colour,
                          dueca::pack_traits<vector_float_t >()); 
  DOBS("amorph constructor ViewSpec");
}
#endif

#if !defined(__CUSTOM_ARRAY_SIZE_INIT_CONSTRUCTOR)
#endif

#ifndef __CUSTOM_DESTRUCTOR
ViewSpec::~ViewSpec()
{
  DOBS("destructor ViewSpec");
}
#endif

#if !defined(__DCO_STANDALONE)
void* ViewSpec::operator new(size_t size)
{
  DOBS("operator new ViewSpec");
  static ::dueca::Arena* my_arena = arena_pool.findArena
    (sizeof(ViewSpec));
  return my_arena->alloc(size);
}

void ViewSpec::operator delete(void* v)
{
  DOBS("operator delete ViewSpec");
  static ::dueca::Arena* my_arena = arena_pool.findArena
    (sizeof(ViewSpec));
  my_arena->free(v);
}
#endif

#if !defined(__CUSTOM_FUNCTION_PACKDATADIFF) && !defined(__DCO_NOPACK)
void ViewSpec::packDataDiff(::dueca::AmorphStore& s, const ViewSpec& ref) const
{
  DOBS("packDataDiff ViewSpec");
  ::dueca::IndexMemory im;
  ::dueca::checkandpackdiffsingle(this->name, ref.name,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->winname, ref.winname,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->overlay, ref.overlay,
                         s, im);
  ::dueca::checkandpackdiffiterable(this->portcoords, ref.portcoords, s, im,
                          dueca::diffpack_traits<vector_int_t >());
  ::dueca::checkandpackdiffiterable(this->eye_pos, ref.eye_pos, s, im,
                          dueca::diffpack_traits<vector_float_t >());
  ::dueca::checkandpackdiffiterable(this->frustum_data, ref.frustum_data, s, im,
                          dueca::diffpack_traits<vector_float_t >());
  ::dueca::checkandpackdiffsingle(this->render_shadows, ref.render_shadows,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->shadow_technique, ref.shadow_technique,
                         s, im);
  ::dueca::checkandpackdiffiterable(this->shadow_colour, ref.shadow_colour, s, im,
                          dueca::diffpack_traits<vector_float_t >());
  ::dueca::checkandpackdiffsingle(this->shadow_farDistance, ref.shadow_farDistance,
                         s, im);
  im.closeoff(s);
}
#endif

#if !defined(__CUSTOM_FUNCTION_UNPACKDATA) && !defined(__DCO_NOPACK)
void ViewSpec::unPackData(::dueca::AmorphReStore& s)
{
  DOBS("unPackData ViewSpec");

  ::unPackData(s, this->name);
  ::unPackData(s, this->winname);
  ::unPackData(s, this->overlay);
  ::unPackData(s, this->render_shadows);
  ::unPackData(s, this->shadow_technique);
  ::unPackData(s, this->shadow_farDistance);

  ::dueca::unpackiterable(s, this->portcoords,
                          dueca::pack_traits<vector_int_t >()); 
  ::dueca::unpackiterable(s, this->eye_pos,
                          dueca::pack_traits<vector_float_t >()); 
  ::dueca::unpackiterable(s, this->frustum_data,
                          dueca::pack_traits<vector_float_t >()); 
  ::dueca::unpackiterable(s, this->shadow_colour,
                          dueca::pack_traits<vector_float_t >()); 
}
#endif

#if !defined(__CUSTOM_FUNCTION_UNPACKDATADIFF) && !defined(__DCO_NOPACK)
void ViewSpec::unPackDataDiff(dueca::AmorphReStore& s)
{
  DOBS("unPackDataDiff ViewSpec");
  ::dueca::IndexRecall im;
  ::dueca::checkandunpackdiffsingle(this->name, s, im);
  ::dueca::checkandunpackdiffsingle(this->winname, s, im);
  ::dueca::checkandunpackdiffsingle(this->overlay, s, im);
  ::dueca::checkandunpackdiffiterable(this->portcoords, s, im,
                          dueca::diffpack_traits<vector_int_t >());
  ::dueca::checkandunpackdiffiterable(this->eye_pos, s, im,
                          dueca::diffpack_traits<vector_float_t >());
  ::dueca::checkandunpackdiffiterable(this->frustum_data, s, im,
                          dueca::diffpack_traits<vector_float_t >());
  ::dueca::checkandunpackdiffsingle(this->render_shadows, s, im);
  ::dueca::checkandunpackdiffsingle(this->shadow_technique, s, im);
  ::dueca::checkandunpackdiffiterable(this->shadow_colour, s, im,
                          dueca::diffpack_traits<vector_float_t >());
  ::dueca::checkandunpackdiffsingle(this->shadow_farDistance, s, im);
}
#endif

#ifndef __CUSTOM_OPERATOR_EQUAL
bool ViewSpec::operator == (const ViewSpec& other) const
{
  DOBS("operator == ViewSpec");
  if (this->name != other.name) return false;
  if (this->winname != other.winname) return false;
  if (this->overlay != other.overlay) return false;
  if (this->portcoords != other.portcoords) return false;
  if (this->eye_pos != other.eye_pos) return false;
  if (this->frustum_data != other.frustum_data) return false;
  if (this->render_shadows != other.render_shadows) return false;
  if (this->shadow_technique != other.shadow_technique) return false;
  if (this->shadow_colour != other.shadow_colour) return false;
  if (this->shadow_farDistance != other.shadow_farDistance) return false;
  return true;
}
#endif

#ifndef __CUSTOM_OPERATOR_ASSIGN
ViewSpec&
ViewSpec::operator=(const ViewSpec& other)
{
  DOBS("operator = ViewSpec");
  if (this == &other) return *this;
  this->name = other.name;
  this->winname = other.winname;
  this->overlay = other.overlay;
  this->portcoords = other.portcoords;
  this->eye_pos = other.eye_pos;
  this->frustum_data = other.frustum_data;
  this->render_shadows = other.render_shadows;
  this->shadow_technique = other.shadow_technique;
  this->shadow_colour = other.shadow_colour;
  this->shadow_farDistance = other.shadow_farDistance;
  return *this;
}
#endif

#if !defined(__CUSTOM_FUNCTION_PACKDATA) && !defined(__DCO_NOPACK)
void ViewSpec::packData(::dueca::AmorphStore& s) const
{
  DOBS("packData ViewSpec");
  ::packData(s, this->name);
  ::packData(s, this->winname);
  ::packData(s, this->overlay);
  ::packData(s, this->render_shadows);
  ::packData(s, this->shadow_technique);
  ::packData(s, this->shadow_farDistance);
  ::dueca::packiterable(s, this->portcoords,
                        dueca::pack_traits<vector_int_t >()); 
  ::dueca::packiterable(s, this->eye_pos,
                        dueca::pack_traits<vector_float_t >()); 
  ::dueca::packiterable(s, this->frustum_data,
                        dueca::pack_traits<vector_float_t >()); 
  ::dueca::packiterable(s, this->shadow_colour,
                        dueca::pack_traits<vector_float_t >()); 
}
#endif

#ifndef __CUSTOM_FUNCTION_PRINT
std::ostream & ViewSpec::print(std::ostream& s) const
{
  s << "ViewSpec("
    << "name=" << this->name << ','
    << "winname=" << this->winname << ','
    << "overlay=" << this->overlay << ','
    << "portcoords={";
  for (vector_int_t::const_iterator ii = this->portcoords.begin();
       ii != this->portcoords.end(); ii++) {
    if (ii != this->portcoords.begin()) s << ',';
    s << (*ii);
  }
  s << "},"
    << "eye_pos={";
  for (vector_float_t::const_iterator ii = this->eye_pos.begin();
       ii != this->eye_pos.end(); ii++) {
    if (ii != this->eye_pos.begin()) s << ',';
    s << (*ii);
  }
  s << "},"
    << "frustum_data={";
  for (vector_float_t::const_iterator ii = this->frustum_data.begin();
       ii != this->frustum_data.end(); ii++) {
    if (ii != this->frustum_data.begin()) s << ',';
    s << (*ii);
  }
  s << "},"
    << "render_shadows=" << this->render_shadows << ','
    << "shadow_technique=" << this->shadow_technique << ','
    << "shadow_colour={";
  for (vector_float_t::const_iterator ii = this->shadow_colour.begin();
       ii != this->shadow_colour.end(); ii++) {
    if (ii != this->shadow_colour.begin()) s << ',';
    s << (*ii);
  }
  s << "},"
    << "shadow_farDistance=" << this->shadow_farDistance
    << ')';
  return s;
}
#endif


