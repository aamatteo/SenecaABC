/* ------------------------------------------------------------------ */
/*      item            : SecondarySwitches.cxx
        generated by    : matteo (matteo)
        date            : Wed 15 Dec 2021
        category        : body file
        description     : DUECA Communication Object (DCO),
                          automatically generated by dueca-codegen
        codegen version : 110
        language        : C++
*/

#include "SecondarySwitches.hxx"
#include <iostream>
#include <cassert>
#if !defined(__DCO_NOPACK)
#include <AmorphStore.hxx>
#include <PackUnpackTemplates.hxx>
#endif
#include <DataWriterArraySize.hxx>
#define DOBS(A)
#if !defined(__DCO_STANDALONE)
#include <Arena.hxx>
#include <ArenaPool.hxx>
#include <DataClassRegistrar.hxx>
#include <CommObjectMemberAccess.hxx>
#include <DCOFunctor.hxx>
#include <DCOMetaFunctor.hxx>

#define DO_INSTANTIATE
#include <DataSetSubsidiary.hxx>
#endif
#ifdef DUECA_CONFIG_HDF5
#include <hdf5utils/HDF5Templates.hxx>
#endif




#if !defined(__DCO_STANDALONE)
// static CommObjectMemberAccess objects, that can provide flexible access
// to the members of a SecondarySwitches object
static ::dueca::CommObjectMemberAccess
  <SecondarySwitches,bool >
  SecondarySwitches_member_AT_disconnect(&SecondarySwitches::AT_disconnect, "AT_disconnect");
static ::dueca::CommObjectMemberAccess
  <SecondarySwitches,bool >
  SecondarySwitches_member_ignition_left(&SecondarySwitches::ignition_left, "ignition_left");
static ::dueca::CommObjectMemberAccess
  <SecondarySwitches,bool >
  SecondarySwitches_member_ignition_right(&SecondarySwitches::ignition_right, "ignition_right");
static ::dueca::CommObjectMemberAccess
  <SecondarySwitches,bool >
  SecondarySwitches_member_gear_up(&SecondarySwitches::gear_up, "gear_up");
static ::dueca::CommObjectMemberAccess
  <SecondarySwitches,bool >
  SecondarySwitches_member_gear_neutral(&SecondarySwitches::gear_neutral, "gear_neutral");
static ::dueca::CommObjectMemberAccess
  <SecondarySwitches,bool >
  SecondarySwitches_member_gear_down(&SecondarySwitches::gear_down, "gear_down");

// assemble the above entries into a table in the order in which they
// appear in the SecondarySwitches object
static const ::dueca::CommObjectDataTable entriestable[] = {
  { &SecondarySwitches_member_AT_disconnect },
  { &SecondarySwitches_member_ignition_left },
  { &SecondarySwitches_member_ignition_right },
  { &SecondarySwitches_member_gear_up },
  { &SecondarySwitches_member_gear_neutral },
  { &SecondarySwitches_member_gear_down },
  { NULL }
};

#endif

// class name, static
const char * const SecondarySwitches::classname = "SecondarySwitches";

// magic number, hashed from class name and member names / classes
const uint32_t SecondarySwitches::magic_check_number=0x7725b3cf;

#if !defined(__DCO_STANDALONE)
// functor table, provides access to user-defined metafunctions through the
// data class registry
static dueca::functortable_type functortable;

// register this class, provides access to a packing/unpacking object,
// and to the member access tables
static ::dueca::DataClassRegistrar registrar
  (SecondarySwitches::classname, NULL,
   entriestable, &functortable,
   new ::dueca::DataSetSubsidiary<SecondarySwitches>());

#endif

#ifndef __CUSTOM_DEFAULT_CONSTRUCTOR
SecondarySwitches::SecondarySwitches():
    AT_disconnect(false),
    ignition_left(false),
    ignition_right(false),
    gear_up(false),
    gear_neutral(false),
    gear_down(false)
{
  DOBS("default constructor SecondarySwitches");
}
#endif

#ifndef __CUSTOM_FULL_CONSTRUCTOR
SecondarySwitches::SecondarySwitches(
        const bool& AT_disconnect,
        const bool& ignition_left,
        const bool& ignition_right,
        const bool& gear_up,
        const bool& gear_neutral,
        const bool& gear_down) :
    AT_disconnect(AT_disconnect),
    ignition_left(ignition_left),
    ignition_right(ignition_right),
    gear_up(gear_up),
    gear_neutral(gear_neutral),
    gear_down(gear_down)
{
  DOBS("complete constructor SecondarySwitches");
}
#endif

#ifndef __CUSTOM_FULLSINGLES_CONSTRUCTOR
#endif

#ifndef __CUSTOM_COPY_CONSTRUCTOR
SecondarySwitches::SecondarySwitches(const SecondarySwitches& other):
    AT_disconnect(other.AT_disconnect),
    ignition_left(other.ignition_left),
    ignition_right(other.ignition_right),
    gear_up(other.gear_up),
    gear_neutral(other.gear_neutral),
    gear_down(other.gear_down)
{
  DOBS("copy constructor SecondarySwitches");
}
#endif

#if !defined(__CUSTOM_AMORPHRESTORE_CONSTRUCTOR) && !defined(__DCO_NOPACK)
SecondarySwitches::SecondarySwitches(dueca::AmorphReStore& s):
        AT_disconnect(s),
        ignition_left(s),
        ignition_right(s),
        gear_up(s),
        gear_neutral(s),
        gear_down(s)
{
  DOBS("amorph constructor SecondarySwitches");
}
#endif

#if !defined(__CUSTOM_ARRAY_SIZE_INIT_CONSTRUCTOR)
#endif

#ifndef __CUSTOM_DESTRUCTOR
SecondarySwitches::~SecondarySwitches()
{
  DOBS("destructor SecondarySwitches");
}
#endif

#if !defined(__DCO_STANDALONE)
void* SecondarySwitches::operator new(size_t size)
{
  DOBS("operator new SecondarySwitches");
  static ::dueca::Arena* my_arena = arena_pool.findArena
    (sizeof(SecondarySwitches));
  return my_arena->alloc(size);
}

void SecondarySwitches::operator delete(void* v)
{
  DOBS("operator delete SecondarySwitches");
  static ::dueca::Arena* my_arena = arena_pool.findArena
    (sizeof(SecondarySwitches));
  my_arena->free(v);
}
#endif

#if !defined(__CUSTOM_FUNCTION_PACKDATADIFF) && !defined(__DCO_NOPACK)
void SecondarySwitches::packDataDiff(::dueca::AmorphStore& s, const SecondarySwitches& ref) const
{
  DOBS("packDataDiff SecondarySwitches");
  ::dueca::IndexMemory im;
  ::dueca::checkandpackdiffsingle(this->AT_disconnect, ref.AT_disconnect,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->ignition_left, ref.ignition_left,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->ignition_right, ref.ignition_right,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->gear_up, ref.gear_up,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->gear_neutral, ref.gear_neutral,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->gear_down, ref.gear_down,
                         s, im);
  im.closeoff(s);
}
#endif

#if !defined(__CUSTOM_FUNCTION_UNPACKDATA) && !defined(__DCO_NOPACK)
void SecondarySwitches::unPackData(::dueca::AmorphReStore& s)
{
  DOBS("unPackData SecondarySwitches");

  ::unPackData(s, this->AT_disconnect);
  ::unPackData(s, this->ignition_left);
  ::unPackData(s, this->ignition_right);
  ::unPackData(s, this->gear_up);
  ::unPackData(s, this->gear_neutral);
  ::unPackData(s, this->gear_down);

}
#endif

#if !defined(__CUSTOM_FUNCTION_UNPACKDATADIFF) && !defined(__DCO_NOPACK)
void SecondarySwitches::unPackDataDiff(dueca::AmorphReStore& s)
{
  DOBS("unPackDataDiff SecondarySwitches");
  ::dueca::IndexRecall im;
  ::dueca::checkandunpackdiffsingle(this->AT_disconnect, s, im);
  ::dueca::checkandunpackdiffsingle(this->ignition_left, s, im);
  ::dueca::checkandunpackdiffsingle(this->ignition_right, s, im);
  ::dueca::checkandunpackdiffsingle(this->gear_up, s, im);
  ::dueca::checkandunpackdiffsingle(this->gear_neutral, s, im);
  ::dueca::checkandunpackdiffsingle(this->gear_down, s, im);
}
#endif

#ifndef __CUSTOM_OPERATOR_EQUAL
bool SecondarySwitches::operator == (const SecondarySwitches& other) const
{
  DOBS("operator == SecondarySwitches");
  if (this->AT_disconnect != other.AT_disconnect) return false;
  if (this->ignition_left != other.ignition_left) return false;
  if (this->ignition_right != other.ignition_right) return false;
  if (this->gear_up != other.gear_up) return false;
  if (this->gear_neutral != other.gear_neutral) return false;
  if (this->gear_down != other.gear_down) return false;
  return true;
}
#endif

#ifndef __CUSTOM_OPERATOR_ASSIGN
SecondarySwitches&
SecondarySwitches::operator=(const SecondarySwitches& other)
{
  DOBS("operator = SecondarySwitches");
  if (this == &other) return *this;
  this->AT_disconnect = other.AT_disconnect;
  this->ignition_left = other.ignition_left;
  this->ignition_right = other.ignition_right;
  this->gear_up = other.gear_up;
  this->gear_neutral = other.gear_neutral;
  this->gear_down = other.gear_down;
  return *this;
}
#endif

#if !defined(__CUSTOM_FUNCTION_PACKDATA) && !defined(__DCO_NOPACK)
void SecondarySwitches::packData(::dueca::AmorphStore& s) const
{
  DOBS("packData SecondarySwitches");
  ::packData(s, this->AT_disconnect);
  ::packData(s, this->ignition_left);
  ::packData(s, this->ignition_right);
  ::packData(s, this->gear_up);
  ::packData(s, this->gear_neutral);
  ::packData(s, this->gear_down);
}
#endif

#ifndef __CUSTOM_FUNCTION_PRINT
std::ostream & SecondarySwitches::print(std::ostream& s) const
{
  s << "SecondarySwitches("
    << "AT_disconnect=" << this->AT_disconnect << ','
    << "ignition_left=" << this->ignition_left << ','
    << "ignition_right=" << this->ignition_right << ','
    << "gear_up=" << this->gear_up << ','
    << "gear_neutral=" << this->gear_neutral << ','
    << "gear_down=" << this->gear_down
    << ')';
  return s;
}
#endif


#if defined(DUECA_CONFIG_HDF5)
// guarded in a separate namespace
namespace SecondarySwitches_space {

#if !defined(__CUSTOM_HDF5_WRITE_FUNCTOR)
  HDF5DCOWriteFunctor::
  HDF5DCOWriteFunctor(boost::weak_ptr<H5::H5File> file,
                      const std::string& path,
                      size_t chunksize,
                      const std::string& label,
                      bool compress, bool writeticks,
                      const dueca::DataTimeSpec* startend) :
    dueca::hdf5log::HDF5DCOWriteFunctor(file, path, chunksize, label,
                               6, compress, writeticks,
                               startend)
  {
    // add memspaces for all elements

    this->configureDataSet(0, "/data/AT_disconnect",
                           HOFFSET(SecondarySwitches, AT_disconnect),
                           dueca::get_hdf5_elt_type(example.AT_disconnect),
                           dueca::get_hdf5_elt_length(example.AT_disconnect));

    this->configureDataSet(1, "/data/ignition_left",
                           HOFFSET(SecondarySwitches, ignition_left),
                           dueca::get_hdf5_elt_type(example.ignition_left),
                           dueca::get_hdf5_elt_length(example.ignition_left));

    this->configureDataSet(2, "/data/ignition_right",
                           HOFFSET(SecondarySwitches, ignition_right),
                           dueca::get_hdf5_elt_type(example.ignition_right),
                           dueca::get_hdf5_elt_length(example.ignition_right));

    this->configureDataSet(3, "/data/gear_up",
                           HOFFSET(SecondarySwitches, gear_up),
                           dueca::get_hdf5_elt_type(example.gear_up),
                           dueca::get_hdf5_elt_length(example.gear_up));

    this->configureDataSet(4, "/data/gear_neutral",
                           HOFFSET(SecondarySwitches, gear_neutral),
                           dueca::get_hdf5_elt_type(example.gear_neutral),
                           dueca::get_hdf5_elt_length(example.gear_neutral));

    this->configureDataSet(5, "/data/gear_down",
                           HOFFSET(SecondarySwitches, gear_down),
                           dueca::get_hdf5_elt_type(example.gear_down),
                           dueca::get_hdf5_elt_length(example.gear_down));

    if (writeticks) {
      dueca::TimeTickType tex;
      this->configureDataSet(6, "/tick", 0,
                             dueca::get_hdf5_elt_type(tex), 1);
    }
  }

  // the functor member used by channel reading code, writes data in HDF5 file
  bool HDF5DCOWriteFunctor::operator() (const void* dpointer,
                                        const dueca::DataTimeSpec& ts)
  {
    while (ts.getValidityEnd() <= startend->getValidityStart()) {
      return true;
    }
    if (ts.getValidityStart() >= startend->getValidityEnd()) {
      return false;
    }
    this->prepareRow();

    this->sets[0].writeNew(dpointer, chunkidx, example.AT_disconnect);

    this->sets[1].writeNew(dpointer, chunkidx, example.ignition_left);

    this->sets[2].writeNew(dpointer, chunkidx, example.ignition_right);

    this->sets[3].writeNew(dpointer, chunkidx, example.gear_up);

    this->sets[4].writeNew(dpointer, chunkidx, example.gear_neutral);

    this->sets[5].writeNew(dpointer, chunkidx, example.gear_down);

    if (writeticks) {
      this->sets[6].writeNew(&ts);
    }
    return true;
  }
#endif


#if !defined(__CUSTOM_HDF5_READ_FUNCTOR)
  HDF5DCOReadFunctor::
  HDF5DCOReadFunctor(boost::weak_ptr<H5::H5File> file,
                     const std::string& path,
                     bool readticks) :
    dueca::hdf5log::HDF5DCOReadFunctor(file, path,
                              6, readticks)
  {
    // add memspaces for all elements

    this->configureDataSet(0, "/data/AT_disconnect",
                           HOFFSET(SecondarySwitches, AT_disconnect),
                           dueca::get_hdf5_elt_type(example.AT_disconnect),
                           dueca::get_hdf5_elt_length(example.AT_disconnect));

    this->configureDataSet(1, "/data/ignition_left",
                           HOFFSET(SecondarySwitches, ignition_left),
                           dueca::get_hdf5_elt_type(example.ignition_left),
                           dueca::get_hdf5_elt_length(example.ignition_left));

    this->configureDataSet(2, "/data/ignition_right",
                           HOFFSET(SecondarySwitches, ignition_right),
                           dueca::get_hdf5_elt_type(example.ignition_right),
                           dueca::get_hdf5_elt_length(example.ignition_right));

    this->configureDataSet(3, "/data/gear_up",
                           HOFFSET(SecondarySwitches, gear_up),
                           dueca::get_hdf5_elt_type(example.gear_up),
                           dueca::get_hdf5_elt_length(example.gear_up));

    this->configureDataSet(4, "/data/gear_neutral",
                           HOFFSET(SecondarySwitches, gear_neutral),
                           dueca::get_hdf5_elt_type(example.gear_neutral),
                           dueca::get_hdf5_elt_length(example.gear_neutral));

    this->configureDataSet(5, "/data/gear_down",
                           HOFFSET(SecondarySwitches, gear_down),
                           dueca::get_hdf5_elt_type(example.gear_down),
                           dueca::get_hdf5_elt_length(example.gear_down));

    if (readticks) {
      dueca::TimeTickType tex;
      this->configureDataSet(6, "/tick", 0,
                             dueca::get_hdf5_elt_type(tex), 1);
    }
  }

  bool HDF5DCOReadFunctor::operator() (void* dpointer)
  {

    this->sets[0].readObjectPart(dpointer, example.AT_disconnect);

    this->sets[1].readObjectPart(dpointer, example.ignition_left);

    this->sets[2].readObjectPart(dpointer, example.ignition_right);

    this->sets[3].readObjectPart(dpointer, example.gear_up);

    this->sets[4].readObjectPart(dpointer, example.gear_neutral);

    this->sets[5].readObjectPart(dpointer, example.gear_down);

    return true;
  }
#endif


  /** Metafunctor, can be accessed through the table, and can
      produce a functor object and the HDF5 data type */
  class HDF5DCOMetaFunctor: public dueca::hdf5log::HDF5DCOMetaFunctor
  {
    HDF5DCOWriteFunctor* getWriteFunctor(boost::weak_ptr<H5::H5File> file,
                                         const std::string& path,
                                         size_t chunksize,
                                         const std::string& label,
                                         const dueca::DataTimeSpec* startend,
                                         bool compress,
                                         bool writeticks=true)
    {
      return new HDF5DCOWriteFunctor(file, path, chunksize, label,
                                     compress, writeticks, startend);
    }

    HDF5DCOReadFunctor* getReadFunctor(boost::weak_ptr<H5::H5File> file,
                                       const std::string& path,
                                       bool writeticks=true)
    {
      return new HDF5DCOReadFunctor(file, path, writeticks);
    }

  };

#if !defined(__DCO_STANDALONE)
  // loads the metafunctor in the table
  static dueca::LoadMetaFunctor<HDF5DCOMetaFunctor>
    load_functor(functortable, "hdf5");
#endif
} // end namespace SecondarySwitches_space
#endif

