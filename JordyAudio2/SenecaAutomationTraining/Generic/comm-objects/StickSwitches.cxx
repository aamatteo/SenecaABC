/* ------------------------------------------------------------------ */
/*      item            : StickSwitches.cxx
        generated by    : matteo (matteo)
        date            : Wed 15 Dec 2021
        category        : body file
        description     : DUECA Communication Object (DCO),
                          automatically generated by dueca-codegen
        codegen version : 110
        language        : C++
*/

#include "StickSwitches.hxx"
#include <iostream>
#include <cassert>
#if !defined(__DCO_NOPACK)
#include <AmorphStore.hxx>
#include <PackUnpackTemplates.hxx>
#endif
#include <DataWriterArraySize.hxx>
#define DOBS(A)
#if !defined(__DCO_STANDALONE)
#include <Arena.hxx>
#include <ArenaPool.hxx>
#include <DataClassRegistrar.hxx>
#include <CommObjectMemberAccess.hxx>
#include <DCOFunctor.hxx>
#include <DCOMetaFunctor.hxx>

#define DO_INSTANTIATE
#include <DataSetSubsidiary.hxx>
#endif




#if !defined(__DCO_STANDALONE)
// static CommObjectMemberAccess objects, that can provide flexible access
// to the members of a StickSwitches object
static ::dueca::CommObjectMemberAccess
  <StickSwitches,bool >
  StickSwitches_member_trigger(&StickSwitches::trigger, "trigger");
static ::dueca::CommObjectMemberAccess
  <StickSwitches,bool >
  StickSwitches_member_red(&StickSwitches::red, "red");
static ::dueca::CommObjectMemberAccess
  <StickSwitches,bool >
  StickSwitches_member_black(&StickSwitches::black, "black");
static ::dueca::CommObjectMemberAccess
  <StickSwitches,bool >
  StickSwitches_member_blue(&StickSwitches::blue, "blue");
static ::dueca::CommObjectMemberAccess
  <StickSwitches,bool >
  StickSwitches_member_green(&StickSwitches::green, "green");
static ::dueca::CommObjectMemberAccess
  <StickSwitches,bool >
  StickSwitches_member_coolie_down(&StickSwitches::coolie_down, "coolie_down");
static ::dueca::CommObjectMemberAccess
  <StickSwitches,bool >
  StickSwitches_member_coolie_up(&StickSwitches::coolie_up, "coolie_up");
static ::dueca::CommObjectMemberAccess
  <StickSwitches,bool >
  StickSwitches_member_coolie_right(&StickSwitches::coolie_right, "coolie_right");
static ::dueca::CommObjectMemberAccess
  <StickSwitches,bool >
  StickSwitches_member_coolie_left(&StickSwitches::coolie_left, "coolie_left");

// assemble the above entries into a table in the order in which they
// appear in the StickSwitches object
static const ::dueca::CommObjectDataTable entriestable[] = {
  { &StickSwitches_member_trigger },
  { &StickSwitches_member_red },
  { &StickSwitches_member_black },
  { &StickSwitches_member_blue },
  { &StickSwitches_member_green },
  { &StickSwitches_member_coolie_down },
  { &StickSwitches_member_coolie_up },
  { &StickSwitches_member_coolie_right },
  { &StickSwitches_member_coolie_left },
  { NULL }
};

#endif

// class name, static
const char * const StickSwitches::classname = "StickSwitches";

// magic number, hashed from class name and member names / classes
const uint32_t StickSwitches::magic_check_number=0xa63241d6;

#if !defined(__DCO_STANDALONE)
// functor table, provides access to user-defined metafunctions through the
// data class registry
static dueca::functortable_type functortable;

// register this class, provides access to a packing/unpacking object,
// and to the member access tables
static ::dueca::DataClassRegistrar registrar
  (StickSwitches::classname, NULL,
   entriestable, &functortable,
   new ::dueca::DataSetSubsidiary<StickSwitches>());

#endif

#ifndef __CUSTOM_DEFAULT_CONSTRUCTOR
StickSwitches::StickSwitches()
{
  DOBS("default constructor StickSwitches");
}
#endif

#ifndef __CUSTOM_FULL_CONSTRUCTOR
StickSwitches::StickSwitches(
        const bool& trigger,
        const bool& red,
        const bool& black,
        const bool& blue,
        const bool& green,
        const bool& coolie_down,
        const bool& coolie_up,
        const bool& coolie_right,
        const bool& coolie_left) :
    trigger(trigger),
    red(red),
    black(black),
    blue(blue),
    green(green),
    coolie_down(coolie_down),
    coolie_up(coolie_up),
    coolie_right(coolie_right),
    coolie_left(coolie_left)
{
  DOBS("complete constructor StickSwitches");
}
#endif

#ifndef __CUSTOM_FULLSINGLES_CONSTRUCTOR
#endif

#ifndef __CUSTOM_COPY_CONSTRUCTOR
StickSwitches::StickSwitches(const StickSwitches& other):
    trigger(other.trigger),
    red(other.red),
    black(other.black),
    blue(other.blue),
    green(other.green),
    coolie_down(other.coolie_down),
    coolie_up(other.coolie_up),
    coolie_right(other.coolie_right),
    coolie_left(other.coolie_left)
{
  DOBS("copy constructor StickSwitches");
}
#endif

#if !defined(__CUSTOM_AMORPHRESTORE_CONSTRUCTOR) && !defined(__DCO_NOPACK)
StickSwitches::StickSwitches(dueca::AmorphReStore& s):
        trigger(s),
        red(s),
        black(s),
        blue(s),
        green(s),
        coolie_down(s),
        coolie_up(s),
        coolie_right(s),
        coolie_left(s)
{
  DOBS("amorph constructor StickSwitches");
}
#endif

#if !defined(__CUSTOM_ARRAY_SIZE_INIT_CONSTRUCTOR)
#endif

#ifndef __CUSTOM_DESTRUCTOR
StickSwitches::~StickSwitches()
{
  DOBS("destructor StickSwitches");
}
#endif

#if !defined(__DCO_STANDALONE)
void* StickSwitches::operator new(size_t size)
{
  DOBS("operator new StickSwitches");
  static ::dueca::Arena* my_arena = arena_pool.findArena
    (sizeof(StickSwitches));
  return my_arena->alloc(size);
}

void StickSwitches::operator delete(void* v)
{
  DOBS("operator delete StickSwitches");
  static ::dueca::Arena* my_arena = arena_pool.findArena
    (sizeof(StickSwitches));
  my_arena->free(v);
}
#endif

#if !defined(__CUSTOM_FUNCTION_PACKDATADIFF) && !defined(__DCO_NOPACK)
void StickSwitches::packDataDiff(::dueca::AmorphStore& s, const StickSwitches& ref) const
{
  DOBS("packDataDiff StickSwitches");
  ::dueca::IndexMemory im;
  ::dueca::checkandpackdiffsingle(this->trigger, ref.trigger,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->red, ref.red,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->black, ref.black,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->blue, ref.blue,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->green, ref.green,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->coolie_down, ref.coolie_down,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->coolie_up, ref.coolie_up,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->coolie_right, ref.coolie_right,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->coolie_left, ref.coolie_left,
                         s, im);
  im.closeoff(s);
}
#endif

#if !defined(__CUSTOM_FUNCTION_UNPACKDATA) && !defined(__DCO_NOPACK)
void StickSwitches::unPackData(::dueca::AmorphReStore& s)
{
  DOBS("unPackData StickSwitches");

  ::unPackData(s, this->trigger);
  ::unPackData(s, this->red);
  ::unPackData(s, this->black);
  ::unPackData(s, this->blue);
  ::unPackData(s, this->green);
  ::unPackData(s, this->coolie_down);
  ::unPackData(s, this->coolie_up);
  ::unPackData(s, this->coolie_right);
  ::unPackData(s, this->coolie_left);

}
#endif

#if !defined(__CUSTOM_FUNCTION_UNPACKDATADIFF) && !defined(__DCO_NOPACK)
void StickSwitches::unPackDataDiff(dueca::AmorphReStore& s)
{
  DOBS("unPackDataDiff StickSwitches");
  ::dueca::IndexRecall im;
  ::dueca::checkandunpackdiffsingle(this->trigger, s, im);
  ::dueca::checkandunpackdiffsingle(this->red, s, im);
  ::dueca::checkandunpackdiffsingle(this->black, s, im);
  ::dueca::checkandunpackdiffsingle(this->blue, s, im);
  ::dueca::checkandunpackdiffsingle(this->green, s, im);
  ::dueca::checkandunpackdiffsingle(this->coolie_down, s, im);
  ::dueca::checkandunpackdiffsingle(this->coolie_up, s, im);
  ::dueca::checkandunpackdiffsingle(this->coolie_right, s, im);
  ::dueca::checkandunpackdiffsingle(this->coolie_left, s, im);
}
#endif

#ifndef __CUSTOM_OPERATOR_EQUAL
bool StickSwitches::operator == (const StickSwitches& other) const
{
  DOBS("operator == StickSwitches");
  if (this->trigger != other.trigger) return false;
  if (this->red != other.red) return false;
  if (this->black != other.black) return false;
  if (this->blue != other.blue) return false;
  if (this->green != other.green) return false;
  if (this->coolie_down != other.coolie_down) return false;
  if (this->coolie_up != other.coolie_up) return false;
  if (this->coolie_right != other.coolie_right) return false;
  if (this->coolie_left != other.coolie_left) return false;
  return true;
}
#endif

#ifndef __CUSTOM_OPERATOR_ASSIGN
StickSwitches&
StickSwitches::operator=(const StickSwitches& other)
{
  DOBS("operator = StickSwitches");
  if (this == &other) return *this;
  this->trigger = other.trigger;
  this->red = other.red;
  this->black = other.black;
  this->blue = other.blue;
  this->green = other.green;
  this->coolie_down = other.coolie_down;
  this->coolie_up = other.coolie_up;
  this->coolie_right = other.coolie_right;
  this->coolie_left = other.coolie_left;
  return *this;
}
#endif

#if !defined(__CUSTOM_FUNCTION_PACKDATA) && !defined(__DCO_NOPACK)
void StickSwitches::packData(::dueca::AmorphStore& s) const
{
  DOBS("packData StickSwitches");
  ::packData(s, this->trigger);
  ::packData(s, this->red);
  ::packData(s, this->black);
  ::packData(s, this->blue);
  ::packData(s, this->green);
  ::packData(s, this->coolie_down);
  ::packData(s, this->coolie_up);
  ::packData(s, this->coolie_right);
  ::packData(s, this->coolie_left);
}
#endif

#ifndef __CUSTOM_FUNCTION_PRINT
std::ostream & StickSwitches::print(std::ostream& s) const
{
  s << "StickSwitches("
    << "trigger=" << this->trigger << ','
    << "red=" << this->red << ','
    << "black=" << this->black << ','
    << "blue=" << this->blue << ','
    << "green=" << this->green << ','
    << "coolie_down=" << this->coolie_down << ','
    << "coolie_up=" << this->coolie_up << ','
    << "coolie_right=" << this->coolie_right << ','
    << "coolie_left=" << this->coolie_left
    << ')';
  return s;
}
#endif


