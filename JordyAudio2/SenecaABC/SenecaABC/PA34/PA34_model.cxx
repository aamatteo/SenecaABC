/* ------------------------------------------------------------------   */
/*      item            : PA34.cxx
        generated by    : hkoolstra
	from template   : Simulink61Template.cxx
        template made by: Rene van Paassen
        date            : Tue Feb 25 10:44:23 2014
	category        : body file
        description     : Encapsulation of the Simulink/rtw model
	                  pa34model_dueca_8b
	changes         : Tue Feb 25 10:44:23 2014 first version
	template changes: 030326 RvP Centralised creation of models
	                         RvP delete and re-create strategy
                          030523 RvP corrected delete model race
			  040116 RvP added description in par table
			  060418 RvP created rtw61 version from 5 version
	                  060512 RvP Modified token checking code
			  070116 RvP Call sequence for rtw64 is
                                 identical; code also doubles for rtw64
			  070125 RvP Call sequence for rtw65 is
                                 identical; code also doubles for rtw65
        language        : C++
*/

static const char c_id[] =
"$Id: PA34_model.cxx,v 1.6 2022/04/04 13:15:14 matteopiras Exp $";


#define PA34_model_cxx
// include the definition of the module class
#include "PA34_model.hxx"

// include the debug writing header, by default, write warning and
// error messages
//#define D_MOD
#define I_MOD
#define W_MOD
#define E_MOD
#include <debug.h>

// include additional files needed for your calculation here
extern "C" {
#include <rtw_prototypes.h>
#include <rt_sim.h>
  rtModel_pa34model_dueca_8b *pa34model_dueca_8b(void);
}
#include <assert.h>
#include <fstream>
#include <cmath>
#include <Ticker.hxx> // FIX voor SIMONA timing errors

// conversions
#define DEG2RAD 0.0174533

// the standard package for DUSIME, including template source
#define DO_INSTANTIATE
#include <dusime.h>

// you may try to uncomment this define. It might give you slightly
// advanced outputs, but check beforehand with running a test whether
// everything works
//#define ADVANCE_OUTPUT

// class/module name
const char* const PA34_model::classname = "pa_34_model";

// initial condition/trim table
const IncoTable* PA34_model::getMyIncoTable()
{
  static IncoTable inco_table[] = {
    // enter pairs of IncoVariable and VarProbe pointers (i.e.
    // objects made with new), in this table.
    // For example
//    {(new IncoVariable("example", 0.0, 1.0, 0.01))
//     ->forMode(FlightPath, Constraint)
//     ->forMode(Speed, Control),
//     new VarProbe<PA34_model,double>
//       (REF_MEMBER(&PA34_model::i_example))}

    // always close off with:
    { NULL, NULL} };

  return inco_table;
}

// parameters to be inserted
const ParameterTable* PA34_model::getMyParameterTable()
{
  static const ParameterTable parameter_table[] = {
    { "set-timing",
      new MemberCall<PA34_model,TimeSpec>
      (&PA34_model::setTimeSpec), set_timing_description },

    { "check-timing",
      new MemberCall<PA34_model,vector<int> >
      (&PA34_model::checkTiming), check_timing_description },

    { "ARI",
      new VarProbe<PA34_model, double >
      (&PA34_model::ARI),
      "Aileron rudder inter connect [0:1]"},

    { "flap-speed",
      new VarProbe<PA34_model, float>
      (REF_MEMBER(&PA34_model::flap_speed)),
      "speed of flaps, rad/s" },

    { "gear-time",
      new VarProbe<PA34_model, float>
      (REF_MEMBER(&PA34_model::gear_time)),
      "time for gear to move up/down, s" },

    { "terrain-elevation",
      new VarProbe<PA34_model, double>
      (REF_MEMBER(&PA34_model::terr_elevation)),
      "fixed elevation of terrain, m" },

    /* You can extend this table with labels and MemberCall or
       VarProbe pointers to perform calls or insert values into your
       class objects. Please also add a description (c-style string).

       Note that for efficiency, set_timing_description and
       check_timing_description are pointers to pre-defined strings,
       you can simply enter the descriptive strings in the table. */

    /* The table is closed off with NULL pointers for the variable
       label and MemberCall/VarProbe object. The description is used to
       give an overall description of the module. */
    { NULL, NULL, "please give a description of this module"} };

  return parameter_table;
}

// constructor
PA34_model::PA34_model(Entity* e, const char* part, const
		       PrioritySpec& ps) :
  /* The following line initialises the SimulationModule base class.
     You always pass the pointer to the entity, give the classname and the
     part arguments.
     If you give a NULL pointer instead of the inco table, you will not be
     called for trim condition calculations, which is normal if you for
     example implement logging or a display.
     If you give 0 for the snapshot state, you will not be called to
     fill a snapshot, or to restore your state from a snapshot. Only
     applicable if you have no state. */
  SimulationModule(e, classname, part, getMyIncoTable(),
                   sizeof(real_T)*NSTATES),

  // initialize the data you need in your simulation
  S(NULL), Snew(NULL), Sold(NULL),
  dt(-1.0),
  //de0(0.0),
  prev_de(0.08),
  // flaps and gear
  flap_pos(0.0), flap_speed(0.14f), flap_incr(0.01f*flap_speed), // speed in rad/s
  gear_pos(0.0), gear_time(6.0f), gear_incr(0.01f/gear_time), eventgeardown(0.0),// time in s for full move
  flapsOK(true),
  gearOK(true),
  check_gear_asym(false),

  // communication items added by Matteo Piras

  radioevent(false),
  radiocomm(0),


  //gear_fail(false), // setting that in principle the landing gear does not fail
  // wind and turb
  K_turb(0.0),
  K_shear(0.0),
  wind_vel(0.0),
  wind_dir(0.0),
  wind_vel_stepsize(0.0),
  wind_vel_nsteps(0),
  wind_dir_stepsize(0.0),
  wind_dir_nsteps(0),
  // VehicleCabPosition
  xcab(1.0), ycab(0.0), zcab(-0.25),
  sf(0.0),cf(1.0),st(0.0),ct(1.0),sp(0.0),cp(1.0),
  // elevator trim
  //trim_tab_pos(0.0), trim_speed(0.26/10.0), trim_incr(trim_speed/100.0), // 15 deg(max) in 10 sec
  terr_elevation(0.0),
  //
  inco_loaded(false),
  fade_in(0.0),
  // engines
  power_left(1.0), power_right(1.0),
  LEFT_RPM(2800), RIGHT_RPM(2800),
  pla_stepsize_left(0.0), pla_stepsize_right(0.0),
  pla_nsteps_left(0), pla_nsteps_right(0),
  // mass
  asym_x(0.0),
  asym_y(0.0),
  asym_z(0.0),
  asym_mass(0.0),
  old_x(0),
  old_y(0),
  old_z(0),
  old_mass(0),
  dx(0),
  dy(0),
  dz(0),
  dmass(0),
  mass_nsteps(0),
  // controls
  aileron_power(1),
  rudder_power(1),
  rudder_bias(0.0),
  rudder_offset(0.0),
  rudder_offset_time(0.0),
  elevator_fix(0.0),
  flying(false),

  APstate(0),
  ap_de(0),
  autopilotdisco_notplaying(false),
  msg(GFC700Event::GFC700_NONE),
  //
  i_S(NULL),

  // initialize the data you need for the trim calculation

  // initialize the channel access tokens
  // example
  // my_token(getId(), NameSet(getEntity(), "MyData", part)),
  //pc_token(getId(), NameSet(getEntity(), "PrimaryControls", part), 101),
  //sc_token(getId(), NameSet(getEntity(), "SecondaryControls", part), 101),
  //ps_token(getId(), NameSet(getEntity(), "PrimarySwitches", part), 101),
  //ss_token(getId(), NameSet(getEntity(), "SecondarySwitches", part), 101),
  cpi_token(getId(), NameSet(getEntity(), "CitationPilotInput", part), 101),

//  turb_token(getId(),NameSet(getEntity(), "TurbulenceConfiguration",part)),
  turb_token(getId(),NameSet(getEntity(), "WindEvent",part)),
  sr_token(getId(), NameSet(getEntity(), "SnapshotRequest", part)),
  repos_token(getId(), NameSet(getEntity(), "Reposition", part)),
  trim_inco_token(getId(), NameSet(getEntity(), "Trim_inco",part)),

  mass_token(getId(), NameSet(getEntity(), "MassEvent", part)),
  engine_token(getId(), NameSet(getEntity(), "EngineEvent", part)),
  control_token(getId(), NameSet(getEntity(), "ControlEvent", part)),
  comm_token(getId(), NameSet(getEntity(), "CommEvent", part)),

  ap_token(getId(), NameSet(getEntity(), "AutopilotChannel", part), 101),
  gfcr_token(getId(), NameSet(getEntity(), "GFC700Event", ""), ChannelDistribution::JOIN_MASTER),
  ap2g1000_token(getId(), NameSet(getEntity(), "AP2G1000Channel", part)),


  mass_feedback_token(getId(), NameSet(getEntity(), "MassEvent", "feedback")),
  engine_feedback_token(getId(), NameSet(getEntity(), "EngineEvent", "feedback")),

  out_token(getId(), NameSet(getEntity(), "CitationOutput", part),101),
  ma_token(getId(), NameSet(getEntity(), "ManifoldChannel", part), 101),
  vcp_token(getId(), NameSet(getEntity(), "VehicleCabPosition", part),101),
  vcm_token(getId(), NameSet(getEntity(), "VehicleCabMotion", part),101),
  snd_token(getId(), NameSet(getEntity(), "PropSoundData", part)),

  //hold_request(getId(), NameSet("dusime", "SimStateRequest", ""), ChannelDistribution::NO_OPINION),
  snap_token(getId(), NameSet(getEntity(), "Snapshot", "set"), ChannelDistribution::NO_OPINION),
  cpi_trim_token(getId(), NameSet(getEntity(), "CitationPilotInput", "trim")),

    w_observer(getId(), NameSet(getEntity(), "BaseObjectMotion", ""),
           "BaseObjectMotion", "self", Channel::Continuous),

    w_gearup(getId(), NameSet("audio", "AnyAudioClass", ""),
           "AudioObjectFixed", "gearup", Channel::Events,
           Channel::OneOrMoreEntries, Channel::MixedPacking),

    w_geardown(getId(), NameSet("audio", "AnyAudioClass", ""),
          "AudioObjectFixed", "geardown", Channel::Events,
          Channel::OneOrMoreEntries, Channel::MixedPacking),

    w_flaps(getId(), NameSet("audio", "AnyAudioClass", ""),
           "AudioObjectFixed", "flaps", Channel::Events,
           Channel::OneOrMoreEntries, Channel::MixedPacking),

    w_sndwind(getId(), NameSet("audio", "AnyAudioClass", ""),
         "AudioObjectFixed", "wind",
         Channel::Continuous,
         Channel::OneOrMoreEntries, Channel::MixedPacking),

    w_sndstall(getId(), NameSet("audio", "AnyAudioClass", ""),
          "AudioObjectFixed", "stall",
          Channel::Continuous,
          Channel::OneOrMoreEntries, Channel::MixedPacking),

    w_sndmass(getId(), NameSet("audio", "AnyAudioClass", ""),
          "AudioObjectFixed", "mass", Channel::Events,
          Channel::OneOrMoreEntries, Channel::MixedPacking),

    w_sndspeed(getId(), NameSet("audio", "AnyAudioClass", ""),
           "AudioObjectFixed", "overspeed",
           Channel::Continuous,
           Channel::OneOrMoreEntries, Channel::MixedPacking),

    w_sndwheel(getId(), NameSet("audio", "AnyAudioClass", ""),
           "AudioObjectFixed", "wheels",
           Channel::Continuous,
           Channel::OneOrMoreEntries, Channel::MixedPacking),

    w_sndtd(getId(), NameSet("audio", "AnyAudioClass", ""),
          "AudioObjectFixed", "touchdown", Channel::Continuous,
          Channel::OneOrMoreEntries, Channel::MixedPacking),

    w_gearalert(getId(), NameSet("audio", "AnyAudioClass", ""),
        "AudioObjectFixed", "gearalert", Channel::Continuous,
        Channel::OneOrMoreEntries, Channel::MixedPacking),

    w_autopilotdisco(getId(), NameSet("audio", "AnyAudioClass", ""),
           "AudioObjectFixed", "autopilotdisco", Channel::Events,
           Channel::OneOrMoreEntries, Channel::MixedPacking),

    w_apbutton(getId(), NameSet("audio", "AnyAudioClass", ""),
            "AudioObjectFixed", "apbutton", Channel::Events,
            Channel::OneOrMoreEntries, Channel::MixedPacking),

    //w_comm(getId(), NameSet("audio", "AnyAudioClass", ""), // added by Matteo Piras - up to here all ok
             //"AudioObjectFixed", "audiot", Channel::Events,
             //Channel::OneOrMoreEntries, Channel::MixedPacking),

    // label invullen en in modfile aantal parameters koppelen aan het label

    // motor

  // activity initialization
  cb1(this, &PA34_model::doCalculation),
  do_calc(getId(), "Calculates aircraft dynamics ", &cb1, ps)
{
  // do the actions you need for the simulation
 /* for(int i=0;i<8;i++)
    turb_gains[i] = 1.0;
  */

  // uncomment and complete to connect the triggers for simulation
  // do_calc.setTrigger(/* fill in your triggering channels */);
  //TODO
  do_calc.setTrigger(cpi_token);
  //do_calc.setTrigger(*Ticker::single()); // for SRS (timing issues)

  // uncomment and complete to connect the triggers for trim
  // calculation. Leave this out if you not need input for trim
  // calculation
  // trimCalculationCondition(/* fill in your trim triggering channels */);

  // pleas add a check that the RTW model sizes are what you are expecting
  assert(NINPUTS  == U_no_inputs);
  assert(NOUTPUTS == Y_no_outputs);
  assert(NCSTATES == X_no_states);
  //assert(NOUTPUTS == CitationOutput::y_fixed_size);

  /* ---------------------------------------------------------------- */
  /* Real-time workshop model initialisation                          */

  // initialise global stuff
  rt_InitInfAndNaN(sizeof(real_T));

  // create the model
  S = createAndInitialiseModel();

  // do one output call, be very careful with these, since they have
  // side effects. State changes after an outputs call cannot undo these
  rtmiOutputs(rtmGetRTWRTModelMethodsInfo(S), 0);

  /* ---------------------------------------------------------------- */
  /* Real-time workshop model initialisation for trim calculator      */
  i_S = createAndInitialiseModel();

  /* some checks. */
  assert(sizeof(real_T) == sizeof(double));
}

pa34model_dueca_8b_rtModel *PA34_model::createAndInitialiseModel()
{
  pa34model_dueca_8b_rtModel * S1 = pa34model_dueca_8b();

  //D_MOD(classname << " created model @ " << S1);
  if (S1 == NULL) {
    E_MOD(getId() << " Cannot create model \"pa34model_dueca_8b\"");
    exit(1);
  }
  if (rtmGetErrorStatus(S1) != NULL) {
    E_MOD(getId() << " Error creating model \"pa34model_dueca_8b\"");
    exit(1);
  }

  // further initialisation
  rtmiInitializeSizes(rtmGetRTWRTModelMethodsInfo(S1));
  rtmiInitializeSampleTimes(rtmGetRTWRTModelMethodsInfo(S1));

  // adjust the step size if changed before by the user
  // initialisation of the timing engine uses this step size
  if (dt > 0.0) {
    rtmSetStepSize(S1, dt);
  }

  // timing engine
  const char* status = rt_SimInitTimingEngine
    (rtmGetNumSampleTimes(S1),    rtmGetStepSize(S1),
     rtmGetSampleTimePtr(S1),     rtmGetOffsetTimePtr(S1),
     rtmGetSampleHitPtr(S1),      rtmGetSampleTimeTaskIDPtr(S1),
     rtmGetTStart(S1),            &rtmGetSimTimeStep(S1),
     &rtmGetTimingData(S1));
  if (status != NULL) {
    E_MOD(getId() << " Failure in timing engine \"pa34model_dueca_8b\"");
    exit(1);
  }


  // integration data
#if NCSTATES > 0
  rt_ODECreateIntegrationData(rtmGetRTWSolverInfo(S1));
  if(rtmGetErrorStatus(S1) != NULL) {
    E_MOD(getId() << " Failure integration data \"pa34model_dueca_8b\"");
    exit(1);
  }
#endif
  rtmiStart(rtmGetRTWRTModelMethodsInfo(S1));
  if (rtmGetErrorStatus(S1) != NULL) {
    E_MOD(getId() << " Cannot start \"pa34model_dueca_8b\"");
    exit(1);
  }

  return S1;
}

void PA34_model::destroyModel(pa34model_dueca_8b_rtModel *dS)
{
  //D_MOD(classname << " destroying model @ " << dS);
  rt_SimDestroyTimingEngine(rtmGetTimingData(dS));
#if NCSTATES > 0
  rt_ODEDestroyIntegrationData(rtmGetRTWSolverInfo(dS));
#endif
  rtmiTerminate(rtmGetRTWRTModelMethodsInfo(dS));
}

bool PA34_model::complete()
{
  /* All your parameters have been set. You may do extended
     initialisation here. Return false if something is wrong. */

  // now that we know the time step, set the trim increment
  //trim_incr = trim_speed*dt; //TODO take a look at how this is done and use for gear and flaps

  // set the flaps and gear increment
  flap_incr = dt*flap_speed;
  gear_incr = dt/gear_time;
  D_MOD(classname << " flap increment: " << flap_incr << ", gear increment: " << gear_incr);

  // get an initial value for the trimmed elevator angle
  //real_T* Y = reinterpret_cast<real_T*>(rtmGetY(S));
  //de0 = Y[Y_de0

  // TODO check what is going on here
  //TODO probleem met de LATER OPLOSSEN x_de IS NU GEEN STATE
  // real_T* X = reinterpret_cast<real_T*>(rtmGetContStates(S));
  prev_de = 0.08;
  //  D_MOD(classname << " initial delta_e: " << prev_de);

  return true;
}

// destructor
PA34_model::~PA34_model()
{
  destroyModel(S);
  destroyModel(i_S);
}

// as an example, the setTimeSpec function
bool PA34_model::setTimeSpec(const TimeSpec& ts)
{
  // a time span of 0 is not acceptable
  if (ts.getValiditySpan() == 0) return false;

  // specify the timespec to the activity
  do_calc.setTimeSpec(ts);

  // do whatever else you need to process this in your model
  dt = ts.getDtInSeconds();
  if (fabs(rtmGetStepSize(S) - dt) > 1e-8) {
    W_MOD(getId() << '/' << classname <<
	  " new time step different from step in generated code!\n" <<
	  "       Check that your model is able to handle this" <<
	  "       model timestep " << rtmGetStepSize(S) << " , used ts " << dt );

    // this is not called under real-time running, so we may adjust
    // (and destroy) the model freely
    destroyModel(S);

    // the new model will be created with the modified step size
    S = createAndInitialiseModel();
  }

  // return true if everything is acceptable
  return true;
}

// and the checkTiming function
bool PA34_model::checkTiming(const vector<int>& i)
{
  if (i.size() == 3) {
    new TimingCheck(do_calc, i[0], i[1], i[2]);
  }

  else if (i.size() == 2) {
    new TimingCheck(do_calc, i[0], i[1]);
  }
  else {
    return false;
  }
  return true;
}


// tell DUECA you are prepared
bool PA34_model::isPrepared()
{
  // do whatever additional calculations you need to prepare the model.
  bool res = true;

  CHECK_TOKEN(cpi_token);

  CHECK_TOKEN(turb_token);
  CHECK_TOKEN(sr_token);
  CHECK_TOKEN(repos_token);
  CHECK_TOKEN(trim_inco_token);

  CHECK_TOKEN(mass_token);
  CHECK_TOKEN(engine_token);
  CHECK_TOKEN(control_token);
  CHECK_TOKEN(comm_token);

  CHECK_TOKEN(ap_token);


  CHECK_TOKEN(mass_feedback_token);
  CHECK_TOKEN(engine_feedback_token);

  CHECK_TOKEN(out_token);
  CHECK_TOKEN(ma_token);
  CHECK_TOKEN(vcp_token);
  CHECK_TOKEN(vcm_token);
  CHECK_TOKEN(snd_token);

  //CHECK_TOKEN(hold_request);
  CHECK_TOKEN(snap_token);
  CHECK_TOKEN(cpi_trim_token);

  CHECK_TOKEN(w_observer);
  CHECK_TOKEN(w_gearup);
  CHECK_TOKEN(w_geardown);
  CHECK_TOKEN(w_flaps);
  CHECK_TOKEN(w_sndwind);
  CHECK_TOKEN(w_sndstall);
  CHECK_TOKEN(w_sndmass);
  CHECK_TOKEN(w_sndspeed);
  CHECK_TOKEN(w_sndwheel);
  CHECK_TOKEN(w_sndtd);
  CHECK_TOKEN(w_gearalert);
  CHECK_TOKEN(w_autopilotdisco);
  CHECK_TOKEN(w_apbutton);
  //CHECK_TOKEN(w_comm);


  // return result of checks
  return res;
}

// start the module
void PA34_model::startModule(const TimeSpec &time)
{
  do_calc.switchOn(time);
}

// stop the module
void PA34_model::stopModule(const TimeSpec &time)
{
  do_calc.switchOff(time);
}

// fill a snapshot with state data. You may remove this method (and the
// declaration) if you specified to the SimulationModule that the size of
// state snapshots is zero
void PA34_model::fillSnapshot(const TimeSpec& ts,
                              Snapshot& snap, bool from_trim)
{
  // The most efficient way of filling a snapshot is with an AmorphStore
  // object.
  AmorphStore s(snap.accessData(), snap.getDataSize());

  D_MOD(classname << " Snapshot size= " << snap.getDataSize() );


  if (from_trim) {
    real_T* X = reinterpret_cast<real_T*>(rtmGetContStates(i_S));
    for (int ii = 0; ii < 17; ii++) packData(s, X[ii]);

    #ifdef NDSTATES
    X = reinterpret_cast<real_T*>(rtmGetDiscStates(i_S));
    for (int ii = 0; ii < 17; ii++) packData(s, X[ii]);
    #endif
  }
  else {
    for (int ii = 0; ii < 17; ii++) packData(s, s_x[ii]);
  }
}

// reload from a snapshot. You may remove this method (and the
// declaration) if you specified to the SimulationModule that the size of
// state snapshots is zero
void PA34_model::loadSnapshot(const TimeSpec& t, const Snapshot& snap)
{
  if (Sold != NULL) {
    destroyModel(Sold);
    Sold = NULL;
  }

  // check that there is room to make a new model
  if (Snew != NULL) {
    W_MOD(getId() << '/' << classname << " no room for snapshot");
    return;
  }

  // access the data in the snapshot with an AmorphReStore object
  AmorphReStore s(snap.data, snap.data_size);

  // Start with a new model. There are simply too much side effects in
  // the model creation functions (setting work vectors to 0, etc.),
  // to believe that a proper reset is possible. We found often enough
  // that a second run with a re-initialised model produces strange
  // effects.
  pa34model_dueca_8b_rtModel *S2 = createAndInitialiseModel();

  // do an outputs call, will reset integrators to default first time
  rtmiOutputs(rtmGetRTWRTModelMethodsInfo(S2), 0);

  // restore the state vector. Note that the re-start puts the state
  // vector to the initial one, we have to do it after, or otherwise
  // this is undone
  real_T* X = reinterpret_cast<real_T*>(rtmGetContStates(S2));
  for (int ii = 0; ii < NCSTATES; ii++) {
    unPackData(s, X[ii]);
    //D_MOD(classname << " unpacked state # " << ii << " = " << X[ii]);
  }
#ifdef NDSTATES
  X = reinterpret_cast<real_T*>(rtmGetDiscStates(S2));
  for (int ii = 0; ii < NDSTATES; ii++) {
    unPackData(s, X[ii]);
    //D_MOD(classname << " unpacked state # " << ii << " = " << X[ii]);
  }
#endif

  D_MOD(classname << " Reloading new model NC states= " << NCSTATES);

  // new model is ready now, leave in pick-up location
  Snew = S2;

  //D_MOD(classname << " S2 @ " << S2 << " S @ " << S);
  //D_MOD(classname << " S2.X[3] " << X[3]);

  // QUICK FIX reset the wind
  // this should be fixed in the model, after which
  // most wind related code in this file can be removed
  wind_vel = 0;
  wind_vel_nsteps = 0;
}


// this routine contains the main simulation process of your module. You
// should read the input channels here, and calculate and write the
// appropriate output


void PA34_model::doCalculation(const TimeSpec& ts)
{

    if (comm_token.getNumWaitingEvents(ts)) //added by Matteo Piras
    {
        try
        {
            EventReader<CommEvent> comm(comm_token, ts);

            radiocomm = comm.data().radiocomm;

            //if (fade_in == 1) { // if we fly
                //DataWriter<AudioObjectFixed> sndmass(w_sndmass, ts);
                //sndmass.data().volume = 2.0f;
                //sndmass.data().pitch = 1.0;
            //}

        }
        catch (Exception& e)
        {
            W_MOD(classname << " caught " << e << " @ " << ts << " when reading MassEvent" );
        }
    }


	// Read MassEvent
	if (mass_token.getNumWaitingEvents(ts))
	{
		try
		{
			EventReader<MassEvent> m(mass_token, ts);

			// mass shift data
			//m.data().id;
			asym_x    = m.data().x;
			asym_y    = m.data().y;
			asym_z    = m.data().z;
			asym_mass = m.data().mass;

			//number of steps to make
			mass_nsteps = m.data().time / dt;
			// at least one step
			if (mass_nsteps < 1) mass_nsteps = 1;
			// size of each step
			dx    = (asym_x - old_x)       / mass_nsteps;
			dy    = (asym_y - old_y)       / mass_nsteps;
			dz    = (asym_z - old_z)       / mass_nsteps;
			dmass = (asym_mass - old_mass) / mass_nsteps;

			I_MOD(classname << " Preparing for mass shift in " << mass_nsteps << " steps");

            if (fade_in == 1) { // if we fly
                DataWriter<AudioObjectFixed> sndmass(w_sndmass, ts);
                sndmass.data().volume = 2.0f;
                sndmass.data().pitch = 1.0;
            }

		}
		catch (Exception& e)
		{
			W_MOD(classname << " caught " << e << " @ " << ts << " when reading MassEvent" );
		}
	}

	// Read EngineEvent
	if (engine_token.getNumWaitingEvents(ts))
	{
		try
		{
			EventReader<EngineEvent> e(engine_token, ts);

			// engine data
			//e.data().id;
			if (LEFT_RPM != e.data().max_rpm_left)
			{
				LEFT_RPM   = e.data().max_rpm_left;
				I_MOD(classname << ": Setting left max RPM: "<< LEFT_RPM);
			}
			if (RIGHT_RPM != e.data().max_rpm_right)
			{
				RIGHT_RPM  = e.data().max_rpm_right;
				I_MOD(classname << ": Setting right max RPM: "<< RIGHT_RPM);
			}
			// check for difference between set engine power and current engine power limit
			// left engine
			if ( fabs(e.data().power_left - power_left) > 0.001) {
				//number of steps to make
				pla_nsteps_left = e.data().time_left / dt;
				// at least one step
				if (pla_nsteps_left < 1) pla_nsteps_left = 1;
				// size of each step
				pla_stepsize_left = (e.data().power_left - power_left) / pla_nsteps_left;

				I_MOD(classname << ": Changing left engine power");
			}
			// right engine
			if ( fabs(e.data().power_right - power_right) > 0.001) {
				//number of steps to make
				pla_nsteps_right = e.data().time_right / dt;
				// at least one step
				if (pla_nsteps_right < 1) pla_nsteps_right = 1;
				// size of each step
				pla_stepsize_right = (e.data().power_right - power_right) / pla_nsteps_right;

				I_MOD(classname << ": Changing right engine power");
			}
		}
		catch (Exception& e)
		{
			W_MOD(classname << " caught " << e << " @ " << ts << " when reading EngineEvent" );
		}
	}

	// Read ControlEvent
	if (control_token.getNumWaitingEvents(ts))
	{
		try
		{
			EventReader<ControlEvent> c(control_token, ts);

			// control data
			//c.data().id;
			aileron_power = c.data().aileron_power;
			//c.data().aileron_power_time;
			//c.data().aileron_delta;
			//c.data().aileron_delta_time;
			rudder_power = c.data().rudder_power;
			//c.data().rudder_power_time;
			//c.data().rudder_delta;
			//c.data().rudder_delta_time;
			//gear_fail = c.data().gear_fail;
			rudder_offset = c.data().rudder_offset;
			rudder_offset_time = c.data().rudder_offset_time;
			rudder_bias = c.data().rudder_bias;
			elevator_fix = c.data().elevator_fix;

			// ARI
			if (ARI != c.data().ARI)
			{
				ARI = c.data().ARI;
				I_MOD(classname << " Setting ARI: "<< ARI);
			}

			// output new values
			I_MOD(classname << " Set control; Aileron power: " << aileron_power
			                << "; Rudder power: " << rudder_power
			                << "; Rudder fix: " << rudder_bias
			                << "; Elevator fix: " << elevator_fix );

		}
		catch (Exception& e)
		{
			W_MOD(classname << " caught " << e << " @ " << ts << " when reading ControlEvent" );
		}
	}

	// Read WindEvent
	if(turb_token.getNumWaitingEvents(ts))
	{
		try
		{
			EventReader<WindEvent> w(turb_token, ts);

			// wind data
			//w.data().id;

			// turbulence and the intensity
			if(w.data().turbulence) {
				K_turb = w.data().turb_int;

				if (K_turb>0 && wind_vel<1) {
					// turbulence requires wind
					//wind_vel = 1; // changed from 10 to 1, as 10 m/s is too much wind to have as a minimum
					W_MOD(classname << " Turbulence requires wind to function" << endl );
				}
				I_MOD(classname << " Turbulence enabled: K_turb=" << K_turb );
			}
			else {
				K_turb = 0; // no turbulence
				I_MOD(classname << " Turbulence disabled: K_turb=" << K_turb );
			}

			// wind shear, or gust, is simple
			K_shear  = w.data().gust;
			I_MOD(classname << " K_shear: " << K_shear);

			// wind velocity, increasing in steps, decreasing all at once
			// see also the reset in PA34_model::loadSnapshot()
			if (fabs(w.data().wind_vel - wind_vel) > 0.001) {
				//number of steps to make
				wind_vel_nsteps = 5.0f / dt; // hardcoded time of 5 s
				// at least ten step
				if (wind_vel_nsteps < 10) wind_vel_nsteps = 10;
				// size of each step
				wind_vel_stepsize = (w.data().wind_vel - wind_vel) / wind_vel_nsteps;
			}

			// wind direction
			// when standing still, a wind change is a problem
			// fixed for direction, but angle can change max 30 deg at a time
			// no problem when moving, even the slightest movement is ok
			//TODO slowly move wind_dir to the commanded setting
			// wind dir should be set if in hold, slowly change in advance
			//  note the 360 deg and going round thing, determine going clockwise or counter clockwise
			//
			// warning if there is wind and the dir change is over 5 degrees
			if ( wind_vel > 0.1
			     && fabs(w.data().wind_dir - wind_dir) > 5
			     && fabs(w.data().wind_dir - wind_dir) < (360 - 5)
			   ) {
				W_MOD(classname << ": Wind direction change of more than 5 degrees");

				// number of steps to make
				wind_dir_nsteps = 5.0f / dt; // hardcoded time of 5 s
				// angle between the current and commanded wind direction [rad]
				float diffangle = w.data().wind_dir - wind_dir;
				// circle
				if (diffangle > +180) diffangle-=360;
				if (diffangle < -180) diffangle+=360;
				// size of each step
				// in rad instead of deg
				wind_dir_stepsize = diffangle / wind_dir_nsteps;

				I_MOD(classname << ": changing wind dir: steps " << wind_dir_nsteps);
				I_MOD(classname << ": changing wind dir: angle " << diffangle);
				I_MOD(classname << ": changing wind dir: ssize " << wind_dir_stepsize);
			}
			else {
				// if the wind velocity is almost zero
				// this can be done in one step
				wind_dir = w.data().wind_dir;
				wind_dir_nsteps = 0;
				I_MOD(classname << ": Wind direction changed instantly to " << wind_dir);
			}
		}
		catch (Exception& e)
		{
			W_MOD(classname << " caught " << e << " @ " << ts << " (reading WindEvent)");
		}
	}


  // check the state we are supposed to be in
  switch (getAndCheckState(ts)) {
  case SimulationState::HoldCurrent: {
	fade_in=0;
      flying = false;

	// check if there's a new model waiting
	if(Snew) {
		//D_MOD(classname << " before: Snew @ " << Snew << " Sold @ " << Sold << " S @ " << S);

		Sold = S;
		S = Snew;
		destroyModel(Sold);
		Sold = NULL;
		Snew = NULL;

		D_MOD(classname << " picked up new model @ " << ts);

		//D_MOD(classname << " after: Snew @ " << Snew << " Sold @ " << Sold << " S @ " << S);
	}

	// set de inco waarden die niet in de Pa 34 state zitten
	// read event on Trim_inco and send event on CitationPilotInput
	if(trim_inco_token.getNumWaitingEvents(ts))
	{
		try
		{
			EventReader<Trim_inco> trim(trim_inco_token, ts);
			EventWriter<CitationPilotInput> cpi_trim(cpi_trim_token, ts);

			//D_MOD(classname << " Trim_input from inco: " << trim.data());

			cpi_trim.data().de = trim.data().de_trim;
			cpi_trim.data().da = trim.data().da_trim;
			cpi_trim.data().dr = trim.data().dr_trim;

			// de wordt goed gezet maar da dr en gear niet
			// same problem for flaps?
			// this thing is read by the FCSAdapter - only de is set, the rest is ignored

			flap_pos = trim.data().flaps_trim; // rad
			gear_pos = trim.data().gear_trim; // 0 or 1
			I_MOD(classname << " (trim_inco) gear position: " << gear_pos );
			I_MOD(classname << " (trim_inco) flap position: " << flap_pos/DEG2RAD << " deg" );

			// engine wordt getrimd vanuit trim channel

			inco_loaded = true;
		}
		catch(Exception& e)
		{
			W_MOD(classname << " caught " << e << " @ " << ts << " (reading Trim_inco)" );
		}
	}

	// this updates outputs
	rtmiOutputs(rtmGetRTWRTModelMethodsInfo(S), 0);

	// (re)set MASS SHIFT settings if needed (in one step)
	if (mass_nsteps > 0)
	{
		mass_nsteps = 0;
		old_x    = asym_x;
		old_y    = asym_y;
		old_z    = asym_z;
		old_mass = asym_mass;

		// sturen van de data over het kanaal
		EventWriter<MassEvent> asym(mass_feedback_token, ts);
		asym.data().x    = old_x;
		asym.data().y    = old_y;
		asym.data().z    = old_z;
		asym.data().mass = old_mass;

		I_MOD(classname << " updated mass shift in Hold" );
	}

	// (re)set engine power settings if needed (in one step)
	if (pla_nsteps_left > 0 || pla_nsteps_right > 0)
	{
		// LEFT ENGINE
		if (pla_nsteps_left > 0) {
			power_left += pla_stepsize_left*pla_nsteps_left;
			pla_nsteps_left = 0;
			I_MOD(classname << ": left engine power setting: " << power_left);
		}
		// RIGHT ENGINE
		if (pla_nsteps_right > 0) {
			power_right += pla_stepsize_right*pla_nsteps_right;
			pla_nsteps_right = 0;
			I_MOD(classname << ": right engine power setting: " << power_right);
		}
		// send out current engine power
		EventWriter<EngineEvent> e(engine_feedback_token,ts);
		e.data().power_left  = power_left;
		e.data().power_right = power_right;
	}

    // repositioning
	if(repos_token.getNumWaitingEvents(ts))
	{
		try
		{
			EventReader<Reposition> repos(repos_token, ts);

			real_T* X = reinterpret_cast<real_T*> (rtmGetContStates(S));
			X[X_X]    =  repos.data().repos_x;
			X[X_Y]    =  repos.data().repos_y;
			X[X_Z]    = -repos.data().repos_h;
			X[X_PSI]  =  repos.data().repos_psi;

			D_MOD(classname << " Rx: " << repos.data());
		}
		catch(Exception& e)
		{
			W_MOD(classname << " caught " << e << " @ " << ts);
		}
	}

    // TODO check what is going on here
	// als er geen inco is geladen kan/zal  X[x_de] precies nul zijn
	// Dan default pitch trim waarden invoeren , niet nodig nadat een inco is geladen
	if(!inco_loaded) {
		// trim stand indien er geen ieuwe inco is
		EventWriter<CitationPilotInput> cpi_trim(cpi_trim_token, ts);
		cpi_trim.data().de = 0.08;
		D_MOD(classname << " nieuwe de " <<  cpi_trim.data().de);

		inco_loaded = true; // just do this once
	}

	break;
  }
  case SimulationState::Replay:
  case SimulationState::Advance: {

	// let fade_in increase to 1 over a period of 2 seconds
	fade_in = fmin(1, fade_in + dt/2.0f);

	// update mass shift?
	if (mass_nsteps > 0)
	{
		// change at each timestep
		mass_nsteps--;
		old_x    += dx;
		old_y    += dy;
		old_z    += dz;
		old_mass += dmass;
		if (mass_nsteps == 0)
		{
			// just to make sure
			old_x    = asym_x;
			old_y    = asym_y;
			old_z    = asym_z;
			old_mass = asym_mass;

			I_MOD(classname << ": updated mass shift to final position" );
		}
		// send out the current values for reporting and log
		EventWriter<MassEvent> asym(mass_feedback_token, ts);
		asym.data().x    = old_x;
		asym.data().y    = old_y;
		asym.data().z    = old_z;
		asym.data().mass = old_mass;

        D_MOD(mass_nsteps);
	}

	// update available engine power multiplier?
	if (pla_nsteps_left > 0 || pla_nsteps_right > 0)
	{
		// LEFT ENGINE
		if (pla_nsteps_left > 0) {
			power_left += pla_stepsize_left;
			pla_nsteps_left--;

			if (pla_nsteps_left == 0)
				I_MOD(classname << ": left engine power setting reached final value: " << power_left);
		}
		// RIGHT ENGINE
		if (pla_nsteps_right > 0) {
			power_right += pla_stepsize_right;
			pla_nsteps_right--;

			if (pla_nsteps_right == 0)
				I_MOD(classname << ": right engine power setting reached final value: " << power_right);
		}
		// send out current engine power
		EventWriter<EngineEvent> e(engine_feedback_token,ts);
		e.data().power_left  = power_left;
		e.data().power_right = power_right;
	}

	// update wind velocity?
	if (wind_vel_nsteps > 0)
	{
		wind_vel += wind_vel_stepsize;
		wind_vel_nsteps--;

		if (wind_vel_nsteps == 0)
			I_MOD(classname << ": wind velocity setting reached final value: " << wind_vel);
	}
	// update wind direction?
	if (wind_dir_nsteps > 0)
	{
		wind_dir += wind_dir_stepsize;
		wind_dir_nsteps--;

		if (wind_dir < 0)   wind_dir+=360;
		if (wind_dir > 360) wind_dir-=360;

		if (wind_dir_nsteps == 0)
			I_MOD(classname << ": wind direction setting reached final value: " << wind_dir);
	}

	// obtain a pointer to the model input
	real_T* U = reinterpret_cast<real_T*>(rtmGetU(S));

  try
  {
    StreamReaderLatest<AutopilotChannel> ap(ap_token, ts);
    APstate = ap.data().APstate;
    ap_de = ap.data().de;
    ap_da = ap.data().da;
    ap_dr = ap.data().dr;
  }
  catch(Exception &e)
  {
    W_MOD(getId() << " caught " << e << " @ " << ts << "(reading AutopilotChannel)" );
  }

	try
	{
	  StreamReader<CitationPilotInput> cpi(cpi_token, ts);
		//StreamReaderLatest<CitationPilotInput> cpi(cpi_token);

		/*
		// Warning maximale uitslagen
		if (cpi.data().de< -0.2  || cpi.data().de >0.1) { cout << "de extreem=" << cpi.data().de << endl; }
		if (cpi.data().da< -0.75 || cpi.data().de >0.75){ cout << "da extreem=" << cpi.data().da << endl; }
		if (cpi.data().dr< -0.5  || cpi.data().dr >0.5) { cout << "dr extreem=" << cpi.data().dr << endl; }
		*/

		// Surface deflections [rad]

		U[U_de] = ( fabs(elevator_fix) < 1e-5 ? cpi.data().de : elevator_fix*DEG2RAD ); // elevator, might be fixed in place
    U[U_da] = cpi.data().da;
    U[U_dr] = ( cpi.data().de < 1e-5 ? (cpi.data().dr + cpi.data().da * ARI) * 0.5 : cpi.data().dr + cpi.data().da * ARI ); // Includes aileron rudder connect (ARI). Correction for ground roll


    // if(APstate == 1){
    //   U[U_de] = ( fabs(elevator_fix) < 1e-5 ? ap_de : elevator_fix*DEG2RAD );
    //   U[U_da] = ap_da;
    //   U[U_dr] = ( ap_de < 1e-5 ? (ap_dr + ap_da * ARI) * 0.5 : ap_dr + ap_da * ARI );
    // }

		// Check rudder deflection
		//if(U[U_dr]>0.5) { cout << " dr groter dan 0.5" << endl;   U[U_dr] = 0.5; }
		//if(U[U_dr]<-0.5){ cout << " dr kleiner dan -0.5" << endl; U[U_dr] = -0.5; }

		/* // the old way of moving flaps
		if (U[U_df] > cpi.data().df+0.0025) { U[U_df] -= 0.0015; } // go up
		if (U[U_df] < cpi.data().df-0.0025) { U[U_df] += 0.0015; } // go down
		*/

		if (gear_pos > eventgeardown && eventgeardown != 0.0){

        cout << eventgeardown << endl;
		    rudder_bias = rudder_bias;
		    check_gear_asym = true;

		}

		if(check_gear_asym = true && gear_pos < 0.3){

		  rudder_bias = 0.0;

		}

		//if(radioevent == true){

		    //radiocomm = radiocomm;
           // DataWriter<AudioObjectFixed> sndcomm(w_comm, ts);
           // sndcomm.data().volume = 0.5f;
           // sndcomm.data().pitch = 1.0;
            //D_MOD("comm sound sent");


		//}

		//TODO option to disable normal operations, setting flapsOK or gearOK to false

		// MOVE FLAPS
		// angle in RAD, max 0.7 rad (40 deg) deflection
		//TODO check speed, have not found a source on flap speed yet
		if (flapsOK) {

            if (flap_pos > cpi.data().df) {

             if (flap_pos > 0.696732) {
                 DataWriter<AudioObjectFixed> sndflaps(w_flaps, ts);
                 sndflaps.data().volume = 0.5f;
                 sndflaps.data().pitch = 1.0;
                 D_MOD("flaps sound sent");

             }
                flap_pos = fmax(cpi.data().df, flap_pos-flap_incr); // go up
            }

			if (flap_pos < cpi.data().df) {

                if (flap_pos < 0.000934394) {
                    DataWriter<AudioObjectFixed> sndflaps(w_flaps, ts);
                    sndflaps.data().volume = 0.5f;
                    sndflaps.data().pitch = 1.0;
                    D_MOD("flaps sound sent");
                }

                flap_pos = fmin(cpi.data().df, flap_pos+flap_incr); // go down
            }
		}

		// MOVE GEAR
		// SENECA III manual Section 7.9 states that "Gear extension or retraction normally takes 6 to 7 seconds."
        if (gearOK) {
            if (gear_pos > cpi.data().gear) {

                if (gear_pos == cpi.data().gear + 1) {
                    DataWriter<AudioObjectFixed> sndgearup(w_gearup, ts);
                    sndgearup.data().volume = 0.5f;
                    sndgearup.data().pitch = 1.0;
                }

                gear_pos = fmax(cpi.data().gear, gear_pos-gear_incr); // go up   -> to 0
            }

            if (gear_pos < cpi.data().gear) {

                if (gear_pos == cpi.data().gear - 1) {
                    DataWriter<AudioObjectFixed> sndgeardown(w_geardown, ts);
                    sndgeardown.data().volume = 0.5f;
                    sndgeardown.data().pitch = 1.0;
                }
                gear_pos = fmin(cpi.data().gear, gear_pos+gear_incr); // go down -> to 1
            }
        }

		// pla setting to model = pilot input * power setting multiplier
		U[U_pla1] = cpi.data().pla1 * power_left;
		U[U_pla2] = cpi.data().pla2 * power_right;
	}
	catch(Exception &e)
	{
		W_MOD(getId() << " caught " << e << " @ " << ts << "(reading CitationPilotInput)" );

		// safe (defined) inputs for model
		U[U_de] = 0.0;
		U[U_da] = 0.0;
		U[U_dr] = 0.0;
		U[U_pla1] = 0.0;
		U[U_pla2] = 0.0;
	}

  if (ap2g1000_token.getNumWaitingEvents(ts))
  {
    try
    {
      EventReader<AP2G1000Channel> ap2g1000_reader(ap2g1000_token, ts);

      if(ap2g1000_reader.data().ap_flash && autopilotdisco_notplaying){
        DataWriter<AudioObjectFixed> autopilotdisco_writer(w_autopilotdisco,ts);
        autopilotdisco_writer.data().pitch = 1.0;
        autopilotdisco_writer.data().volume = 1.0;
        autopilotdisco_notplaying = false;
      }else{
        autopilotdisco_notplaying = true;
      }
    }
    catch (Exception& e)
    {
      W_MOD(classname << ": Error while reading AP2G1000Channel!");
    }
  }

  if (gfcr_token.getNumWaitingEvents(ts))
  {
    try
    {
      EventReader<GFC700Event> gfc(gfcr_token, ts);
      msg = gfc.data().msg;

      if(msg != GFC700Event::GFC700_NONE){
        DataWriter<AudioObjectFixed> apbutton_writer(w_apbutton,ts);
        apbutton_writer.data().pitch = 1.0;
        apbutton_writer.data().volume = 1.0;
        msg = GFC700Event::GFC700_NONE;
      }
    }
    catch (Exception& e)
    {
      W_MOD(classname << ": Error while reading GFC700Event!");
    }
  }

  //if (gear_fail == true){
      //rudder_offset      = rudder_offset;
      //rudder_offset_time = 6.0;
  //}

	// FILLING REMAINDER OF THE INPUT_VEC FOR MODEL
	// always set all data in the input vector
	// do not trust data which is already in this vector

	// Trim surface deflections are not included in the model
	U[U_dte] = 0.0;
	U[U_dta] = 0.0;
	U[U_dtr] = 0.0;

	// flaps and gear position to model input
	U[U_df]   = flap_pos;
	U[U_gear] = gear_pos;

	// The following items do not depend on pilot input
	// For ease of use: in order of how they appear in StatesOutputs.h and go into the model
	// wind and turbulence
	U[U_gust_u]        = wind_vel; // In dit model is dit de windsnelheid (m/s)
	U[U_gust_alpha]    = wind_dir*DEG2RAD; // Dit is de windrichting [rad]
	U[U_gust_beta]     = K_turb;   // De turbulence intensity
	U[U_gust_udot]     = 1.0;      // K-gust
	U[U_gust_alphadot] = 0.0;      // Event gust (time in seconds na start?
	U[U_gust_betadot]  = K_shear;  // K-shear kiezen voor shear of constante wind
	// max rpm limits
	U[U_max_rpm_left]  = LEFT_RPM;
	U[U_max_rpm_right] = RIGHT_RPM;
	// terrain elevation
	U[U_terr_elev]     = terr_elevation;
	// mass shift
	U[U_asym_x]        = old_x;
	U[U_asym_y]        = old_y;
	U[U_asym_z]        = old_z;
	U[U_asym_mass]     = old_mass;
	// control power
	U[U_aileron_power] = aileron_power;
    U[U_rudder_power] = rudder_power;
	U[U_rudder_bias]   = rudder_bias;


#if !defined(MULTITASKING)

    // do the simulation calculations, one step
    real_T tnext = rt_SimGetNextSampleHit(rtmGetTimingData(S),
					  rtmGetNumSampleTimes(S));
    rtsiSetSolverStopTime(rtmGetRTWSolverInfo(S), tnext);

#ifndef ADVANCE_OUTPUTS
    // calculate outputs for continuous or base rate
    rtmiOutputs(rtmGetRTWRTModelMethodsInfo(S), 0);
#endif

    // call for an update
    rtmiUpdate(rtmGetRTWRTModelMethodsInfo(S), 0);

    // do the hit array updates for the single discrete task
    rt_SimUpdateDiscreteTaskSampleHits(rtmGetNumSampleTimes(S),
                                       rtmGetTimingData(S),
                                       rtmGetSampleHitPtr(S),
                                       rtmGetTPtr(S));

    // if task 0 is continuous, to an integration step update
#if NCSTATES > 0
    if (rtmGetSampleTime(S, 0) == CONTINUOUS_SAMPLE_TIME) {
      rt_ODEUpdateContinuousStates(rtmGetRTWSolverInfo(S));
    }
#endif

#ifdef ADVANCE_OUTPUTS
    // calculate outputs for continuous or base rate
    rtmiOutputs(rtmGetRTWRTModelMethodsInfo(S), 0);
#endif


#else // multitasking

#error "Using a multitasking model is asking for trouble"

#endif

    break;
  }
  default:
    // other states should never be entered for a SimulationModule,
    // HardwareModules on the other hand have more states. Throw an
    // exception if we get here,
    throw CannotHandleState(getId(),GlobalId(), "state unhandled");
  }

  // DUECA applications are data-driven. From the time a module is switched
  // on, it should produce data, so that modules "downstreams" are activated

  // access the output from the model
  real_T* Y = reinterpret_cast<real_T*>(rtmGetY(S));


  // access the current state of the model
  //real_T* X = reinterpret_cast<real_T*>(rtmGetContStates(S));
  //D_MOD(classname << " output model X[3] = " << X[3]);

  // write the output into the output channel, using the stream writer

  {
    StreamWriter<CitationOutput> y(out_token,ts);
    // y.data().var1 = Y[0]; ...
    #if GENCODEGEN >= 110
      for(unsigned int i = 0; i < y.data().y.size(); i++) {
    #else
      for(unsigned int i = 0; i < 47; i++) {
    #endif
        y.data().y[i] = Y[i];
      }

      // propagate gear position
      y.data().y[Y_gear] = gear_pos;
  }

  // remember the trimmed pitch input
  //de0 = Y[Y_de0];

  // visual output
  // transfrom from cg to pilot's eyepoint
  {
    sf=sin(Y[Y_phi]);   cf=cos(Y[Y_phi]);
    st=sin(Y[Y_theta]); ct=cos(Y[Y_theta]);
    sp=sin(Y[Y_psi]);   cp=cos(Y[Y_psi]);

    StreamWriter<VehicleCabPosition> vcp(vcp_token, ts);
    vcp.data().x     =  cp*ct*xcab + (cp*st*sf-sp*cf)*ycab + (cp*st*cf+sp*sf)*zcab +  Y[Y_x];
    vcp.data().y     =  sp*ct*xcab + (sp*st*sf+cp*cf)*ycab + (sp*st*cf-cp*sf)*zcab +  Y[Y_y];
    vcp.data().z     = -st   *xcab +  ct*sf          *ycab +  ct*cf          *zcab + -Y[Y_h];
    vcp.data().phi   = Y[Y_phi];
    vcp.data().theta = Y[Y_theta];
    vcp.data().psi   = Y[Y_psi];
    vcp.data().test  = 0;
  }


  //***** Output for the soundplayer ******//
  // gear and flap sounds are played as events (see above)

  // Position data for the observer of sound (not sure if needed)
  {
    DataWriter<BaseObjectMotion> observer(w_observer, ts);

    observer.data().xyz[0] = 0.0;
    observer.data().xyz[1] = 0.0;
    observer.data().xyz[2] = 0.0;

    observer.data().setquat(0, 0, 0);

    observer.data().uvw[0] = 0.0;
    observer.data().uvw[1] = 0.0;
    observer.data().uvw[2] = 0.0;

    observer.data().dt = dt;

  // Engine data voor Enginesound

    StreamWriter<PropSoundData> snd(snd_token, ts);
    if (fade_in > 0.5) { // if we fly
        snd.data().rpm[0]    = fade_in*Y[Y_rpmleft];
        snd.data().rpm[1]    = fade_in*Y[Y_rpmright];
        snd.data().torque[0] = fade_in*Y[Y_torqueleft];
        snd.data().torque[1] = fade_in*Y[Y_torqueright];
        snd.data().power[0]  = (power_left > 0.01 ? true : false);
        snd.data().power[1]  = (power_right > 0.01 ? true : false);
    }
    else {
        snd.data().rpm[0] = 0;
        snd.data().rpm[1] = 0;
        snd.data().torque[0] = 0;
        snd.data().torque[1] = 0;
        snd.data().power[0] = 0;
        snd.data().power[1] = 0;
    }

      // gear warning sound
      // if one of the engines is shut off, the plane is flying and the gear is up

      StreamReader<CitationPilotInput> cpi(cpi_token, ts);
      DataWriter<AudioObjectFixed> gearalert(w_gearalert,ts);

      if ((Y[Y_torqueleft] == 0 || Y[Y_torqueright] == 0) && Y[Y_h] > 3.0 && fade_in == 1 && gear_pos == 0) {

          gearalert.data().pitch = 1.0;
          gearalert.data().volume = 2.0;
      }

      DataWriter<AudioObjectFixed> sndwind(w_sndwind,ts);
      DataWriter<AudioObjectFixed> sndstall(w_sndstall,ts);
      DataWriter<AudioObjectFixed> sndspeed(w_sndspeed,ts);
      DataWriter<AudioObjectFixed> sndwheel(w_sndwheel,ts);
      DataWriter<AudioObjectFixed> sndtd(w_sndtd,ts);

      // speed buffet starts with low volume at Vno (190 kn) is 2 at Vne (217 kn)

      if (Y[Y_vtas] > 0.514444444 * 190 && fade_in == 1) {
          sndspeed.data().pitch = 1.0;
          sndspeed.data().volume = 2 * (Y[Y_vtas] - 0.514444444 * 190) / (217-190);
      }

      // wind sound
      if (fade_in == 1) { // if we fly

          sndwind.data().pitch = 1.0;
          sndwind.data().volume = Y[Y_vtas]/(0.514444444 * 140); // vol = 1 at 140 kn
      }

     // stall alert at alpha > 17 degrees
      if (Y[Y_alpha] > 0.3 && Y[Y_h] > 3.0) {

          sndstall.data().pitch = 1.0;
          sndstall.data().volume = 2.0f ;
      }

     // ground rumble sound
      if (Y[Y_h] < 1.9 && gear_pos == 1 && fade_in == 1) {

          sndwheel.data().pitch = 1.0;
          sndwheel.data().volume = Y[Y_vtas]/(0.514444444 * 40); // vol = 1 at v = 40 kn
      }

      // sound of touchdown

      // don't play the sound when we're still on the ground
      if (Y[Y_h] > 10) {
          flying = true;
      }

      if (Y[Y_h] < 1.25 && gear_pos == 1 && flying && Y[Y_vtas]/0.514444444 > 70) {

          sndtd.data().pitch = 1.0;
          sndtd.data().volume = 1.0f ;
      }
  }

  // {
  //   StreamWriter<ManifoldChannel> man(ma_token,ts);
  //   man.data().map_l = Y[48];
  //   man.data().map_r = Y[49];
  // }

  // motion output
  // accelerations already at pilot's head, check [xyz]iacc in ac_genrl.mat
  // 14JAN05, output changed, anyib gave wrong values in turn, it's now an[xyz]b
  //    TODO: transform to the pilot's head
  // 23 september 2014 niet lineaire filtering ingebracht
  //TODO check correctness of comments
  {
    StreamWriter<VehicleCabMotion> vcm(vcm_token, ts);
    vcm.data().xdotdot = 0.0; // not an output, but also not used in current motion filter
    vcm.data().ydotdot = 0.0; // not an output, but also not used in current motion filter
    vcm.data().zdotdot = 0.0; // not an output, but also not used in current motion filter
    vcm.data().fx      = fade_in*2*atan(Y[Y_fxcg]/2); // input to the motion filter
    vcm.data().fy      = fade_in*2*atan(Y[Y_fycg]/2); // input to the motion filter
    vcm.data().fz      = ((fade_in*2*atan((Y[Y_fzcg]+9.8066)/2) )-9.8066); // input to the motion filter
    vcm.data().xdot    = 0.0; // not an output, but also not used in current motion filter
    vcm.data().ydot    = 0.0; // not an output, but also not used in current motion filter
    vcm.data().zdot    = 0.0; // not an output, but also not used in current motion filter
    vcm.data().pdot    = fade_in*0.5*atan(Y[Y_pdot]/0.5); // input to the motion filter
    vcm.data().qdot    = fade_in*0.5*atan(Y[Y_qdot]/0.5); // input to the motion filter
    vcm.data().rdot    = fade_in*0.5*atan(Y[Y_rdot]/0.5); // input to the motion filter
    vcm.data().p       = fade_in* 0.25*atan(Y[Y_p]/0.25); // not used in current motion filter
    vcm.data().q       = fade_in* 0.25*atan(Y[Y_q]/0.25); // not used in current motion filter
    vcm.data().r       = fade_in* 0.25*atan(Y[Y_r]/0.25); // not used in current motion filter
  }


  // goto HoldCurrent below a certain speed
  // there is no zero speed model !  // there is now (kind of)
  /*
  if(getCurrentState() == SimulationState::Advance && Y[Y_vtas] < 20.0) {
    hold_request.sendEvent(new SimStateRequest(SimulationState::HoldCurrent), ts);
  }
  */

  //  if (snapshotNow()) {
  if (sr_token.getNumWaitingEvents(ts)) {
    try {
      EventReader<SnapshotRequest> sr(sr_token, ts);
      // don't care what's in it
    }
    catch (Exception& e) {
      W_MOD(classname << " caught " << e);
    }

    // make a snapshot
    Snapshot* snap = new Snapshot(NCSTATES*sizeof(double),
				  NameSet(getEntity(), "citation-inco-selector", ""));

    // make an amorphstore object to access the data in the snapshot
    AmorphStore s(snap->accessData(), snap->getDataSize());

    // get the current state and store it
    real_T *X = reinterpret_cast<real_T*>(rtmGetContStates(S));
    for (int ii = 0; ii < NCSTATES; ii++) packData(s, X[ii]);

    // send it out
    snap_token.sendEvent(snap, SimTime::now()); // DUECA deletes snap
    D_MOD( "Snapshot verzonden; NCStates= "<< NCSTATES << endl);
  }
}

/* WARNING                       WARNING               WARNING */
/* trim calculation stuff has not been verified. */

void PA34_model::trimCalculation(const TimeSpec& ts, const TrimMode& mode)
{
  // Access the input of the trim model
  // Commented out to avoid compiler warnings [OS]
  //real_T *U = reinterpret_cast<real_T*>(rtmGetU(i_S));

  // read the event equivalent of the input data
  // example
  // EventReader u(i_input_token, ts);

  // using the input, and the data put into your trim variables,
  // calculate the derivative of the state. DO NOT use the state
  // vector of the normal simulation here, because it might be that
  // this is done while the simulation runs!
  // Some elements in this state derivative are needed as target, copy
  // these out again into trim variables (see you TrimTable

  // trim calculation
  switch(mode) {
  case FlightPath: {
    // one type of trim calculation, find a power setting and attitude
    // belonging to a flight path angle and speed
  }
  break;

  case Speed: {
    // find a flightpath belonging to a speed and power setting (also
    // nice for gliders)
  }
  break;

  case Ground: {
    // find an altitude/attitude belonging to standing still on the
    // ground, power/speed 0
  }
  break;

  default:
    W_MOD(getId() << " cannot calculate inco mode " << mode);
  break;
  }
  rtmiDerivatives(rtmGetRTWRTModelMethodsInfo(i_S));

  // This works just like a normal calculation, only you provide the
  // steady state value (if your system is stable anyhow). So, if you
  // have other modules normally depending on your output, you should
  // also produce the equivalent output here.
  // EventWriter<MyOutput> y(output_token, ts);

  // write the output into the output channel, using the EventWriter
  // N.B. you may also use:
  // output_token.sendEvent(ts, new MyOutput(arguments));
  // this is slightly more efficient. However, the EventWriter makes
  // it easier, because the code will look much more like your normal
  // calculation code.

  // now return. The real results from the trim calculation, as you
  // specified them in the TrimTable, will now be collected and sent
  // off for processing.
}

// Make a TypeCreator object for this module, the TypeCreator
// will check in with the scheme-interpreting code, and enable the
// creation of modules of this type
static TypeCreator<PA34_model> a(PA34_model::getMyParameterTable());
