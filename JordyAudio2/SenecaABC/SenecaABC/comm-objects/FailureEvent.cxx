/* ------------------------------------------------------------------ */
/*      item            : FailureEvent.cxx
        generated by    : matteo (matteo)
        date            : Thu 24 Mar 2022
        category        : body file
        description     : DUECA Communication Object (DCO),
                          automatically generated by dueca-codegen
        codegen version : 110
        language        : C++
*/

#include "FailureEvent.hxx"
#include <iostream>
#include <cassert>
#if !defined(__DCO_NOPACK)
#include <AmorphStore.hxx>
#include <PackUnpackTemplates.hxx>
#endif
#include <DataWriterArraySize.hxx>
#define DOBS(A)
#if !defined(__DCO_STANDALONE)
#include <Arena.hxx>
#include <ArenaPool.hxx>
#include <DataClassRegistrar.hxx>
#include <CommObjectMemberAccess.hxx>
#include <DCOFunctor.hxx>
#include <DCOMetaFunctor.hxx>

#define DO_INSTANTIATE
#include <DataSetSubsidiary.hxx>
#endif




#if !defined(__DCO_STANDALONE)
// static CommObjectMemberAccess objects, that can provide flexible access
// to the members of a FailureEvent object
static ::dueca::CommObjectMemberAccess
  <FailureEvent,bool >
  FailureEvent_member_GPS_failure(&FailureEvent::GPS_failure, "GPS_failure");
static ::dueca::CommObjectMemberAccess
  <FailureEvent,bool >
  FailureEvent_member_VOR_failure(&FailureEvent::VOR_failure, "VOR_failure");
static ::dueca::CommObjectMemberAccess
  <FailureEvent,bool >
  FailureEvent_member_ADC_failure(&FailureEvent::ADC_failure, "ADC_failure");
static ::dueca::CommObjectMemberAccess
  <FailureEvent,bool >
  FailureEvent_member_PFD_failure(&FailureEvent::PFD_failure, "PFD_failure");
static ::dueca::CommObjectMemberAccess
  <FailureEvent,bool >
  FailureEvent_member_GMU_failure(&FailureEvent::GMU_failure, "GMU_failure");
static ::dueca::CommObjectMemberAccess
  <FailureEvent,bool >
  FailureEvent_member_HSI_failure(&FailureEvent::HSI_failure, "HSI_failure");
static ::dueca::CommObjectMemberAccess
  <FailureEvent,bool >
  FailureEvent_member_AFCS_pit(&FailureEvent::AFCS_pit, "AFCS_pit");
static ::dueca::CommObjectMemberAccess
  <FailureEvent,bool >
  FailureEvent_member_AFCS_rol(&FailureEvent::AFCS_rol, "AFCS_rol");
static ::dueca::CommObjectMemberAccess
  <FailureEvent,bool >
  FailureEvent_member_clogged_sp(&FailureEvent::clogged_sp, "clogged_sp");
static ::dueca::CommObjectMemberAccess
  <FailureEvent,bool >
  FailureEvent_member_clogged_pt(&FailureEvent::clogged_pt, "clogged_pt");

// assemble the above entries into a table in the order in which they
// appear in the FailureEvent object
static const ::dueca::CommObjectDataTable entriestable[] = {
  { &FailureEvent_member_GPS_failure },
  { &FailureEvent_member_VOR_failure },
  { &FailureEvent_member_ADC_failure },
  { &FailureEvent_member_PFD_failure },
  { &FailureEvent_member_GMU_failure },
  { &FailureEvent_member_HSI_failure },
  { &FailureEvent_member_AFCS_pit },
  { &FailureEvent_member_AFCS_rol },
  { &FailureEvent_member_clogged_sp },
  { &FailureEvent_member_clogged_pt },
  { NULL }
};

#endif

// class name, static
const char * const FailureEvent::classname = "FailureEvent";

// magic number, hashed from class name and member names / classes
const uint32_t FailureEvent::magic_check_number=0xae0848bf;

#if !defined(__DCO_STANDALONE)
// functor table, provides access to user-defined metafunctions through the
// data class registry
static dueca::functortable_type functortable;

// register this class, provides access to a packing/unpacking object,
// and to the member access tables
static ::dueca::DataClassRegistrar registrar
  (FailureEvent::classname, NULL,
   entriestable, &functortable,
   new ::dueca::DataSetSubsidiary<FailureEvent>());

#endif

#ifndef __CUSTOM_DEFAULT_CONSTRUCTOR
FailureEvent::FailureEvent():
    GPS_failure(false),
    VOR_failure(false),
    ADC_failure(false),
    PFD_failure(false),
    GMU_failure(false),
    HSI_failure(false),
    AFCS_pit(false),
    AFCS_rol(false),
    clogged_sp(false),
    clogged_pt(false)
{
  DOBS("default constructor FailureEvent");
}
#endif

#ifndef __CUSTOM_FULL_CONSTRUCTOR
FailureEvent::FailureEvent(
        const bool& GPS_failure,
        const bool& VOR_failure,
        const bool& ADC_failure,
        const bool& PFD_failure,
        const bool& GMU_failure,
        const bool& HSI_failure,
        const bool& AFCS_pit,
        const bool& AFCS_rol,
        const bool& clogged_sp,
        const bool& clogged_pt) :
    GPS_failure(GPS_failure),
    VOR_failure(VOR_failure),
    ADC_failure(ADC_failure),
    PFD_failure(PFD_failure),
    GMU_failure(GMU_failure),
    HSI_failure(HSI_failure),
    AFCS_pit(AFCS_pit),
    AFCS_rol(AFCS_rol),
    clogged_sp(clogged_sp),
    clogged_pt(clogged_pt)
{
  DOBS("complete constructor FailureEvent");
}
#endif

#ifndef __CUSTOM_FULLSINGLES_CONSTRUCTOR
#endif

#ifndef __CUSTOM_COPY_CONSTRUCTOR
FailureEvent::FailureEvent(const FailureEvent& other):
    GPS_failure(other.GPS_failure),
    VOR_failure(other.VOR_failure),
    ADC_failure(other.ADC_failure),
    PFD_failure(other.PFD_failure),
    GMU_failure(other.GMU_failure),
    HSI_failure(other.HSI_failure),
    AFCS_pit(other.AFCS_pit),
    AFCS_rol(other.AFCS_rol),
    clogged_sp(other.clogged_sp),
    clogged_pt(other.clogged_pt)
{
  DOBS("copy constructor FailureEvent");
}
#endif

#if !defined(__CUSTOM_AMORPHRESTORE_CONSTRUCTOR) && !defined(__DCO_NOPACK)
FailureEvent::FailureEvent(dueca::AmorphReStore& s):
        GPS_failure(s),
        VOR_failure(s),
        ADC_failure(s),
        PFD_failure(s),
        GMU_failure(s),
        HSI_failure(s),
        AFCS_pit(s),
        AFCS_rol(s),
        clogged_sp(s),
        clogged_pt(s)
{
  DOBS("amorph constructor FailureEvent");
}
#endif

#if !defined(__CUSTOM_ARRAY_SIZE_INIT_CONSTRUCTOR)
#endif

#ifndef __CUSTOM_DESTRUCTOR
FailureEvent::~FailureEvent()
{
  DOBS("destructor FailureEvent");
}
#endif

#if !defined(__DCO_STANDALONE)
void* FailureEvent::operator new(size_t size)
{
  DOBS("operator new FailureEvent");
  static ::dueca::Arena* my_arena = arena_pool.findArena
    (sizeof(FailureEvent));
  return my_arena->alloc(size);
}

void FailureEvent::operator delete(void* v)
{
  DOBS("operator delete FailureEvent");
  static ::dueca::Arena* my_arena = arena_pool.findArena
    (sizeof(FailureEvent));
  my_arena->free(v);
}
#endif

#if !defined(__CUSTOM_FUNCTION_PACKDATADIFF) && !defined(__DCO_NOPACK)
void FailureEvent::packDataDiff(::dueca::AmorphStore& s, const FailureEvent& ref) const
{
  DOBS("packDataDiff FailureEvent");
  ::dueca::IndexMemory im;
  ::dueca::checkandpackdiffsingle(this->GPS_failure, ref.GPS_failure,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->VOR_failure, ref.VOR_failure,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->ADC_failure, ref.ADC_failure,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->PFD_failure, ref.PFD_failure,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->GMU_failure, ref.GMU_failure,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->HSI_failure, ref.HSI_failure,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->AFCS_pit, ref.AFCS_pit,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->AFCS_rol, ref.AFCS_rol,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->clogged_sp, ref.clogged_sp,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->clogged_pt, ref.clogged_pt,
                         s, im);
  im.closeoff(s);
}
#endif

#if !defined(__CUSTOM_FUNCTION_UNPACKDATA) && !defined(__DCO_NOPACK)
void FailureEvent::unPackData(::dueca::AmorphReStore& s)
{
  DOBS("unPackData FailureEvent");

  ::unPackData(s, this->GPS_failure);
  ::unPackData(s, this->VOR_failure);
  ::unPackData(s, this->ADC_failure);
  ::unPackData(s, this->PFD_failure);
  ::unPackData(s, this->GMU_failure);
  ::unPackData(s, this->HSI_failure);
  ::unPackData(s, this->AFCS_pit);
  ::unPackData(s, this->AFCS_rol);
  ::unPackData(s, this->clogged_sp);
  ::unPackData(s, this->clogged_pt);

}
#endif

#if !defined(__CUSTOM_FUNCTION_UNPACKDATADIFF) && !defined(__DCO_NOPACK)
void FailureEvent::unPackDataDiff(dueca::AmorphReStore& s)
{
  DOBS("unPackDataDiff FailureEvent");
  ::dueca::IndexRecall im;
  ::dueca::checkandunpackdiffsingle(this->GPS_failure, s, im);
  ::dueca::checkandunpackdiffsingle(this->VOR_failure, s, im);
  ::dueca::checkandunpackdiffsingle(this->ADC_failure, s, im);
  ::dueca::checkandunpackdiffsingle(this->PFD_failure, s, im);
  ::dueca::checkandunpackdiffsingle(this->GMU_failure, s, im);
  ::dueca::checkandunpackdiffsingle(this->HSI_failure, s, im);
  ::dueca::checkandunpackdiffsingle(this->AFCS_pit, s, im);
  ::dueca::checkandunpackdiffsingle(this->AFCS_rol, s, im);
  ::dueca::checkandunpackdiffsingle(this->clogged_sp, s, im);
  ::dueca::checkandunpackdiffsingle(this->clogged_pt, s, im);
}
#endif

#ifndef __CUSTOM_OPERATOR_EQUAL
bool FailureEvent::operator == (const FailureEvent& other) const
{
  DOBS("operator == FailureEvent");
  if (this->GPS_failure != other.GPS_failure) return false;
  if (this->VOR_failure != other.VOR_failure) return false;
  if (this->ADC_failure != other.ADC_failure) return false;
  if (this->PFD_failure != other.PFD_failure) return false;
  if (this->GMU_failure != other.GMU_failure) return false;
  if (this->HSI_failure != other.HSI_failure) return false;
  if (this->AFCS_pit != other.AFCS_pit) return false;
  if (this->AFCS_rol != other.AFCS_rol) return false;
  if (this->clogged_sp != other.clogged_sp) return false;
  if (this->clogged_pt != other.clogged_pt) return false;
  return true;
}
#endif

#ifndef __CUSTOM_OPERATOR_ASSIGN
FailureEvent&
FailureEvent::operator=(const FailureEvent& other)
{
  DOBS("operator = FailureEvent");
  if (this == &other) return *this;
  this->GPS_failure = other.GPS_failure;
  this->VOR_failure = other.VOR_failure;
  this->ADC_failure = other.ADC_failure;
  this->PFD_failure = other.PFD_failure;
  this->GMU_failure = other.GMU_failure;
  this->HSI_failure = other.HSI_failure;
  this->AFCS_pit = other.AFCS_pit;
  this->AFCS_rol = other.AFCS_rol;
  this->clogged_sp = other.clogged_sp;
  this->clogged_pt = other.clogged_pt;
  return *this;
}
#endif

#if !defined(__CUSTOM_FUNCTION_PACKDATA) && !defined(__DCO_NOPACK)
void FailureEvent::packData(::dueca::AmorphStore& s) const
{
  DOBS("packData FailureEvent");
  ::packData(s, this->GPS_failure);
  ::packData(s, this->VOR_failure);
  ::packData(s, this->ADC_failure);
  ::packData(s, this->PFD_failure);
  ::packData(s, this->GMU_failure);
  ::packData(s, this->HSI_failure);
  ::packData(s, this->AFCS_pit);
  ::packData(s, this->AFCS_rol);
  ::packData(s, this->clogged_sp);
  ::packData(s, this->clogged_pt);
}
#endif

#ifndef __CUSTOM_FUNCTION_PRINT
std::ostream & FailureEvent::print(std::ostream& s) const
{
  s << "FailureEvent("
    << "GPS_failure=" << this->GPS_failure << ','
    << "VOR_failure=" << this->VOR_failure << ','
    << "ADC_failure=" << this->ADC_failure << ','
    << "PFD_failure=" << this->PFD_failure << ','
    << "GMU_failure=" << this->GMU_failure << ','
    << "HSI_failure=" << this->HSI_failure << ','
    << "AFCS_pit=" << this->AFCS_pit << ','
    << "AFCS_rol=" << this->AFCS_rol << ','
    << "clogged_sp=" << this->clogged_sp << ','
    << "clogged_pt=" << this->clogged_pt
    << ')';
  return s;
}
#endif


