/* ------------------------------------------------------------------ */
/*      item            : MassEvent.cxx
        generated by    : matteo (matteo)
        date            : Thu 24 Mar 2022
        category        : body file
        description     : DUECA Communication Object (DCO),
                          automatically generated by dueca-codegen
        codegen version : 110
        language        : C++
*/

#include "MassEvent.hxx"
#include <iostream>
#include <cassert>
#if !defined(__DCO_NOPACK)
#include <AmorphStore.hxx>
#include <PackUnpackTemplates.hxx>
#endif
#include <DataWriterArraySize.hxx>
#define DOBS(A)
#if !defined(__DCO_STANDALONE)
#include <Arena.hxx>
#include <ArenaPool.hxx>
#include <DataClassRegistrar.hxx>
#include <CommObjectMemberAccess.hxx>
#include <DCOFunctor.hxx>
#include <DCOMetaFunctor.hxx>

#define DO_INSTANTIATE
#include <DataSetSubsidiary.hxx>
#endif




#if !defined(__DCO_STANDALONE)
// static CommObjectMemberAccess objects, that can provide flexible access
// to the members of a MassEvent object
static ::dueca::CommObjectMemberAccess
  <MassEvent,int >
  MassEvent_member_id(&MassEvent::id, "id");
static ::dueca::CommObjectMemberAccess
  <MassEvent,float >
  MassEvent_member_x(&MassEvent::x, "x");
static ::dueca::CommObjectMemberAccess
  <MassEvent,float >
  MassEvent_member_y(&MassEvent::y, "y");
static ::dueca::CommObjectMemberAccess
  <MassEvent,float >
  MassEvent_member_z(&MassEvent::z, "z");
static ::dueca::CommObjectMemberAccess
  <MassEvent,float >
  MassEvent_member_mass(&MassEvent::mass, "mass");
static ::dueca::CommObjectMemberAccess
  <MassEvent,float >
  MassEvent_member_time(&MassEvent::time, "time");

// assemble the above entries into a table in the order in which they
// appear in the MassEvent object
static const ::dueca::CommObjectDataTable entriestable[] = {
  { &MassEvent_member_id },
  { &MassEvent_member_x },
  { &MassEvent_member_y },
  { &MassEvent_member_z },
  { &MassEvent_member_mass },
  { &MassEvent_member_time },
  { NULL }
};

#endif

// class name, static
const char * const MassEvent::classname = "MassEvent";

// magic number, hashed from class name and member names / classes
const uint32_t MassEvent::magic_check_number=0x2304c65f;

#if !defined(__DCO_STANDALONE)
// functor table, provides access to user-defined metafunctions through the
// data class registry
static dueca::functortable_type functortable;

// register this class, provides access to a packing/unpacking object,
// and to the member access tables
static ::dueca::DataClassRegistrar registrar
  (MassEvent::classname, NULL,
   entriestable, &functortable,
   new ::dueca::DataSetSubsidiary<MassEvent>());

#endif

#ifndef __CUSTOM_DEFAULT_CONSTRUCTOR
MassEvent::MassEvent():
    id(0),
    x(0.0f),
    y(0.0f),
    z(0.0f),
    mass(0.0f),
    time(0.0f)
{
  DOBS("default constructor MassEvent");
}
#endif

#ifndef __CUSTOM_FULL_CONSTRUCTOR
MassEvent::MassEvent(
        const int& id,
        const float& x,
        const float& y,
        const float& z,
        const float& mass,
        const float& time) :
    id(id),
    x(x),
    y(y),
    z(z),
    mass(mass),
    time(time)
{
  DOBS("complete constructor MassEvent");
}
#endif

#ifndef __CUSTOM_FULLSINGLES_CONSTRUCTOR
#endif

#ifndef __CUSTOM_COPY_CONSTRUCTOR
MassEvent::MassEvent(const MassEvent& other):
    id(other.id),
    x(other.x),
    y(other.y),
    z(other.z),
    mass(other.mass),
    time(other.time)
{
  DOBS("copy constructor MassEvent");
}
#endif

#if !defined(__CUSTOM_AMORPHRESTORE_CONSTRUCTOR) && !defined(__DCO_NOPACK)
MassEvent::MassEvent(dueca::AmorphReStore& s):
        id(s),
        x(s),
        y(s),
        z(s),
        mass(s),
        time(s)
{
  DOBS("amorph constructor MassEvent");
}
#endif

#if !defined(__CUSTOM_ARRAY_SIZE_INIT_CONSTRUCTOR)
#endif

#ifndef __CUSTOM_DESTRUCTOR
MassEvent::~MassEvent()
{
  DOBS("destructor MassEvent");
}
#endif

#if !defined(__DCO_STANDALONE)
void* MassEvent::operator new(size_t size)
{
  DOBS("operator new MassEvent");
  static ::dueca::Arena* my_arena = arena_pool.findArena
    (sizeof(MassEvent));
  return my_arena->alloc(size);
}

void MassEvent::operator delete(void* v)
{
  DOBS("operator delete MassEvent");
  static ::dueca::Arena* my_arena = arena_pool.findArena
    (sizeof(MassEvent));
  my_arena->free(v);
}
#endif

#if !defined(__CUSTOM_FUNCTION_PACKDATADIFF) && !defined(__DCO_NOPACK)
void MassEvent::packDataDiff(::dueca::AmorphStore& s, const MassEvent& ref) const
{
  DOBS("packDataDiff MassEvent");
  ::dueca::IndexMemory im;
  ::dueca::checkandpackdiffsingle(this->id, ref.id,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->x, ref.x,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->y, ref.y,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->z, ref.z,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->mass, ref.mass,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->time, ref.time,
                         s, im);
  im.closeoff(s);
}
#endif

#if !defined(__CUSTOM_FUNCTION_UNPACKDATA) && !defined(__DCO_NOPACK)
void MassEvent::unPackData(::dueca::AmorphReStore& s)
{
  DOBS("unPackData MassEvent");

  ::unPackData(s, this->id);
  ::unPackData(s, this->x);
  ::unPackData(s, this->y);
  ::unPackData(s, this->z);
  ::unPackData(s, this->mass);
  ::unPackData(s, this->time);

}
#endif

#if !defined(__CUSTOM_FUNCTION_UNPACKDATADIFF) && !defined(__DCO_NOPACK)
void MassEvent::unPackDataDiff(dueca::AmorphReStore& s)
{
  DOBS("unPackDataDiff MassEvent");
  ::dueca::IndexRecall im;
  ::dueca::checkandunpackdiffsingle(this->id, s, im);
  ::dueca::checkandunpackdiffsingle(this->x, s, im);
  ::dueca::checkandunpackdiffsingle(this->y, s, im);
  ::dueca::checkandunpackdiffsingle(this->z, s, im);
  ::dueca::checkandunpackdiffsingle(this->mass, s, im);
  ::dueca::checkandunpackdiffsingle(this->time, s, im);
}
#endif

#ifndef __CUSTOM_OPERATOR_EQUAL
bool MassEvent::operator == (const MassEvent& other) const
{
  DOBS("operator == MassEvent");
  if (this->id != other.id) return false;
  if (this->x != other.x) return false;
  if (this->y != other.y) return false;
  if (this->z != other.z) return false;
  if (this->mass != other.mass) return false;
  if (this->time != other.time) return false;
  return true;
}
#endif

#ifndef __CUSTOM_OPERATOR_ASSIGN
MassEvent&
MassEvent::operator=(const MassEvent& other)
{
  DOBS("operator = MassEvent");
  if (this == &other) return *this;
  this->id = other.id;
  this->x = other.x;
  this->y = other.y;
  this->z = other.z;
  this->mass = other.mass;
  this->time = other.time;
  return *this;
}
#endif

#if !defined(__CUSTOM_FUNCTION_PACKDATA) && !defined(__DCO_NOPACK)
void MassEvent::packData(::dueca::AmorphStore& s) const
{
  DOBS("packData MassEvent");
  ::packData(s, this->id);
  ::packData(s, this->x);
  ::packData(s, this->y);
  ::packData(s, this->z);
  ::packData(s, this->mass);
  ::packData(s, this->time);
}
#endif

#ifndef __CUSTOM_FUNCTION_PRINT
std::ostream & MassEvent::print(std::ostream& s) const
{
  s << "MassEvent("
    << "id=" << this->id << ','
    << "x=" << this->x << ','
    << "y=" << this->y << ','
    << "z=" << this->z << ','
    << "mass=" << this->mass << ','
    << "time=" << this->time
    << ')';
  return s;
}
#endif


