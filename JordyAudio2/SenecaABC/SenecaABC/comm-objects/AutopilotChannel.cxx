/* ------------------------------------------------------------------ */
/*      item            : AutopilotChannel.cxx
        generated by    : matteo (matteo)
        date            : Thu 24 Mar 2022
        category        : body file
        description     : DUECA Communication Object (DCO),
                          automatically generated by dueca-codegen
        codegen version : 110
        language        : C++
*/

#include "AutopilotChannel.hxx"
#include <iostream>
#include <cassert>
#if !defined(__DCO_NOPACK)
#include <AmorphStore.hxx>
#include <PackUnpackTemplates.hxx>
#endif
#include <DataWriterArraySize.hxx>
#define DOBS(A)
#if !defined(__DCO_STANDALONE)
#include <Arena.hxx>
#include <ArenaPool.hxx>
#include <DataClassRegistrar.hxx>
#include <CommObjectMemberAccess.hxx>
#include <DCOFunctor.hxx>
#include <DCOMetaFunctor.hxx>

#define DO_INSTANTIATE
#include <DataSetSubsidiary.hxx>
#endif




#if !defined(__DCO_STANDALONE)
// static CommObjectMemberAccess objects, that can provide flexible access
// to the members of a AutopilotChannel object
static ::dueca::CommObjectMemberAccess
  <AutopilotChannel,int >
  AutopilotChannel_member_APstate(&AutopilotChannel::APstate, "APstate");
static ::dueca::CommObjectMemberAccess
  <AutopilotChannel,float >
  AutopilotChannel_member_de(&AutopilotChannel::de, "de");
static ::dueca::CommObjectMemberAccess
  <AutopilotChannel,float >
  AutopilotChannel_member_da(&AutopilotChannel::da, "da");
static ::dueca::CommObjectMemberAccess
  <AutopilotChannel,float >
  AutopilotChannel_member_dr(&AutopilotChannel::dr, "dr");
static ::dueca::CommObjectMemberAccess
  <AutopilotChannel,float >
  AutopilotChannel_member_theta_ref(&AutopilotChannel::theta_ref, "theta_ref");
static ::dueca::CommObjectMemberAccess
  <AutopilotChannel,float >
  AutopilotChannel_member_phi_ref(&AutopilotChannel::phi_ref, "phi_ref");
static ::dueca::CommObjectMemberAccess
  <AutopilotChannel,float >
  AutopilotChannel_member_needle_deviation(&AutopilotChannel::needle_deviation, "needle_deviation");
static ::dueca::CommObjectMemberAccess
  <AutopilotChannel,float >
  AutopilotChannel_member_dme(&AutopilotChannel::dme, "dme");
static ::dueca::CommObjectMemberAccess
  <AutopilotChannel,float >
  AutopilotChannel_member_brg(&AutopilotChannel::brg, "brg");
static ::dueca::CommObjectMemberAccess
  <AutopilotChannel,float >
  AutopilotChannel_member_course(&AutopilotChannel::course, "course");
static ::dueca::CommObjectMemberAccess
  <AutopilotChannel,float >
  AutopilotChannel_member_dtk(&AutopilotChannel::dtk, "dtk");
static ::dueca::CommObjectMemberAccess
  <AutopilotChannel,float >
  AutopilotChannel_member_nav_R(&AutopilotChannel::nav_R, "nav_R");
static ::dueca::CommObjectMemberAccess
  <AutopilotChannel,float >
  AutopilotChannel_member_vnav_R(&AutopilotChannel::vnav_R, "vnav_R");
static ::dueca::CommObjectMemberAccess
  <AutopilotChannel,float >
  AutopilotChannel_member_dist_to_top(&AutopilotChannel::dist_to_top, "dist_to_top");
static ::dueca::CommObjectMemberAccess
  <AutopilotChannel,float >
  AutopilotChannel_member_time_to_bod(&AutopilotChannel::time_to_bod, "time_to_bod");
static ::dueca::CommObjectMemberAccess
  <AutopilotChannel,float >
  AutopilotChannel_member_turn_rate(&AutopilotChannel::turn_rate, "turn_rate");
static ::dueca::CommObjectMemberAccess
  <AutopilotChannel,float >
  AutopilotChannel_member_fpa_req(&AutopilotChannel::fpa_req, "fpa_req");

// assemble the above entries into a table in the order in which they
// appear in the AutopilotChannel object
static const ::dueca::CommObjectDataTable entriestable[] = {
  { &AutopilotChannel_member_APstate },
  { &AutopilotChannel_member_de },
  { &AutopilotChannel_member_da },
  { &AutopilotChannel_member_dr },
  { &AutopilotChannel_member_theta_ref },
  { &AutopilotChannel_member_phi_ref },
  { &AutopilotChannel_member_needle_deviation },
  { &AutopilotChannel_member_dme },
  { &AutopilotChannel_member_brg },
  { &AutopilotChannel_member_course },
  { &AutopilotChannel_member_dtk },
  { &AutopilotChannel_member_nav_R },
  { &AutopilotChannel_member_vnav_R },
  { &AutopilotChannel_member_dist_to_top },
  { &AutopilotChannel_member_time_to_bod },
  { &AutopilotChannel_member_turn_rate },
  { &AutopilotChannel_member_fpa_req },
  { NULL }
};

#endif

// class name, static
const char * const AutopilotChannel::classname = "AutopilotChannel";

// magic number, hashed from class name and member names / classes
const uint32_t AutopilotChannel::magic_check_number=0xea382d14;

#if !defined(__DCO_STANDALONE)
// functor table, provides access to user-defined metafunctions through the
// data class registry
static dueca::functortable_type functortable;

// register this class, provides access to a packing/unpacking object,
// and to the member access tables
static ::dueca::DataClassRegistrar registrar
  (AutopilotChannel::classname, NULL,
   entriestable, &functortable,
   new ::dueca::DataSetSubsidiary<AutopilotChannel>());

#endif

#ifndef __CUSTOM_DEFAULT_CONSTRUCTOR
AutopilotChannel::AutopilotChannel()
{
  DOBS("default constructor AutopilotChannel");
}
#endif

#ifndef __CUSTOM_FULL_CONSTRUCTOR
AutopilotChannel::AutopilotChannel(
        const int& APstate,
        const float& de,
        const float& da,
        const float& dr,
        const float& theta_ref,
        const float& phi_ref,
        const float& needle_deviation,
        const float& dme,
        const float& brg,
        const float& course,
        const float& dtk,
        const float& nav_R,
        const float& vnav_R,
        const float& dist_to_top,
        const float& time_to_bod,
        const float& turn_rate,
        const float& fpa_req) :
    APstate(APstate),
    de(de),
    da(da),
    dr(dr),
    theta_ref(theta_ref),
    phi_ref(phi_ref),
    needle_deviation(needle_deviation),
    dme(dme),
    brg(brg),
    course(course),
    dtk(dtk),
    nav_R(nav_R),
    vnav_R(vnav_R),
    dist_to_top(dist_to_top),
    time_to_bod(time_to_bod),
    turn_rate(turn_rate),
    fpa_req(fpa_req)
{
  DOBS("complete constructor AutopilotChannel");
}
#endif

#ifndef __CUSTOM_FULLSINGLES_CONSTRUCTOR
#endif

#ifndef __CUSTOM_COPY_CONSTRUCTOR
AutopilotChannel::AutopilotChannel(const AutopilotChannel& other):
    APstate(other.APstate),
    de(other.de),
    da(other.da),
    dr(other.dr),
    theta_ref(other.theta_ref),
    phi_ref(other.phi_ref),
    needle_deviation(other.needle_deviation),
    dme(other.dme),
    brg(other.brg),
    course(other.course),
    dtk(other.dtk),
    nav_R(other.nav_R),
    vnav_R(other.vnav_R),
    dist_to_top(other.dist_to_top),
    time_to_bod(other.time_to_bod),
    turn_rate(other.turn_rate),
    fpa_req(other.fpa_req)
{
  DOBS("copy constructor AutopilotChannel");
}
#endif

#if !defined(__CUSTOM_AMORPHRESTORE_CONSTRUCTOR) && !defined(__DCO_NOPACK)
AutopilotChannel::AutopilotChannel(dueca::AmorphReStore& s):
        APstate(s),
        de(s),
        da(s),
        dr(s),
        theta_ref(s),
        phi_ref(s),
        needle_deviation(s),
        dme(s),
        brg(s),
        course(s),
        dtk(s),
        nav_R(s),
        vnav_R(s),
        dist_to_top(s),
        time_to_bod(s),
        turn_rate(s),
        fpa_req(s)
{
  DOBS("amorph constructor AutopilotChannel");
}
#endif

#if !defined(__CUSTOM_ARRAY_SIZE_INIT_CONSTRUCTOR)
#endif

#ifndef __CUSTOM_DESTRUCTOR
AutopilotChannel::~AutopilotChannel()
{
  DOBS("destructor AutopilotChannel");
}
#endif

#if !defined(__DCO_STANDALONE)
void* AutopilotChannel::operator new(size_t size)
{
  DOBS("operator new AutopilotChannel");
  static ::dueca::Arena* my_arena = arena_pool.findArena
    (sizeof(AutopilotChannel));
  return my_arena->alloc(size);
}

void AutopilotChannel::operator delete(void* v)
{
  DOBS("operator delete AutopilotChannel");
  static ::dueca::Arena* my_arena = arena_pool.findArena
    (sizeof(AutopilotChannel));
  my_arena->free(v);
}
#endif

#if !defined(__CUSTOM_FUNCTION_PACKDATADIFF) && !defined(__DCO_NOPACK)
void AutopilotChannel::packDataDiff(::dueca::AmorphStore& s, const AutopilotChannel& ref) const
{
  DOBS("packDataDiff AutopilotChannel");
  ::dueca::IndexMemory im;
  ::dueca::checkandpackdiffsingle(this->APstate, ref.APstate,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->de, ref.de,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->da, ref.da,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->dr, ref.dr,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->theta_ref, ref.theta_ref,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->phi_ref, ref.phi_ref,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->needle_deviation, ref.needle_deviation,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->dme, ref.dme,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->brg, ref.brg,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->course, ref.course,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->dtk, ref.dtk,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->nav_R, ref.nav_R,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->vnav_R, ref.vnav_R,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->dist_to_top, ref.dist_to_top,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->time_to_bod, ref.time_to_bod,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->turn_rate, ref.turn_rate,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->fpa_req, ref.fpa_req,
                         s, im);
  im.closeoff(s);
}
#endif

#if !defined(__CUSTOM_FUNCTION_UNPACKDATA) && !defined(__DCO_NOPACK)
void AutopilotChannel::unPackData(::dueca::AmorphReStore& s)
{
  DOBS("unPackData AutopilotChannel");

  ::unPackData(s, this->APstate);
  ::unPackData(s, this->de);
  ::unPackData(s, this->da);
  ::unPackData(s, this->dr);
  ::unPackData(s, this->theta_ref);
  ::unPackData(s, this->phi_ref);
  ::unPackData(s, this->needle_deviation);
  ::unPackData(s, this->dme);
  ::unPackData(s, this->brg);
  ::unPackData(s, this->course);
  ::unPackData(s, this->dtk);
  ::unPackData(s, this->nav_R);
  ::unPackData(s, this->vnav_R);
  ::unPackData(s, this->dist_to_top);
  ::unPackData(s, this->time_to_bod);
  ::unPackData(s, this->turn_rate);
  ::unPackData(s, this->fpa_req);

}
#endif

#if !defined(__CUSTOM_FUNCTION_UNPACKDATADIFF) && !defined(__DCO_NOPACK)
void AutopilotChannel::unPackDataDiff(dueca::AmorphReStore& s)
{
  DOBS("unPackDataDiff AutopilotChannel");
  ::dueca::IndexRecall im;
  ::dueca::checkandunpackdiffsingle(this->APstate, s, im);
  ::dueca::checkandunpackdiffsingle(this->de, s, im);
  ::dueca::checkandunpackdiffsingle(this->da, s, im);
  ::dueca::checkandunpackdiffsingle(this->dr, s, im);
  ::dueca::checkandunpackdiffsingle(this->theta_ref, s, im);
  ::dueca::checkandunpackdiffsingle(this->phi_ref, s, im);
  ::dueca::checkandunpackdiffsingle(this->needle_deviation, s, im);
  ::dueca::checkandunpackdiffsingle(this->dme, s, im);
  ::dueca::checkandunpackdiffsingle(this->brg, s, im);
  ::dueca::checkandunpackdiffsingle(this->course, s, im);
  ::dueca::checkandunpackdiffsingle(this->dtk, s, im);
  ::dueca::checkandunpackdiffsingle(this->nav_R, s, im);
  ::dueca::checkandunpackdiffsingle(this->vnav_R, s, im);
  ::dueca::checkandunpackdiffsingle(this->dist_to_top, s, im);
  ::dueca::checkandunpackdiffsingle(this->time_to_bod, s, im);
  ::dueca::checkandunpackdiffsingle(this->turn_rate, s, im);
  ::dueca::checkandunpackdiffsingle(this->fpa_req, s, im);
}
#endif

#ifndef __CUSTOM_OPERATOR_EQUAL
bool AutopilotChannel::operator == (const AutopilotChannel& other) const
{
  DOBS("operator == AutopilotChannel");
  if (this->APstate != other.APstate) return false;
  if (this->de != other.de) return false;
  if (this->da != other.da) return false;
  if (this->dr != other.dr) return false;
  if (this->theta_ref != other.theta_ref) return false;
  if (this->phi_ref != other.phi_ref) return false;
  if (this->needle_deviation != other.needle_deviation) return false;
  if (this->dme != other.dme) return false;
  if (this->brg != other.brg) return false;
  if (this->course != other.course) return false;
  if (this->dtk != other.dtk) return false;
  if (this->nav_R != other.nav_R) return false;
  if (this->vnav_R != other.vnav_R) return false;
  if (this->dist_to_top != other.dist_to_top) return false;
  if (this->time_to_bod != other.time_to_bod) return false;
  if (this->turn_rate != other.turn_rate) return false;
  if (this->fpa_req != other.fpa_req) return false;
  return true;
}
#endif

#ifndef __CUSTOM_OPERATOR_ASSIGN
AutopilotChannel&
AutopilotChannel::operator=(const AutopilotChannel& other)
{
  DOBS("operator = AutopilotChannel");
  if (this == &other) return *this;
  this->APstate = other.APstate;
  this->de = other.de;
  this->da = other.da;
  this->dr = other.dr;
  this->theta_ref = other.theta_ref;
  this->phi_ref = other.phi_ref;
  this->needle_deviation = other.needle_deviation;
  this->dme = other.dme;
  this->brg = other.brg;
  this->course = other.course;
  this->dtk = other.dtk;
  this->nav_R = other.nav_R;
  this->vnav_R = other.vnav_R;
  this->dist_to_top = other.dist_to_top;
  this->time_to_bod = other.time_to_bod;
  this->turn_rate = other.turn_rate;
  this->fpa_req = other.fpa_req;
  return *this;
}
#endif

#if !defined(__CUSTOM_FUNCTION_PACKDATA) && !defined(__DCO_NOPACK)
void AutopilotChannel::packData(::dueca::AmorphStore& s) const
{
  DOBS("packData AutopilotChannel");
  ::packData(s, this->APstate);
  ::packData(s, this->de);
  ::packData(s, this->da);
  ::packData(s, this->dr);
  ::packData(s, this->theta_ref);
  ::packData(s, this->phi_ref);
  ::packData(s, this->needle_deviation);
  ::packData(s, this->dme);
  ::packData(s, this->brg);
  ::packData(s, this->course);
  ::packData(s, this->dtk);
  ::packData(s, this->nav_R);
  ::packData(s, this->vnav_R);
  ::packData(s, this->dist_to_top);
  ::packData(s, this->time_to_bod);
  ::packData(s, this->turn_rate);
  ::packData(s, this->fpa_req);
}
#endif

#ifndef __CUSTOM_FUNCTION_PRINT
std::ostream & AutopilotChannel::print(std::ostream& s) const
{
  s << "AutopilotChannel("
    << "APstate=" << this->APstate << ','
    << "de=" << this->de << ','
    << "da=" << this->da << ','
    << "dr=" << this->dr << ','
    << "theta_ref=" << this->theta_ref << ','
    << "phi_ref=" << this->phi_ref << ','
    << "needle_deviation=" << this->needle_deviation << ','
    << "dme=" << this->dme << ','
    << "brg=" << this->brg << ','
    << "course=" << this->course << ','
    << "dtk=" << this->dtk << ','
    << "nav_R=" << this->nav_R << ','
    << "vnav_R=" << this->vnav_R << ','
    << "dist_to_top=" << this->dist_to_top << ','
    << "time_to_bod=" << this->time_to_bod << ','
    << "turn_rate=" << this->turn_rate << ','
    << "fpa_req=" << this->fpa_req
    << ')';
  return s;
}
#endif


