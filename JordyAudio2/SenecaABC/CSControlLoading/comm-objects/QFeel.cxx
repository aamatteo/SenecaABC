/* ------------------------------------------------------------------ */
/*      item            : QFeel.cxx
        generated by    : matteo (matteo)
        date            : Thu 24 Mar 2022
        category        : body file
        description     : DUECA Communication Object (DCO),
                          automatically generated by dueca-codegen
        codegen version : 110
        language        : C++
*/

#include "QFeel.hxx"
#include <iostream>
#include <cassert>
#if !defined(__DCO_NOPACK)
#include <AmorphStore.hxx>
#include <PackUnpackTemplates.hxx>
#endif
#include <DataWriterArraySize.hxx>
#define DOBS(A)
#if !defined(__DCO_STANDALONE)
#include <Arena.hxx>
#include <ArenaPool.hxx>
#include <DataClassRegistrar.hxx>
#include <CommObjectMemberAccess.hxx>
#include <DCOFunctor.hxx>
#include <DCOMetaFunctor.hxx>

#define DO_INSTANTIATE
#include <DataSetSubsidiary.hxx>
#endif
#ifdef DUECA_CONFIG_HDF5
#include <hdf5utils/HDF5Templates.hxx>
#endif




#if !defined(__DCO_STANDALONE)
// static CommObjectMemberAccess objects, that can provide flexible access
// to the members of a QFeel object
static ::dueca::CommObjectMemberAccess
  <QFeel,dueca::fixvector<6,float> >
  QFeel_member_mom_offset(&QFeel::mom_offset, "mom_offset");
static ::dueca::CommObjectMemberAccess
  <QFeel,dueca::fixvector<6,float> >
  QFeel_member_pos_offset(&QFeel::pos_offset, "pos_offset");
static ::dueca::CommObjectMemberAccess
  <QFeel,dueca::fixvector<6,float> >
  QFeel_member_extra_spring(&QFeel::extra_spring, "extra_spring");
static ::dueca::CommObjectMemberAccess
  <QFeel,dueca::fixvector<6,float> >
  QFeel_member_extra_damping(&QFeel::extra_damping, "extra_damping");

// assemble the above entries into a table in the order in which they
// appear in the QFeel object
static const ::dueca::CommObjectDataTable entriestable[] = {
  { &QFeel_member_mom_offset },
  { &QFeel_member_pos_offset },
  { &QFeel_member_extra_spring },
  { &QFeel_member_extra_damping },
  { NULL }
};

#endif

// class name, static
const char * const QFeel::classname = "QFeel";

// magic number, hashed from class name and member names / classes
const uint32_t QFeel::magic_check_number=0x89e7e12f;

#if !defined(__DCO_STANDALONE)
// functor table, provides access to user-defined metafunctions through the
// data class registry
static dueca::functortable_type functortable;

// register this class, provides access to a packing/unpacking object,
// and to the member access tables
static ::dueca::DataClassRegistrar registrar
  (QFeel::classname, NULL,
   entriestable, &functortable,
   new ::dueca::DataSetSubsidiary<QFeel>());

#endif

#ifndef __CUSTOM_DEFAULT_CONSTRUCTOR
QFeel::QFeel()
{
  for (int ii = 6; ii--; ) {
    mom_offset[ii] = 0.0;
    pos_offset[ii] = 0.0;
    extra_spring[ii] = 0.0;
    extra_damping[ii] = 0.0;
  }
  DOBS("default constructor QFeel");
}
#endif

#ifndef __CUSTOM_FULL_CONSTRUCTOR
QFeel::QFeel(
        const dueca::fixvector<6,float>& mom_offset,
        const dueca::fixvector<6,float>& pos_offset,
        const dueca::fixvector<6,float>& extra_spring,
        const dueca::fixvector<6,float>& extra_damping) :
    mom_offset(mom_offset),
    pos_offset(pos_offset),
    extra_spring(extra_spring),
    extra_damping(extra_damping)
{
  DOBS("complete constructor QFeel");
}
#endif

#ifndef __CUSTOM_FULLSINGLES_CONSTRUCTOR
#endif

#ifndef __CUSTOM_COPY_CONSTRUCTOR
QFeel::QFeel(const QFeel& other):
    mom_offset(other.mom_offset),
    pos_offset(other.pos_offset),
    extra_spring(other.extra_spring),
    extra_damping(other.extra_damping)
{
  DOBS("copy constructor QFeel");
}
#endif

#if !defined(__CUSTOM_AMORPHRESTORE_CONSTRUCTOR) && !defined(__DCO_NOPACK)
QFeel::QFeel(dueca::AmorphReStore& s)
{
  ::dueca::unpackiterable(s, this->mom_offset,
                          dueca::pack_traits<dueca::fixvector<6,float> >()); 
  ::dueca::unpackiterable(s, this->pos_offset,
                          dueca::pack_traits<dueca::fixvector<6,float> >()); 
  ::dueca::unpackiterable(s, this->extra_spring,
                          dueca::pack_traits<dueca::fixvector<6,float> >()); 
  ::dueca::unpackiterable(s, this->extra_damping,
                          dueca::pack_traits<dueca::fixvector<6,float> >()); 
  DOBS("amorph constructor QFeel");
}
#endif

#if !defined(__CUSTOM_ARRAY_SIZE_INIT_CONSTRUCTOR)
#endif

#ifndef __CUSTOM_DESTRUCTOR
QFeel::~QFeel()
{
  DOBS("destructor QFeel");
}
#endif

#if !defined(__DCO_STANDALONE)
void* QFeel::operator new(size_t size)
{
  DOBS("operator new QFeel");
  static ::dueca::Arena* my_arena = arena_pool.findArena
    (sizeof(QFeel));
  return my_arena->alloc(size);
}

void QFeel::operator delete(void* v)
{
  DOBS("operator delete QFeel");
  static ::dueca::Arena* my_arena = arena_pool.findArena
    (sizeof(QFeel));
  my_arena->free(v);
}
#endif

#if !defined(__CUSTOM_FUNCTION_PACKDATADIFF) && !defined(__DCO_NOPACK)
void QFeel::packDataDiff(::dueca::AmorphStore& s, const QFeel& ref) const
{
  DOBS("packDataDiff QFeel");
  ::dueca::IndexMemory im;
  ::dueca::checkandpackdiffiterable(this->mom_offset, ref.mom_offset, s, im,
                          dueca::diffpack_traits<dueca::fixvector<6,float> >());
  ::dueca::checkandpackdiffiterable(this->pos_offset, ref.pos_offset, s, im,
                          dueca::diffpack_traits<dueca::fixvector<6,float> >());
  ::dueca::checkandpackdiffiterable(this->extra_spring, ref.extra_spring, s, im,
                          dueca::diffpack_traits<dueca::fixvector<6,float> >());
  ::dueca::checkandpackdiffiterable(this->extra_damping, ref.extra_damping, s, im,
                          dueca::diffpack_traits<dueca::fixvector<6,float> >());
  im.closeoff(s);
}
#endif

#if !defined(__CUSTOM_FUNCTION_UNPACKDATA) && !defined(__DCO_NOPACK)
void QFeel::unPackData(::dueca::AmorphReStore& s)
{
  DOBS("unPackData QFeel");


  ::dueca::unpackiterable(s, this->mom_offset,
                          dueca::pack_traits<dueca::fixvector<6,float> >()); 
  ::dueca::unpackiterable(s, this->pos_offset,
                          dueca::pack_traits<dueca::fixvector<6,float> >()); 
  ::dueca::unpackiterable(s, this->extra_spring,
                          dueca::pack_traits<dueca::fixvector<6,float> >()); 
  ::dueca::unpackiterable(s, this->extra_damping,
                          dueca::pack_traits<dueca::fixvector<6,float> >()); 
}
#endif

#if !defined(__CUSTOM_FUNCTION_UNPACKDATADIFF) && !defined(__DCO_NOPACK)
void QFeel::unPackDataDiff(dueca::AmorphReStore& s)
{
  DOBS("unPackDataDiff QFeel");
  ::dueca::IndexRecall im;
  ::dueca::checkandunpackdiffiterable(this->mom_offset, s, im,
                          dueca::diffpack_traits<dueca::fixvector<6,float> >());
  ::dueca::checkandunpackdiffiterable(this->pos_offset, s, im,
                          dueca::diffpack_traits<dueca::fixvector<6,float> >());
  ::dueca::checkandunpackdiffiterable(this->extra_spring, s, im,
                          dueca::diffpack_traits<dueca::fixvector<6,float> >());
  ::dueca::checkandunpackdiffiterable(this->extra_damping, s, im,
                          dueca::diffpack_traits<dueca::fixvector<6,float> >());
}
#endif

#ifndef __CUSTOM_OPERATOR_EQUAL
bool QFeel::operator == (const QFeel& other) const
{
  DOBS("operator == QFeel");
  if (this->mom_offset != other.mom_offset) return false;
  if (this->pos_offset != other.pos_offset) return false;
  if (this->extra_spring != other.extra_spring) return false;
  if (this->extra_damping != other.extra_damping) return false;
  return true;
}
#endif

#ifndef __CUSTOM_OPERATOR_ASSIGN
QFeel&
QFeel::operator=(const QFeel& other)
{
  DOBS("operator = QFeel");
  if (this == &other) return *this;
  this->mom_offset = other.mom_offset;
  this->pos_offset = other.pos_offset;
  this->extra_spring = other.extra_spring;
  this->extra_damping = other.extra_damping;
  return *this;
}
#endif

#if !defined(__CUSTOM_FUNCTION_PACKDATA) && !defined(__DCO_NOPACK)
void QFeel::packData(::dueca::AmorphStore& s) const
{
  DOBS("packData QFeel");
  ::dueca::packiterable(s, this->mom_offset,
                        dueca::pack_traits<dueca::fixvector<6,float> >()); 
  ::dueca::packiterable(s, this->pos_offset,
                        dueca::pack_traits<dueca::fixvector<6,float> >()); 
  ::dueca::packiterable(s, this->extra_spring,
                        dueca::pack_traits<dueca::fixvector<6,float> >()); 
  ::dueca::packiterable(s, this->extra_damping,
                        dueca::pack_traits<dueca::fixvector<6,float> >()); 
}
#endif

#ifndef __CUSTOM_FUNCTION_PRINT
std::ostream & QFeel::print(std::ostream& s) const
{
  s << "QFeel("
    << "mom_offset={";
  for (dueca::fixvector<6,float>::const_iterator ii = this->mom_offset.begin();
       ii != this->mom_offset.end(); ii++) {
    if (ii != this->mom_offset.begin()) s << ',';
    s << (*ii);
  }
  s << "},"
    << "pos_offset={";
  for (dueca::fixvector<6,float>::const_iterator ii = this->pos_offset.begin();
       ii != this->pos_offset.end(); ii++) {
    if (ii != this->pos_offset.begin()) s << ',';
    s << (*ii);
  }
  s << "},"
    << "extra_spring={";
  for (dueca::fixvector<6,float>::const_iterator ii = this->extra_spring.begin();
       ii != this->extra_spring.end(); ii++) {
    if (ii != this->extra_spring.begin()) s << ',';
    s << (*ii);
  }
  s << "},"
    << "extra_damping={";
  for (dueca::fixvector<6,float>::const_iterator ii = this->extra_damping.begin();
       ii != this->extra_damping.end(); ii++) {
    if (ii != this->extra_damping.begin()) s << ',';
    s << (*ii);
  }
  s << "}"
    << ')';
  return s;
}
#endif


#if defined(DUECA_CONFIG_HDF5)
// guarded in a separate namespace
namespace QFeel_space {

#if !defined(__CUSTOM_HDF5_WRITE_FUNCTOR)
  HDF5DCOWriteFunctor::
  HDF5DCOWriteFunctor(boost::weak_ptr<H5::H5File> file,
                      const std::string& path,
                      size_t chunksize,
                      const std::string& label,
                      bool compress, bool writeticks,
                      const dueca::DataTimeSpec* startend) :
    dueca::hdf5log::HDF5DCOWriteFunctor(file, path, chunksize, label,
                               4, compress, writeticks,
                               startend)
  {
    // add memspaces for all elements

    this->configureDataSet(0, "/data/mom_offset",
                           HOFFSET(QFeel, mom_offset),
                           dueca::get_hdf5_elt_type(example.mom_offset),
                           dueca::get_hdf5_elt_length(example.mom_offset));

    this->configureDataSet(1, "/data/pos_offset",
                           HOFFSET(QFeel, pos_offset),
                           dueca::get_hdf5_elt_type(example.pos_offset),
                           dueca::get_hdf5_elt_length(example.pos_offset));

    this->configureDataSet(2, "/data/extra_spring",
                           HOFFSET(QFeel, extra_spring),
                           dueca::get_hdf5_elt_type(example.extra_spring),
                           dueca::get_hdf5_elt_length(example.extra_spring));

    this->configureDataSet(3, "/data/extra_damping",
                           HOFFSET(QFeel, extra_damping),
                           dueca::get_hdf5_elt_type(example.extra_damping),
                           dueca::get_hdf5_elt_length(example.extra_damping));

    if (writeticks) {
      dueca::TimeTickType tex;
      this->configureDataSet(4, "/tick", 0,
                             dueca::get_hdf5_elt_type(tex), 1);
    }
  }

  // the functor member used by channel reading code, writes data in HDF5 file
  bool HDF5DCOWriteFunctor::operator() (const void* dpointer,
                                        const dueca::DataTimeSpec& ts)
  {
    while (ts.getValidityEnd() <= startend->getValidityStart()) {
      return true;
    }
    if (ts.getValidityStart() >= startend->getValidityEnd()) {
      return false;
    }
    this->prepareRow();

    this->sets[0].writeNew(dpointer, chunkidx, example.mom_offset);

    this->sets[1].writeNew(dpointer, chunkidx, example.pos_offset);

    this->sets[2].writeNew(dpointer, chunkidx, example.extra_spring);

    this->sets[3].writeNew(dpointer, chunkidx, example.extra_damping);

    if (writeticks) {
      this->sets[4].writeNew(&ts);
    }
    return true;
  }
#endif


#if !defined(__CUSTOM_HDF5_READ_FUNCTOR)
  HDF5DCOReadFunctor::
  HDF5DCOReadFunctor(boost::weak_ptr<H5::H5File> file,
                     const std::string& path,
                     bool readticks) :
    dueca::hdf5log::HDF5DCOReadFunctor(file, path,
                              4, readticks)
  {
    // add memspaces for all elements

    this->configureDataSet(0, "/data/mom_offset",
                           HOFFSET(QFeel, mom_offset),
                           dueca::get_hdf5_elt_type(example.mom_offset),
                           dueca::get_hdf5_elt_length(example.mom_offset));

    this->configureDataSet(1, "/data/pos_offset",
                           HOFFSET(QFeel, pos_offset),
                           dueca::get_hdf5_elt_type(example.pos_offset),
                           dueca::get_hdf5_elt_length(example.pos_offset));

    this->configureDataSet(2, "/data/extra_spring",
                           HOFFSET(QFeel, extra_spring),
                           dueca::get_hdf5_elt_type(example.extra_spring),
                           dueca::get_hdf5_elt_length(example.extra_spring));

    this->configureDataSet(3, "/data/extra_damping",
                           HOFFSET(QFeel, extra_damping),
                           dueca::get_hdf5_elt_type(example.extra_damping),
                           dueca::get_hdf5_elt_length(example.extra_damping));

    if (readticks) {
      dueca::TimeTickType tex;
      this->configureDataSet(4, "/tick", 0,
                             dueca::get_hdf5_elt_type(tex), 1);
    }
  }

  bool HDF5DCOReadFunctor::operator() (void* dpointer)
  {

    this->sets[0].readObjectPart(dpointer, example.mom_offset);

    this->sets[1].readObjectPart(dpointer, example.pos_offset);

    this->sets[2].readObjectPart(dpointer, example.extra_spring);

    this->sets[3].readObjectPart(dpointer, example.extra_damping);

    return true;
  }
#endif


  /** Metafunctor, can be accessed through the table, and can
      produce a functor object and the HDF5 data type */
  class HDF5DCOMetaFunctor: public dueca::hdf5log::HDF5DCOMetaFunctor
  {
    HDF5DCOWriteFunctor* getWriteFunctor(boost::weak_ptr<H5::H5File> file,
                                         const std::string& path,
                                         size_t chunksize,
                                         const std::string& label,
                                         const dueca::DataTimeSpec* startend,
                                         bool compress,
                                         bool writeticks=true)
    {
      return new HDF5DCOWriteFunctor(file, path, chunksize, label,
                                     compress, writeticks, startend);
    }

    HDF5DCOReadFunctor* getReadFunctor(boost::weak_ptr<H5::H5File> file,
                                       const std::string& path,
                                       bool writeticks=true)
    {
      return new HDF5DCOReadFunctor(file, path, writeticks);
    }

  };

#if !defined(__DCO_STANDALONE)
  // loads the metafunctor in the table
  static dueca::LoadMetaFunctor<HDF5DCOMetaFunctor>
    load_functor(functortable, "hdf5");
#endif
} // end namespace QFeel_space
#endif

