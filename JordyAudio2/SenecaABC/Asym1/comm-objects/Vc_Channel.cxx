/* ------------------------------------------------------------------ */
/*      item            : Vc_Channel.cxx
        generated by    : matteo (matteo)
        date            : Thu 24 Mar 2022
        category        : body file
        description     : DUECA Communication Object (DCO),
                          automatically generated by dueca-codegen
        codegen version : 110
        language        : C++
*/

#include "Vc_Channel.hxx"
#include <iostream>
#include <cassert>
#if !defined(__DCO_NOPACK)
#include <AmorphStore.hxx>
#include <PackUnpackTemplates.hxx>
#endif
#include <DataWriterArraySize.hxx>
#define DOBS(A)
#if !defined(__DCO_STANDALONE)
#include <Arena.hxx>
#include <ArenaPool.hxx>
#include <DataClassRegistrar.hxx>
#include <CommObjectMemberAccess.hxx>
#include <DCOFunctor.hxx>
#include <DCOMetaFunctor.hxx>

#define DO_INSTANTIATE
#include <DataSetSubsidiary.hxx>
#endif




#if !defined(__DCO_STANDALONE)
// static CommObjectMemberAccess objects, that can provide flexible access
// to the members of a Vc_Channel object
static ::dueca::CommObjectMemberAccess
  <Vc_Channel,bool >
  Vc_Channel_member_Threshold(&Vc_Channel::Threshold, "Threshold");
static ::dueca::CommObjectMemberAccess
  <Vc_Channel,bool >
  Vc_Channel_member_Reduce_left(&Vc_Channel::Reduce_left, "Reduce_left");
static ::dueca::CommObjectMemberAccess
  <Vc_Channel,bool >
  Vc_Channel_member_Reduce_right(&Vc_Channel::Reduce_right, "Reduce_right");
static ::dueca::CommObjectMemberAccess
  <Vc_Channel,float >
  Vc_Channel_member_Vc_1(&Vc_Channel::Vc_1, "Vc_1");
static ::dueca::CommObjectMemberAccess
  <Vc_Channel,float >
  Vc_Channel_member_Vc_2(&Vc_Channel::Vc_2, "Vc_2");
static ::dueca::CommObjectMemberAccess
  <Vc_Channel,int >
  Vc_Channel_member_Threshold_param(&Vc_Channel::Threshold_param, "Threshold_param");

// assemble the above entries into a table in the order in which they
// appear in the Vc_Channel object
static const ::dueca::CommObjectDataTable entriestable[] = {
  { &Vc_Channel_member_Threshold },
  { &Vc_Channel_member_Reduce_left },
  { &Vc_Channel_member_Reduce_right },
  { &Vc_Channel_member_Vc_1 },
  { &Vc_Channel_member_Vc_2 },
  { &Vc_Channel_member_Threshold_param },
  { NULL }
};

#endif

// class name, static
const char * const Vc_Channel::classname = "Vc_Channel";

// magic number, hashed from class name and member names / classes
const uint32_t Vc_Channel::magic_check_number=0xab451aa5;

#if !defined(__DCO_STANDALONE)
// functor table, provides access to user-defined metafunctions through the
// data class registry
static dueca::functortable_type functortable;

// register this class, provides access to a packing/unpacking object,
// and to the member access tables
static ::dueca::DataClassRegistrar registrar
  (Vc_Channel::classname, NULL,
   entriestable, &functortable,
   new ::dueca::DataSetSubsidiary<Vc_Channel>());

#endif

#ifndef __CUSTOM_DEFAULT_CONSTRUCTOR
Vc_Channel::Vc_Channel()
{
  DOBS("default constructor Vc_Channel");
}
#endif

#ifndef __CUSTOM_FULL_CONSTRUCTOR
Vc_Channel::Vc_Channel(
        const bool& Threshold,
        const bool& Reduce_left,
        const bool& Reduce_right,
        const float& Vc_1,
        const float& Vc_2,
        const int& Threshold_param) :
    Threshold(Threshold),
    Reduce_left(Reduce_left),
    Reduce_right(Reduce_right),
    Vc_1(Vc_1),
    Vc_2(Vc_2),
    Threshold_param(Threshold_param)
{
  DOBS("complete constructor Vc_Channel");
}
#endif

#ifndef __CUSTOM_FULLSINGLES_CONSTRUCTOR
#endif

#ifndef __CUSTOM_COPY_CONSTRUCTOR
Vc_Channel::Vc_Channel(const Vc_Channel& other):
    Threshold(other.Threshold),
    Reduce_left(other.Reduce_left),
    Reduce_right(other.Reduce_right),
    Vc_1(other.Vc_1),
    Vc_2(other.Vc_2),
    Threshold_param(other.Threshold_param)
{
  DOBS("copy constructor Vc_Channel");
}
#endif

#if !defined(__CUSTOM_AMORPHRESTORE_CONSTRUCTOR) && !defined(__DCO_NOPACK)
Vc_Channel::Vc_Channel(dueca::AmorphReStore& s):
        Threshold(s),
        Reduce_left(s),
        Reduce_right(s),
        Vc_1(s),
        Vc_2(s),
        Threshold_param(s)
{
  DOBS("amorph constructor Vc_Channel");
}
#endif

#if !defined(__CUSTOM_ARRAY_SIZE_INIT_CONSTRUCTOR)
#endif

#ifndef __CUSTOM_DESTRUCTOR
Vc_Channel::~Vc_Channel()
{
  DOBS("destructor Vc_Channel");
}
#endif

#if !defined(__DCO_STANDALONE)
void* Vc_Channel::operator new(size_t size)
{
  DOBS("operator new Vc_Channel");
  static ::dueca::Arena* my_arena = arena_pool.findArena
    (sizeof(Vc_Channel));
  return my_arena->alloc(size);
}

void Vc_Channel::operator delete(void* v)
{
  DOBS("operator delete Vc_Channel");
  static ::dueca::Arena* my_arena = arena_pool.findArena
    (sizeof(Vc_Channel));
  my_arena->free(v);
}
#endif

#if !defined(__CUSTOM_FUNCTION_PACKDATADIFF) && !defined(__DCO_NOPACK)
void Vc_Channel::packDataDiff(::dueca::AmorphStore& s, const Vc_Channel& ref) const
{
  DOBS("packDataDiff Vc_Channel");
  ::dueca::IndexMemory im;
  ::dueca::checkandpackdiffsingle(this->Threshold, ref.Threshold,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->Reduce_left, ref.Reduce_left,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->Reduce_right, ref.Reduce_right,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->Vc_1, ref.Vc_1,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->Vc_2, ref.Vc_2,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->Threshold_param, ref.Threshold_param,
                         s, im);
  im.closeoff(s);
}
#endif

#if !defined(__CUSTOM_FUNCTION_UNPACKDATA) && !defined(__DCO_NOPACK)
void Vc_Channel::unPackData(::dueca::AmorphReStore& s)
{
  DOBS("unPackData Vc_Channel");

  ::unPackData(s, this->Threshold);
  ::unPackData(s, this->Reduce_left);
  ::unPackData(s, this->Reduce_right);
  ::unPackData(s, this->Vc_1);
  ::unPackData(s, this->Vc_2);
  ::unPackData(s, this->Threshold_param);

}
#endif

#if !defined(__CUSTOM_FUNCTION_UNPACKDATADIFF) && !defined(__DCO_NOPACK)
void Vc_Channel::unPackDataDiff(dueca::AmorphReStore& s)
{
  DOBS("unPackDataDiff Vc_Channel");
  ::dueca::IndexRecall im;
  ::dueca::checkandunpackdiffsingle(this->Threshold, s, im);
  ::dueca::checkandunpackdiffsingle(this->Reduce_left, s, im);
  ::dueca::checkandunpackdiffsingle(this->Reduce_right, s, im);
  ::dueca::checkandunpackdiffsingle(this->Vc_1, s, im);
  ::dueca::checkandunpackdiffsingle(this->Vc_2, s, im);
  ::dueca::checkandunpackdiffsingle(this->Threshold_param, s, im);
}
#endif

#ifndef __CUSTOM_OPERATOR_EQUAL
bool Vc_Channel::operator == (const Vc_Channel& other) const
{
  DOBS("operator == Vc_Channel");
  if (this->Threshold != other.Threshold) return false;
  if (this->Reduce_left != other.Reduce_left) return false;
  if (this->Reduce_right != other.Reduce_right) return false;
  if (this->Vc_1 != other.Vc_1) return false;
  if (this->Vc_2 != other.Vc_2) return false;
  if (this->Threshold_param != other.Threshold_param) return false;
  return true;
}
#endif

#ifndef __CUSTOM_OPERATOR_ASSIGN
Vc_Channel&
Vc_Channel::operator=(const Vc_Channel& other)
{
  DOBS("operator = Vc_Channel");
  if (this == &other) return *this;
  this->Threshold = other.Threshold;
  this->Reduce_left = other.Reduce_left;
  this->Reduce_right = other.Reduce_right;
  this->Vc_1 = other.Vc_1;
  this->Vc_2 = other.Vc_2;
  this->Threshold_param = other.Threshold_param;
  return *this;
}
#endif

#if !defined(__CUSTOM_FUNCTION_PACKDATA) && !defined(__DCO_NOPACK)
void Vc_Channel::packData(::dueca::AmorphStore& s) const
{
  DOBS("packData Vc_Channel");
  ::packData(s, this->Threshold);
  ::packData(s, this->Reduce_left);
  ::packData(s, this->Reduce_right);
  ::packData(s, this->Vc_1);
  ::packData(s, this->Vc_2);
  ::packData(s, this->Threshold_param);
}
#endif

#ifndef __CUSTOM_FUNCTION_PRINT
std::ostream & Vc_Channel::print(std::ostream& s) const
{
  s << "Vc_Channel("
    << "Threshold=" << this->Threshold << ','
    << "Reduce_left=" << this->Reduce_left << ','
    << "Reduce_right=" << this->Reduce_right << ','
    << "Vc_1=" << this->Vc_1 << ','
    << "Vc_2=" << this->Vc_2 << ','
    << "Threshold_param=" << this->Threshold_param
    << ')';
  return s;
}
#endif


