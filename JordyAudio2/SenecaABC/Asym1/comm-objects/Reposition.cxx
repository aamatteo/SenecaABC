/* ------------------------------------------------------------------ */
/*      item            : Reposition.cxx
        generated by    : matteo (matteo)
        date            : Thu 24 Mar 2022
        category        : body file
        description     : DUECA Communication Object (DCO),
                          automatically generated by dueca-codegen
        codegen version : 110
        language        : C++
*/

#include "Reposition.hxx"
#include <iostream>
#include <cassert>
#if !defined(__DCO_NOPACK)
#include <AmorphStore.hxx>
#include <PackUnpackTemplates.hxx>
#endif
#include <DataWriterArraySize.hxx>
#define DOBS(A)
#if !defined(__DCO_STANDALONE)
#include <Arena.hxx>
#include <ArenaPool.hxx>
#include <DataClassRegistrar.hxx>
#include <CommObjectMemberAccess.hxx>
#include <DCOFunctor.hxx>
#include <DCOMetaFunctor.hxx>

#define DO_INSTANTIATE
#include <DataSetSubsidiary.hxx>
#endif




#if !defined(__DCO_STANDALONE)
// static CommObjectMemberAccess objects, that can provide flexible access
// to the members of a Reposition object
static ::dueca::CommObjectMemberAccess
  <Reposition,float >
  Reposition_member_repos_x(&Reposition::repos_x, "repos_x");
static ::dueca::CommObjectMemberAccess
  <Reposition,float >
  Reposition_member_repos_y(&Reposition::repos_y, "repos_y");
static ::dueca::CommObjectMemberAccess
  <Reposition,float >
  Reposition_member_repos_h(&Reposition::repos_h, "repos_h");
static ::dueca::CommObjectMemberAccess
  <Reposition,float >
  Reposition_member_repos_psi(&Reposition::repos_psi, "repos_psi");

// assemble the above entries into a table in the order in which they
// appear in the Reposition object
static const ::dueca::CommObjectDataTable entriestable[] = {
  { &Reposition_member_repos_x },
  { &Reposition_member_repos_y },
  { &Reposition_member_repos_h },
  { &Reposition_member_repos_psi },
  { NULL }
};

#endif

// class name, static
const char * const Reposition::classname = "Reposition";

// magic number, hashed from class name and member names / classes
const uint32_t Reposition::magic_check_number=0x24a8e3f9;

#if !defined(__DCO_STANDALONE)
// functor table, provides access to user-defined metafunctions through the
// data class registry
static dueca::functortable_type functortable;

// register this class, provides access to a packing/unpacking object,
// and to the member access tables
static ::dueca::DataClassRegistrar registrar
  (Reposition::classname, NULL,
   entriestable, &functortable,
   new ::dueca::DataSetSubsidiary<Reposition>());

#endif

#ifndef __CUSTOM_DEFAULT_CONSTRUCTOR
Reposition::Reposition()
{
  DOBS("default constructor Reposition");
}
#endif

#ifndef __CUSTOM_FULL_CONSTRUCTOR
Reposition::Reposition(
        const float& repos_x,
        const float& repos_y,
        const float& repos_h,
        const float& repos_psi) :
    repos_x(repos_x),
    repos_y(repos_y),
    repos_h(repos_h),
    repos_psi(repos_psi)
{
  DOBS("complete constructor Reposition");
}
#endif

#ifndef __CUSTOM_FULLSINGLES_CONSTRUCTOR
#endif

#ifndef __CUSTOM_COPY_CONSTRUCTOR
Reposition::Reposition(const Reposition& other):
    repos_x(other.repos_x),
    repos_y(other.repos_y),
    repos_h(other.repos_h),
    repos_psi(other.repos_psi)
{
  DOBS("copy constructor Reposition");
}
#endif

#if !defined(__CUSTOM_AMORPHRESTORE_CONSTRUCTOR) && !defined(__DCO_NOPACK)
Reposition::Reposition(dueca::AmorphReStore& s):
        repos_x(s),
        repos_y(s),
        repos_h(s),
        repos_psi(s)
{
  DOBS("amorph constructor Reposition");
}
#endif

#if !defined(__CUSTOM_ARRAY_SIZE_INIT_CONSTRUCTOR)
#endif

#ifndef __CUSTOM_DESTRUCTOR
Reposition::~Reposition()
{
  DOBS("destructor Reposition");
}
#endif

#if !defined(__DCO_STANDALONE)
void* Reposition::operator new(size_t size)
{
  DOBS("operator new Reposition");
  static ::dueca::Arena* my_arena = arena_pool.findArena
    (sizeof(Reposition));
  return my_arena->alloc(size);
}

void Reposition::operator delete(void* v)
{
  DOBS("operator delete Reposition");
  static ::dueca::Arena* my_arena = arena_pool.findArena
    (sizeof(Reposition));
  my_arena->free(v);
}
#endif

#if !defined(__CUSTOM_FUNCTION_PACKDATADIFF) && !defined(__DCO_NOPACK)
void Reposition::packDataDiff(::dueca::AmorphStore& s, const Reposition& ref) const
{
  DOBS("packDataDiff Reposition");
  ::dueca::IndexMemory im;
  ::dueca::checkandpackdiffsingle(this->repos_x, ref.repos_x,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->repos_y, ref.repos_y,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->repos_h, ref.repos_h,
                         s, im);
  ::dueca::checkandpackdiffsingle(this->repos_psi, ref.repos_psi,
                         s, im);
  im.closeoff(s);
}
#endif

#if !defined(__CUSTOM_FUNCTION_UNPACKDATA) && !defined(__DCO_NOPACK)
void Reposition::unPackData(::dueca::AmorphReStore& s)
{
  DOBS("unPackData Reposition");

  ::unPackData(s, this->repos_x);
  ::unPackData(s, this->repos_y);
  ::unPackData(s, this->repos_h);
  ::unPackData(s, this->repos_psi);

}
#endif

#if !defined(__CUSTOM_FUNCTION_UNPACKDATADIFF) && !defined(__DCO_NOPACK)
void Reposition::unPackDataDiff(dueca::AmorphReStore& s)
{
  DOBS("unPackDataDiff Reposition");
  ::dueca::IndexRecall im;
  ::dueca::checkandunpackdiffsingle(this->repos_x, s, im);
  ::dueca::checkandunpackdiffsingle(this->repos_y, s, im);
  ::dueca::checkandunpackdiffsingle(this->repos_h, s, im);
  ::dueca::checkandunpackdiffsingle(this->repos_psi, s, im);
}
#endif

#ifndef __CUSTOM_OPERATOR_EQUAL
bool Reposition::operator == (const Reposition& other) const
{
  DOBS("operator == Reposition");
  if (this->repos_x != other.repos_x) return false;
  if (this->repos_y != other.repos_y) return false;
  if (this->repos_h != other.repos_h) return false;
  if (this->repos_psi != other.repos_psi) return false;
  return true;
}
#endif

#ifndef __CUSTOM_OPERATOR_ASSIGN
Reposition&
Reposition::operator=(const Reposition& other)
{
  DOBS("operator = Reposition");
  if (this == &other) return *this;
  this->repos_x = other.repos_x;
  this->repos_y = other.repos_y;
  this->repos_h = other.repos_h;
  this->repos_psi = other.repos_psi;
  return *this;
}
#endif

#if !defined(__CUSTOM_FUNCTION_PACKDATA) && !defined(__DCO_NOPACK)
void Reposition::packData(::dueca::AmorphStore& s) const
{
  DOBS("packData Reposition");
  ::packData(s, this->repos_x);
  ::packData(s, this->repos_y);
  ::packData(s, this->repos_h);
  ::packData(s, this->repos_psi);
}
#endif

#ifndef __CUSTOM_FUNCTION_PRINT
std::ostream & Reposition::print(std::ostream& s) const
{
  s << "Reposition("
    << "repos_x=" << this->repos_x << ','
    << "repos_y=" << this->repos_y << ','
    << "repos_h=" << this->repos_h << ','
    << "repos_psi=" << this->repos_psi
    << ')';
  return s;
}
#endif


