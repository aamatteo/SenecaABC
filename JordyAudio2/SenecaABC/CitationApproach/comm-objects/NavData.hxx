/* ------------------------------------------------------------------ */
/*      item            : NavData.hxx
        generated by    : matteo (matteo)
        date            : Thu 24 Mar 2022
        category        : header file
        description     : DUECA Communication Object (DCO)
                          automatically generated by dueca-codegen
        codegen version : 110
        language        : C++
*/

#ifndef NavData_hxx
#define NavData_hxx

#include <inttypes.h>

#if !defined(__DCO_NOPACK)
namespace dueca {
class AmorphStore;
class AmorphReStore;
struct DataWriterArraySize;
};
#endif
#if !defined(__DCO_STANDALONE)
namespace dueca {
struct CommObjectDataTable;
};
#include <gencodegen.h>
#if GENCODEGEN != 110
#error "Generated NavData.hxx too old, please clean with 'make mrproper'"
#endif
#include <CommObjectTraits.hxx>
#endif
#include <iostream>




/** An automatically generated class
    */
struct NavData
{
  /** typedef for internal reference */
  typedef NavData __ThisDCOType__;

public:
  /** The name of this class. */
  static const char* const classname;


  /** Enumerated type for an automatically generated object class */
  enum to_from {
    NODIR,
    TO,
    FROM
  };

  /** be careful to not make this info redundant
 */
  enum efis_modes {
    NONE,
    HDG,
    LNAV,
    LOC,
    ALT
  };

  /** A class member */
  float ils_loc_dev;

  /** A class member */
  float ils_gs_dev;

  /** A class member */
  float course_dev;

  /** A class member */
  float course_ref;

  /** A class member */
  to_from direction;

  /** A class member */
  float heading_ref;

  /** A class member */
  float speed_ref;

  /** A class member */
  float alt_ref;

  /** (char next_waypoint) */
  float distance;

  /** A class member */
  float time2go;

  /** A class member */
  efis_modes lateral_mode;

  /** A class member */
  efis_modes armed_lateral_mode;

  /** A class member */
  efis_modes vertical_mode;

  /** A class member */
  efis_modes armed_vertical_mode;

public:
  /** a "magic" number, hashed out of the class definition,
      that will be used to check consistency of the sent objects
      across the dueca nodes. */
  static const uint32_t magic_check_number;

  /** default constructor. */
  NavData();

  /** Constructor with arguments */
  NavData(
        const float& ils_loc_dev,
        const float& ils_gs_dev,
        const float& course_dev,
        const float& course_ref,
        const to_from& direction,
        const float& heading_ref,
        const float& speed_ref,
        const float& alt_ref,
        const float& distance,
        const float& time2go,
        const efis_modes& lateral_mode,
        const efis_modes& armed_lateral_mode,
        const efis_modes& vertical_mode,
        const efis_modes& armed_vertical_mode);

  /** copy constructor. */
  NavData(const NavData& o);

#if !defined(__DCO_NOPACK)
  /** constructor to restore an NavData from amorphous storage. */
  NavData(dueca::AmorphReStore& r);
#endif

  /** destructor. */
  ~NavData();

#if !defined(__DCO_STANDALONE)
  /** new operator "new", which places objects not on a
      heap, but in one of the memory arenas. This to speed up
      memory management. */
  static void* operator new(size_t size);

  /** new operator "delete", to go with the new version
      of operator new. */
  static void operator delete(void* p);

  /** placement "new", needed for stl. */
  inline static void* operator new(size_t size, NavData*& o)
  { return reinterpret_cast<void*>(o); }
#endif

#if !defined(__DCO_NOPACK)
  /** packs the NavData into amorphous storage. */
  void packData(::dueca::AmorphStore& s) const;

  /** packs the NavData into amorphous storage.
      only differences with a previous object are packed. */
  void packDataDiff(::dueca::AmorphStore& s, const NavData& ref) const;

  /** unpacks the NavData from an amorphous storage. */
  void unPackData(::dueca::AmorphReStore& s);

  /** unpacks the differences for NavData
      from an amorphous storage. */
  void unPackDataDiff(::dueca::AmorphReStore& s);
#endif

  /** Test for equality. */
  bool operator == (const NavData& o) const;

  /** Test for inequality. */
  inline bool operator != (const NavData& o) const
  { return !(*this == o); }

  /** Assignment operator. */
  NavData& operator=(const NavData& o);

  /** prints the NavData to a stream. */
  std::ostream & print(std::ostream& s) const;
};

#if !defined(__DCO_NOPACK)
/** pack the object into amorphous storage. */
inline void packData(::dueca::AmorphStore& s,
                     const NavData& o)
{ o.packData(s); }

/** pack the differences between this object and another
    into amorphous storage. */
inline void packDataDiff(dueca::AmorphStore& s,
                         const NavData& o,
                         const NavData& ref)
{ o.packDataDiff(s, ref); }

/** unpack the object from amorphous storage. */
inline void unPackData(::dueca::AmorphReStore& s,
                       NavData& o)
{ o.unPackData(s); }

/** unpack the differences to this object from storage. */
inline void unPackDataDiff(dueca::AmorphReStore& s,
                           NavData& o)
{ o.unPackDataDiff(s); }
#endif

const char* const getString(const NavData::to_from &o);
void readFromString(NavData::to_from &o, const std::string& s);
#if !defined(__DCO_NOPACK)
void packData(::dueca::AmorphStore& s,
              const NavData::to_from &o);
void unPackData(::dueca::AmorphReStore& s,
                NavData::to_from &o);
#endif
namespace dueca {
  template <>
  const char* getclassname<NavData::to_from>();
};

PRINT_NS_START;
inline std::ostream&
operator << (std::ostream& s, const NavData::to_from& o)
{ return s << getString(o); }
inline std::istream&
operator >> (std::istream& s, NavData::to_from& o)
{ std::string tmp; s >> tmp; readFromString(o, tmp); return s; }
PRINT_NS_END;

const char* const getString(const NavData::efis_modes &o);
void readFromString(NavData::efis_modes &o, const std::string& s);
#if !defined(__DCO_NOPACK)
void packData(::dueca::AmorphStore& s,
              const NavData::efis_modes &o);
void unPackData(::dueca::AmorphReStore& s,
                NavData::efis_modes &o);
#endif
namespace dueca {
  template <>
  const char* getclassname<NavData::efis_modes>();
};

PRINT_NS_START;
inline std::ostream&
operator << (std::ostream& s, const NavData::efis_modes& o)
{ return s << getString(o); }
inline std::istream&
operator >> (std::istream& s, NavData::efis_modes& o)
{ std::string tmp; s >> tmp; readFromString(o, tmp); return s; }
PRINT_NS_END;

namespace std {
/** print to a stream. */
inline std::ostream &
operator << (std::ostream& s, const NavData& o)
{ return o.print(s); }
};

#if !defined(__DCO_STANDALONE)
namespace dueca {
/** Template specialization, defines a trait that is needed if
    NavData is ever used inside other dco objects. */
template <>
struct dco_nested<NavData> : public dco_isnested { };
template <>
struct dco_nested< NavData::to_from > : public dco_isenum { };
template <>
struct dco_nested< NavData::efis_modes > : public dco_isenum { };
};
#endif


#endif
